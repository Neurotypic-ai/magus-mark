---
description: Testing strategies and approaches for Obsidian Magic
globs: **/*.test.ts,**/*.spec.ts,**/vitest.config.*
alwaysApply: false
---

# Testing Strategy

The project implements a comprehensive testing strategy using Vitest, a Vite-native test runner:

## Test Organization

We use co-located tests, placing test files directly alongside the source code they test:

```
obsidian-magic/
├── apps/
│   ├── cli/
│   │   └── src/
│   │       └── commands/
│   │           ├── tag-command.ts
│   │           └── tag-command.test.ts    # Test alongside implementation
│   ├── obsidian-plugin/
│   │   └── src/
│   │       ├── services/
│   │       │   ├── tagging-service.ts
│   │       │   └── tagging-service.test.ts
│   │       └── ui/
│   │           ├── components/
│   │           │   ├── TagEditor.tsx
│   │           │   └── TagEditor.test.tsx
├── packages/
│   ├── core/
│   │   └── src/
│   │       ├── tagging/
│   │       │   ├── classifier.ts
│   │       │   └── classifier.test.ts     # Test alongside code
│   │       ├── openai/
│   │       │   ├── client.ts
│   │       │   └── client.test.ts
│   │       └── integration.test.ts        # Integration tests near related code
│   ├── testing/ # Shared testing utilities
│   ├── types/
│   └── utils/
└── vitest.workspace.js # Workspace configuration
```

## VS Code Integration

We use VS Code file nesting to keep the explorer view clean while maintaining the co-location approach:

```json
"explorer.fileNesting.enabled": true,
"explorer.fileNesting.patterns": {
  "*.ts": "${capture}.test.ts, ${capture}.spec.ts, ${capture}.d.ts"
}
```

This visually groups test files with their source files in the explorer.

## Vitest Setup

We use Vitest workspace mode for efficient test running across packages:

```javascript
// vitest.workspace.js
import { defineWorkspace } from 'vitest/config'

export default defineWorkspace([
  "./packages/*/vitest.config.ts",
  "./apps/*/vitest.config.ts",
])
```

Each package and app has its own `vitest.config.ts` with specific configurations:

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    include: ['**/*.{test,spec}.{ts,tsx}'], // Find all test files
    globals: true,
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage'
    }
  }
});
```

## Unit Tests

- Component-level tests with Vitest
- Mocked dependencies via `vi.mock()` and `vi.spyOn()`
- High coverage of core business logic
- Consistent use of `describe`/`it` blocks for organization
- Type-safe testing with TypeScript

## Integration Tests

- Cross-component integration testing
- API interaction testing with mocked responses
- File system operation testing with fs-extra mocks
- Testing service composition and interaction

## End-to-End Tests

- CLI workflow testing
- Plugin installation and operation testing
- Extension activation and operation testing
- Controlled API testing

## Mocking Strategy

### Module Mocking

We use Vitest's mocking capabilities to mock modules:

```typescript
// Mock fs-extra module
vi.mock('fs-extra', () => ({
  ensureDir: vi.fn(),
  readFile: vi.fn(),
  writeFile: vi.fn(),
  access: vi.fn(),
  readdir: vi.fn(),
  stat: vi.fn(),
  unlink: vi.fn()
}));

// Mock a custom module
vi.mock('../logger', () => ({
  logger: {
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn(),
    configure: vi.fn()
  }
}));
```

### Service Mocking

We use dependency injection and the shared testing package for consistent mocks:

```typescript
import { createMockTagSet, createMockOpenAIConfig } from '@obsidian-magic/testing';

// Create consistent mock data
const mockTagSet = createMockTagSet({
  year: '2024',
  conversation_type: 'theoretical'
});

// Create service with mocked dependencies
const service = createTaggingService({
  openAIConfig: createMockOpenAIConfig(),
  // Other dependencies
});
```

## Shared Testing Utilities

We maintain a dedicated `@obsidian-magic/testing` package for:

- Factory functions for test data
- Mock service implementations
- Utility functions for test setup
- Shared fixtures and helpers

This promotes consistency and reduces duplication across tests.

## Testing Best Practices

1. **Structure and Organization**:
   - Use descriptive test names that explain behavior
   - Follow AAA pattern (Arrange, Act, Assert)
   - Group related tests in `describe` blocks
   - Keep tests independent and idempotent
   - Co-locate tests with the code they test

2. **Mocking Strategy**:
   - Use `vi.mock()` for module-level mocks
   - Use `vi.spyOn()` for specific function mocks
   - Reset mocks between tests with `beforeEach(vi.clearAllMocks)`
   - Use the testing package for consistent mock data

3. **Assertions**:
   - Write focused assertions for specific behaviors
   - Test edge cases and error conditions
   - Use type-safe assertions with TypeScript
   - Avoid testing implementation details when possible

4. **Test Performance**:
   - Keep tests fast and efficient
   - Minimize unnecessary setup/teardown
   - Use mocks instead of real APIs for faster tests
   - Isolate slow tests when necessary

5. **Coverage Goals**:
   - Aim for >80% coverage of core business logic
   - Prioritize critical path coverage
   - Track coverage over time in CI

## Running Tests

To run tests:

- All tests: `pnpm test` (runs tests in all packages)
- Single package: `pnpm --filter @obsidian-magic/core test`
- Watch mode: `pnpm --filter @obsidian-magic/core test -- --watch`
- Coverage: `pnpm --filter @obsidian-magic/core test -- --coverage` 