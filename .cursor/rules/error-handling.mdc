---
description: Error handling patterns and best practices for Obsidian Magic
globs: **/*.ts,**/*.tsx
alwaysApply: false
---

# Error Handling System

## Core Principles

When implementing error handling in this project, follow these core principles:

1. **Type-safe error hierarchy** - Use specialized error classes for different failure scenarios
2. **Result pattern** - Wrap operations that can fail in Result<T, E> objects
3. **Retry mechanisms** - Apply retries with exponential backoff for transient failures
4. **Utility functions** - Use provided helpers for error transformation and recovery

All error handling is centralized in `packages/core/src/errors.ts`. **Never create custom error handling logic outside this system**.

## Error Class Hierarchy

- `AppError` - Base class with code, cause, context, and recoverable properties
- `ValidationError` - For input validation failures
- `FileSystemError` - For file system operation failures
- `NetworkError` - For network communication issues
- `APIError` - For API-specific failures with status codes and rate limits
- `ApiKeyError` - For authentication issues
- `ConfigurationError` - For system configuration problems
- `MarkdownError` - For markdown processing failures
- `TaggingError` - For tagging operation failures
- `CostLimitError` - For budget/token limit exceedances

## Result Pattern Usage

Always return `Result<T, E>` from functions that can fail rather than throwing exceptions. This enables:

- Type-safe error handling
- Method chaining with `andThen()` and `map()`
- Clear distinction between success and failure paths

Key methods:
- `Result.ok<T>(value)` - Create a successful result
- `Result.fail<T, E>(error)` - Create a failed result
- `result.isOk()` / `result.isFail()` - Check result status
- `result.getValue()` / `result.getError()` - Access result contents
- `result.andThen(fn)` - Chain operations returning Results

## Coding Patterns

1. **Use specialized error types with context:**
   ```typescript
   throw new FileSystemError('File not found', { path, code: ErrorCodes.FILE_NOT_FOUND });
   ```

2. **Return Results from operations that can fail:**
   ```typescript
   function processMightFail(): Result<Value> {
     try {
       return Result.ok(value);
     } catch (err) {
       return Result.fail(toAppError(err));
     }
   }
   ```

3. **Chain operations with Results:**
   ```typescript
   return fetchData()
     .andThen(data => processData(data))
     .andThen(processed => saveResult(processed));
   ```

4. **Use retry for transient failures:**
   ```typescript
   const data = await withRetry(() => fetchDataFromApi());
   ```

5. **Always clean up resources:**
   ```typescript
   try {
     resource = await acquireResource();
     return Result.ok(await processResource(resource));
   } finally {
     if (resource) await releaseResource(resource).catch(console.error);
   }
   ```

6. **Validate inputs early:**
   ```typescript
   if (!isValidInput(input)) {
     return Result.fail(new ValidationError('Invalid input'));
   }
   ```

7. **Log errors with context:**
   ```typescript
   logger.error({
     message: 'Operation failed',
     error: error instanceof AppError ? error.format() : String(error),
     context: { operationId, user, timestamp }
   });
   ```

## Implementation Reference

For implementation details, refer to:
- [Core Error Handling System](documentation/core/error-handling.md)
- [Error Class Implementation](packages/core/src/errors.ts) 