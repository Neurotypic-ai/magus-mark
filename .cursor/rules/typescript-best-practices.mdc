---
description: TypeScript best practices and coding standards
globs: **/*.ts,**/*.tsx
alwaysApply: true
---

# TypeScript Best Practices

## Type System Configuration

- Leverage TypeScript 5.8.3 features fully (discriminated unions, template literal types, etc.)
- Use explicit typing for function parameters and returns
- Apply discriminated unions for type-safe pattern matching
- Leverage TypeScript's utility types (Pick, Omit, Partial, Required, etc.)
- Never use `any` - prefer `unknown` with proper type narrowing
- Use const assertions for literal types (`as const`)
- Apply template literal types for string manipulation

## Project References & Workspace Structure

- Use TypeScript project references for efficient builds and proper type checking
- Maintain a hierarchical tsconfig structure:
  - `tsconfig.base.json` for common settings
  - Per-package/app configs that extend the base
  - Solution-level `tsconfig.json` with references
- Set `composite: true` in referenced project tsconfig files
- Use `declarationMap: true` for better source mapping
- Structure imports consistently with clear layering
- Organize by domain concepts with meaningful directory structures

## Module & Import Best Practices

- Use type-only imports to avoid runtime overhead (`import type`)
- Favor named exports over default exports for better intellisense
- **NO index.ts Files**: Avoid using index.ts files except at the root of an entire package. Instead, use descriptive filenames that clearly indicate their purpose (e.g., use `commands.ts` instead of `commands/index.ts`).
- Use path mapping for internal module references
- Enforce import sorting and grouping:
  1. External packages
  2. Internal shared modules
  3. Relative imports
  4. Type imports
- Leverage `exports` field in package.json for subpath exports

## Type Declarations

- Define interfaces for public APIs and contracts
- Use type aliases for complex types, unions, and compound structures
- Maintain separate declaration files for large type definitions
- Apply namespace augmentation correctly for extending third-party types
- Create self-documenting types with descriptive names
- Use mapped types for object transformations
- Never use `Object`, `Function`, or `{}` - be specific
- Leverage branded types for nominal typing when needed

## Functional Programming Patterns

- Prefer immutable data structures and pure functions
- Use array methods (map, filter, reduce) instead of imperative loops
- Apply function composition for complex operations
- Implement proper error handling with typed errors
- Use optional chaining (?.) and nullish coalescing (??) for safer code
- Leverage async/await with proper type-safe error handling

## ESLint Integration

- Enforce consistent type imports
- Disallow explicit any
- Use ESLint with TypeScript Parser for consistent code style
- Run type-checking as part of the linting process
- Configure per-directory rule overrides when necessary
- **Enforce file naming conventions**: 
  - Prohibit naming files as index.ts except at package roots
  - Enforce consistent file naming patterns
  - Use custom ESLint rules like `no-barrel-files` to prevent creation of nested index.ts files

## Workspace Dependencies

- Reference shared packages with workspace protocol (`workspace:*`)
- Maintain consistent versioning across workspace
- Keep dependencies scoped to appropriate app/package
- Share common dev dependencies in root package.json
- Use strict versioning for external dependencies
- Audit dependencies regularly

## Performance Optimizations

- Leverage incremental builds with `composite: true`
- Use skipLibCheck for faster type-checking
- Apply isolatedModules for module boundary optimization
- Consider lazy loading for heavy dependencies
- Use memoization for expensive calculations
- Profile and optimize critical type operations
- Be cautious with closures that capture large objects

## Testing Approach

- Write unit tests with strong typing
- Use TypeScript for test files
- Mock external dependencies appropriately
- Test with strict type checking
- Apply generics for type-safe test fixtures and factories
- Co-locate tests with the implementation files

## Code Style & Documentation

- Apply consistent naming conventions:
  - PascalCase for types, interfaces, and classes
  - camelCase for variables, functions, and methods
  - UPPER_CASE for constants
- Use JSDoc comments with TypeScript-aware annotations
- Maintain meaningful comments for complex type manipulations
- Document function parameters and return types
- Apply consistent formatting (via Prettier)
- Use semantic versioning for packages

## Advanced Type Patterns

- Implement higher-order types for complex transformations
- Use conditional types for branching type logic
- Apply template literal types for string manipulation
- Leverage indexed access types for property type extraction
- Use infer for type inference in conditional types
- Apply intersection types for type composition
- Use mapped types to transform object structures

## Module Resolution

- **NO TypeScript Paths**: We explicitly avoid using TypeScript's path mapping feature (`paths` in tsconfig) as it can lead to confusion and make the codebase harder to navigate. Instead, we use relative imports and workspace package references.

## Type Safety

- Use strict TypeScript configuration
- Enable all strict type checking options
- No use of `any` type
- No non-null assertions
- Explicit return types on functions
- Prefer type imports over value imports
- Use branded types for type safety when needed

## Code Organization

- Keep types close to their usage
- **NO index.ts Files**: Never use index.ts for subdirectories or components. Use descriptive filenames instead (e.g., `model.ts` rather than `model/index.ts`).
- Use barrel files only at the root of packages for export organization, but never in subdirectories
- Prefer interfaces for public APIs and type aliases for internal types
- Use discriminated unions for complex state management

## File Organization & Naming

- **Flat Over Nested**: Prefer flat file structures with descriptive filenames over nested directories with index.ts files
- **Descriptive Filenames**: Use clear, descriptive filenames that indicate the module's purpose
- **One Component Per File**: Each file should contain exactly one primary export (exception for tightly coupled helpers)
- **Group By Feature**: Organize files by feature or domain, not by technical role
- **NO index.ts In Subdirectories**: Never use index.ts in subdirectories - this creates maintenance challenges:
  - Makes it harder to trace imports in code editors
  - Causes confusion when viewing directories in source control
  - Creates unnecessary nesting and obfuscates the file structure
  - Results in longer import paths and harder-to-read import statements
- **Explicit Exports**: Always use explicit, named exports from specific files rather than re-exporting through index files
- **Module Boundary**: Use package.json `exports` field to define public API boundaries instead of index.ts

## Error Handling

- Use custom error classes
- Handle all possible error cases
- Avoid throwing non-Error objects
- Use Result types for operations that can fail

## Testing

- Write tests in TypeScript
- Use type-safe test utilities
- Test type definitions where appropriate
- Use test fixtures with proper types

## Documentation

- Document public APIs with TSDoc comments
- Include examples in documentation
- Document complex type parameters
- Keep documentation up to date with code changes

## Performance

- Use const assertions where appropriate
- Avoid type assertions unless absolutely necessary
- Be mindful of type inference performance
- Use `satisfies` operator for better type checking

## Naming Conventions

- Use PascalCase for types, interfaces, and classes
- Use camelCase for variables, functions, and methods
- Use UPPER_CASE for constants
- Prefix interfaces with 'I' only when there's a class implementation
- Suffix type parameters with 'Type' (e.g., TDataType)

## Code Style

- Consistent use of quotes (single)
- Consistent use of semicolons
- Proper spacing and indentation
- Clear and descriptive naming

## Imports/Exports

- Use named exports over default exports
- Group imports logically
- Use type imports for type-only imports
- Avoid side effects in imports

## Error Messages

- Use template literals for dynamic error messages
- Include relevant context in error messages
- Use consistent error message formatting
- Document error conditions

## Generics

- Use meaningful generic names
- Constrain generics appropriately
- Document generic parameters
- Use generic constraints effectively

## Async Code

- Use async/await over raw promises
- Handle promise rejections
- Type async function returns properly
- Use proper error handling in async code

## Type Guards

- Use type predicates
- Create reusable type guards
- Document type guard assumptions
- Test type guards thoroughly

## Enums

- Use const enums for better performance
- Document enum values
- Use string enums for better debugging
- Consider union types instead of enums

## Null/Undefined Handling

- Use undefined for optional values
- Use null when explicitly setting to no value
- Use optional chaining
- Use nullish coalescing

## Type Inference

- Let TypeScript infer types when obvious
- Explicitly type complex objects
- Use type inference in loops
- Document when inference is important

## Related Documentation

- [Project Structure](mdc:documentation/implementation/project-structure.md)
- [Testing Strategy](mdc:.cursor/rules/testing-strategy.mdc)
- [Build System](mdc:.cursor/rules/build-system.mdc)