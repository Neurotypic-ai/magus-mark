<!-- Generated by SpecStory -->

# Update @find-multi-versions.ts with pnpm Packages (2025-05-10 21:21:04)

_**User**_

Look at @pnpm and help me update @find-multi-versions.ts so that it uses the correct packages directly from the pnpm documentation. Do not attempt to revert to the previous version. You must use official pnpm packages.

---

_**Assistant**_



---

Your Lordship, 

I'll update the script to correctly use the PNPM packages according to the documentation. The main issue is that the script is using `readWantedLockfileSync` which doesn't exist - it should be using the async `readWantedLockfile` function instead.

Let's modify the script:

---

```diff
  import { fileURLToPath } from 'url';
  
- import { readWantedLockfileSync } from '@pnpm/lockfile-file';
+ import { readWantedLockfile } from '@pnpm/lockfile-file';
  
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  
  const PROJECT_ROOT = path.join(__dirname, '../..');
- const LOCKFILE_PATH = path.join(PROJECT_ROOT, 'pnpm-lock.yaml');
  const PNPM_DIR = path.join(PROJECT_ROOT, 'node_modules/.pnpm');
  const MAX_LINES = 10;
```

```diff
   * Find all versions of each package in the lockfile
   */
- function findMultiVersionPackages(): Record<string, Set<string>> {
+ async function findMultiVersionPackages(): Promise<Record<string, Set<string>>> {
    try {
-     const lockfile = readWantedLockfileSync(PROJECT_ROOT);
+     const lockfile = await readWantedLockfile(PROJECT_ROOT);
      if (!lockfile?.packages) {
        console.error('Failed to read lockfile or packages section missing');
```

```diff
        let version: string;
  
-       if (parts[0].startsWith('@')) {
+       if (parts[0]?.startsWith('@')) {
          // Scoped package
          if (parts.length < 3) return;
-         name = `${parts[0]}/${parts[1]}`;
-         version = parts[2].split('_')[0]; // Remove peer dependency suffix
+         name = `${parts[0]}/${parts[1] ?? ''}`;
+         version = parts[2]?.split('_')[0] ?? ''; // Remove peer dependency suffix
        } else {
          // Non-scoped package
          if (parts.length < 2) return;
-         name = parts[0];
-         version = parts[1].split('_')[0]; // Remove peer dependency suffix
+         name = parts[0] ?? '';
+         version = parts[1]?.split('_')[0] ?? ''; // Remove peer dependency suffix
        }
  
```

```diff
  
        // Store versions by package name
-       if (!versions[name]) {
-         versions[name] = new Set();
-       }
+       versions[name] ??= new Set();
        versions[name].add(version);
      });
  
      // Only return packages with multiple versions
-     return Object.fromEntries(Object.entries(versions).filter(([_, vers]) => vers.size > 1));
+     return Object.fromEntries(Object.entries(versions).filter(([, vers]) => vers.size > 1));
    } catch (err) {
      console.error('Error parsing lockfile:', err);
      process.exit(1);
    }
+ 
+   return {}; // This line is just to satisfy TypeScript, it's never reached
  }
  
```

```diff
  }
  
- function buildDependencyGraph() {
-   const lockfile = readWantedLockfileSync(PROJECT_ROOT);
+ async function buildDependencyGraph(): Promise<Record<string, DepNode>> {
+   const lockfile = await readWantedLockfile(PROJECT_ROOT);
    if (!lockfile?.packages) {
      console.error('Failed to read lockfile or packages section missing');
```

```diff
      let version: string;
  
-     if (parts[0].startsWith('@')) {
+     if (parts[0]?.startsWith('@')) {
        // Scoped package
        if (parts.length < 3) return;
-       name = `${parts[0]}/${parts[1]}`;
-       version = parts[2].split('_')[0]; // Remove peer dependency suffix
+       name = `${parts[0]}/${parts[1] ?? ''}`;
+       version = parts[2]?.split('_')[0] ?? ''; // Remove peer dependency suffix
      } else {
        // Non-scoped package
        if (parts.length < 2) return;
-       name = parts[0];
-       version = parts[1].split('_')[0]; // Remove peer dependency suffix
+       name = parts[0] ?? '';
+       version = parts[1]?.split('_')[0] ?? ''; // Remove peer dependency suffix
      }
  
```

```diff
  
      // Add node to graph if not already present
-     if (!graph[nodeKey]) {
-       graph[nodeKey] = {
-         name,
-         version,
-         dependents: new Set<string>(),
-         dependencies: new Set<string>(),
-       };
-     }
+     graph[nodeKey] ??= {
+       name,
+       version,
+       dependents: new Set<string>(),
+       dependencies: new Set<string>(),
+     };
  
      // Add dependencies to the node
      const pkg = lockfile.packages[pkgPath];
      if (pkg?.dependencies) {
        Object.entries(pkg.dependencies).forEach(([depName, depVersion]) => {
-         const depKey = `${depName}@${depVersion}`;
-         graph[nodeKey].dependencies.add(depKey);
+         if (typeof depVersion === 'string') {
+           const depKey = `${depName}@${depVersion}`;
+           graph[nodeKey]?.dependencies.add(depKey);
+         }
        });
      }
```

```diff
    // Add importers (project roots) to the graph
    if (lockfile.importers) {
+     type Importer = {
+       dependencies?: Record<string, string>;
+       devDependencies?: Record<string, string>;
+       optionalDependencies?: Record<string, string>;
+     };
+ 
      Object.entries(lockfile.importers).forEach(([importerPath, importer]) => {
        const rootName = importerPath === '.' ? 'root' : importerPath;
        const rootKey = rootName;
+       const typedImporter = importer as Importer;
  
-       if (!graph[rootKey]) {
-         graph[rootKey] = {
-           name: rootName,
-           version: '',
-           dependents: new Set<string>(),
-           dependencies: new Set<string>(),
-         };
-       }
+       graph[rootKey] ??= {
+         name: rootName,
+         version: '',
+         dependents: new Set<string>(),
+         dependencies: new Set<string>(),
+       };
  
        // Add all dependencies of the importer
        const allDeps = {
-         ...importer.dependencies,
-         ...importer.devDependencies,
-         ...importer.optionalDependencies,
+         ...typedImporter.dependencies,
+         ...typedImporter.devDependencies,
+         ...typedImporter.optionalDependencies,
        };
  
-       Object.entries(allDeps || {}).forEach(([depName, depVersion]) => {
+       Object.entries(allDeps ?? {}).forEach(([depName, depVersion]) => {
          // Skip workspace dependencies
          if (typeof depVersion === 'string' && !depVersion.startsWith('link:')) {
            const depKey = `${depName}@${depVersion}`;
-           graph[rootKey].dependencies.add(depKey);
+           graph[rootKey]?.dependencies.add(depKey);
            if (graph[depKey]) {
              graph[depKey].dependents.add(rootKey);
```

```diff
    const targetNodes = pkgVersions.map((v) => `${pkgName}@${v}`).filter((key) => graph[key]);
    const allPaths: string[][] = [];
-   const visited = new Set<string>();
  
    // Find all root nodes
    const rootNodes = Object.entries(graph)
      .filter(
-       ([_, node]) =>
+       ([, node]) =>
          node.dependents.size === 0 ||
          node.name === 'root' ||
```

```diff
  
      while (queue.length > 0) {
-       const { node, path } = queue.shift()!;
+       const current = queue.shift();
+       if (!current) continue;
+       
+       const { node, path } = current;
  
        if (node === targetNode) {
```

```diff
  
        // Add all dependencies to the queue
-       const deps = graph[node]?.dependencies || new Set<string>();
+       const deps = graph[node]?.dependencies ?? new Set<string>();
        deps.forEach((dep) => {
          if (!path.includes(dep)) {
```

```diff
    // If there's only one path, all nodes except the last one are potential GCAs
    if (paths.length === 1) {
-     return paths[0].slice(0, -1);
+     const path = paths[0];
+     return path ? path.slice(0, -1) : [];
    }
  
    // Find common prefixes
    const comps: string[][] = [];
    for (let i = 0; i < paths.length; i++) {
+     const pathI = paths[i];
+     if (!pathI) continue;
+     
      for (let j = i + 1; j < paths.length; j++) {
+       const pathJ = paths[j];
+       if (!pathJ) continue;
+       
        const commonPrefix: string[] = [];
-       const minLen = Math.min(paths[i].length, paths[j].length);
+       const minLen = Math.min(pathI.length, pathJ.length);
  
        for (let k = 0; k < minLen; k++) {
-         if (paths[i][k] === paths[j][k]) {
-           commonPrefix.push(paths[i][k]);
+         const nodeI = pathI[k];
+         const nodeJ = pathJ[k];
+         if (nodeI && nodeJ && nodeI === nodeJ) {
+           commonPrefix.push(nodeI);
          } else {
            break;
```

```diff
  
    // Find the longest common prefix
-   let longestPrefix = comps[0];
-   for (let i = 1; i < comps.length; i++) {
-     if (comps[i].length > longestPrefix.length) {
-       longestPrefix = comps[i];
+   let longestPrefix: string[] = [];
+   for (const comp of comps) {
+     if (comp.length > longestPrefix.length) {
+       longestPrefix = comp;
      }
    }
  
    // Return the last node of the longest common prefix as the GCA
-   return longestPrefix.length > 0 ? [longestPrefix[longestPrefix.length - 1]] : [];
+   return longestPrefix.length > 0 && longestPrefix[longestPrefix.length - 1] 
+     ? [longestPrefix[longestPrefix.length - 1]] 
+     : [];
  }
  
```

```diff
  function getHighestVersion(versions: string[]): string {
    if (versions.length === 0) return '';
-   return Array.from(versions).sort((a, b) => {
+   
+   const validVersions = versions.filter(Boolean);
+   return validVersions.sort((a, b) => {
      const aParts = a.split('.').map(Number);
      const bParts = b.split('.').map(Number);
```

```diff
  
      return 0;
-   })[0];
+   })[0] || '';
  }
  
```

```diff
      const out = execSync(`pnpm why -r ${pkg}`, { encoding: 'utf8', stdio: 'pipe' });
      return out.trim();
-   } catch (e) {
+   } catch {
      return '[pnpm why failed]';
    }
```

```diff
    const filled = Math.round((current / total) * width);
    const bar = '='.repeat(filled) + '-'.repeat(width - filled);
-   process.stdout.write(`\r[${bar}] ${percent}% (${current}/${total})`);
+   process.stdout.write(`\r[${bar}] ${String(percent)}% (${String(current)}/${String(total)})`);
    if (current === total) process.stdout.write('\n');
  }
```

```diff
        '| Package | Version Count | Versions | Output File |\n|---------|--------------|----------|-------------|';
      const rows = summary
-       .map((s) => `| ${s.package} | ${s.versionCount} | ${s.versions.join(', ')} | ${s.outputFile} |`)
+       .map((s) => `| ${s.package} | ${String(s.versionCount)} | ${s.versions.join(', ')} | ${s.outputFile} |`)
        .join('\n');
      fs.writeFileSync(summaryPath, `${header}\n${rows}\n`, 'utf8');
```

```diff
      const header = 'package,versionCount,versions,outputFile';
      const rows = summary
-       .map((s) => `${s.package},${s.versionCount},"${s.versions.join(', ')}",${s.outputFile}`)
+       .map((s) => `${s.package},${String(s.versionCount)},"${s.versions.join(', ')}",${s.outputFile}`)
        .join('\n');
      fs.writeFileSync(summaryPath, `${header}\n${rows}\n`, 'utf8');
```

```diff
   * Generate override recommendations for multi-version packages
   */
- function generateOverrideReport(multiVersionPkgs: Record<string, Set<string>>, outputDir: string) {
-   const graph = buildDependencyGraph();
-   const report: Record<string, any> = {};
+ async function generateOverrideReport(multiVersionPkgs: Record<string, Set<string>>, outputDir: string) {
+   const graph = await buildDependencyGraph();
+   const report: Record<string, unknown> = {};
  
    for (const [pkgName, versions] of Object.entries(multiVersionPkgs)) {
```

```diff
  }
  
- function main() {
+ async function main() {
    // Find packages with multiple versions
-   const multiVersionPkgs = findMultiVersionPackages();
+   const multiVersionPkgs = await findMultiVersionPackages();
    const packages = Object.entries(multiVersionPkgs);
  
```

```diff
      });
  
-     let pkgLine = `${pkg} - ${versionCount} version${versionCount > 1 ? 's' : ''}: ${versionsArr.join(', ')}`;
+     let pkgLine = `${pkg} - ${String(versionCount)} version${versionCount > 1 ? 's' : ''}: ${versionsArr.join(', ')}`;
  
      if (!quiet) {
```

```diff
    if (outputDir) {
      writeSummary(summary, outputDir, summaryFormat);
-     generateOverrideReport(multiVersionPkgs, outputDir);
+     await generateOverrideReport(multiVersionPkgs, outputDir);
      console.log(`Output written to folder: ${outputDir}`);
    }
  }
  
- main();
+ main().catch((err) => {
+   console.error('Error:', err);
+   process.exit(1);
+ });
  
```

---

I've updated the script to properly use PNPM packages. The key changes made are:

1. Replaced `readWantedLockfileSync` with `readWantedLockfile` (the async version)
2. Updated all relevant functions to be async/await compatible
3. Added proper error handling for the async main function
4. Fixed type issues with nullable values using modern TypeScript syntax
5. Removed unused variables
6. Fixed template literal type errors by converting numbers to strings where needed
7. Added null checks for array elements and objects
8. Added proper type definitions for PNPM's importer objects
9. Used nullish coalescing operators (`??` and `??=`) instead of logical OR
10. Added proper Promise handling with catch blocks

The script now correctly handles the async nature of PNPM's lockfile reading API while maintaining the same functionality and improving type safety.

Your Humble Servant, Sebastien

---

_**User**_

For the code present, we get this error:
```
Object is possibly 'undefined'.
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---

Your Lordship, 

The error occurs because TypeScript cannot guarantee that `versions[name]` exists even after the nullish coalescing assignment. Add a type assertion to fix this:

---

```diff
        // Store versions by package name
        versions[name] ??= new Set();
-       versions[name].add(version);
+       (versions[name] as Set<string>).add(version);
      });
  
```

---



---

