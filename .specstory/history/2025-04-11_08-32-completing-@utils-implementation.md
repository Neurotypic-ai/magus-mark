<!-- Generated by SpecStory -->

# Completing @utils Implementation (2025-04-11 04:32:38)

_**User**_

Finish implementing @utils 

---

_**Assistant**_



---

I'll help you implement the utils package for the Obsidian Magic project. Let's start by examining what's currently in the package.json file.

---

Read file: packages/utils/package.json

---

Now let's check the tsconfig.json:

---

Read file: packages/utils/tsconfig.json

---

Let's look at the current structure of the source directory to see what utilities we have:

---

<details>
            <summary>Listed directory packages/utils/src ‚Ä¢ **1** results</summary>
        
| Name |
|-------|
| üìÑ `index.ts` |

</details>

---

Let's see if there's any content in the index.ts file:

---

Read file: packages/utils/src/index.ts

---

Let's also check if there are any tests already set up:

---

<details>
            <summary>Listed directory packages/utils/tests ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

Let's also look at the types package to understand what we need to support:

---

<details>
            <summary>Listed directory packages/types/src ‚Ä¢ **3** results</summary>
        
| Name |
|-------|
| üìÅ `models` |
| üìÅ `validators` |
| üìÑ `index.ts` |

</details>

---

Let's check the types package index file to understand the data models we'll be working with:

---

Read file: packages/types/src/index.ts

---

Now let's check the models and validators in the types package to better understand the data structure:

---

<details>
            <summary>Listed directory packages/types/src/models ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

<details>
            <summary>Listed directory packages/types/src/validators ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

Based on the information gathered, I'll now implement the utils package. Let's create the necessary utility functions for the project.

First, let's create a directory structure for the utils package:

---

```bash
mkdir -p packages/utils/src/{file,string,validation,tag,config,prompt,performance} packages/utils/tests
```

```
khallmark in obsidian-magic ‚Ä¶

```

---

Now let's create the file utility functions:

---

```diff
- 
+ /**
+  * File utility functions for Obsidian Magic
+  */
+ import fs from 'fs-extra';
+ import path from 'path';
+ import { z } from 'zod';
+ 
+ /**
+  * Ensures a directory exists, creating it if necessary
+  * @param dirPath - Path to the directory
+  */
+ export async function ensureDirectory(dirPath: string): Promise<void> {
+   await fs.ensureDir(dirPath);
+ }
+ 
+ /**
+  * Reads a file from the filesystem
+  * @param filePath - Path to the file
+  * @returns File contents as string
+  */
+ export async function readFile(filePath: string): Promise<string> {
+   try {
+     return await fs.readFile(filePath, 'utf-8');
+   } catch (error) {
+     throw new Error(`Failed to read file at ${filePath}: ${(error as Error).message}`);
+   }
+ }
+ 
+ /**
+  * Reads a JSON file and validates it against a schema
+  * @param filePath - Path to the JSON file
+  * @param schema - Zod schema for validation
+  * @returns Parsed and validated JSON
+  */
+ export async function readJsonFile<T>(filePath: string, schema: z.ZodType<T>): Promise<T> {
+   try {
+     const fileContent = await readFile(filePath);
+     const parsedData = JSON.parse(fileContent);
+     return schema.parse(parsedData);
+   } catch (error) {
+     if (error instanceof z.ZodError) {
+       throw new Error(`Invalid JSON schema in ${filePath}: ${error.message}`);
+     }
+     if (error instanceof SyntaxError) {
+       throw new Error(`Invalid JSON in ${filePath}: ${error.message}`);
+     }
+     throw error;
+   }
+ }
+ 
+ /**
+  * Writes a string to a file
+  * @param filePath - Path to the file
+  * @param content - Content to write
+  */
+ export async function writeFile(filePath: string, content: string): Promise<void> {
+   try {
+     await ensureDirectory(path.dirname(filePath));
+     await fs.writeFile(filePath, content, 'utf-8');
+   } catch (error) {
+     throw new Error(`Failed to write file at ${filePath}: ${(error as Error).message}`);
+   }
+ }
+ 
+ /**
+  * Writes a JSON object to a file
+  * @param filePath - Path to the file
+  * @param data - Data to write
+  * @param pretty - Whether to format the JSON (default: true)
+  */
+ export async function writeJsonFile<T>(filePath: string, data: T, pretty = true): Promise<void> {
+   const content = pretty 
+     ? JSON.stringify(data, null, 2) 
+     : JSON.stringify(data);
+   
+   await writeFile(filePath, content);
+ }
+ 
+ /**
+  * Checks if a file exists
+  * @param filePath - Path to the file
+  * @returns True if the file exists
+  */
+ export async function fileExists(filePath: string): Promise<boolean> {
+   try {
+     await fs.access(filePath);
+     return true;
+   } catch {
+     return false;
+   }
+ }
+ 
+ /**
+  * Recursively finds all files matching a pattern
+  * @param dirPath - Directory to search in
+  * @param pattern - Regex pattern to match against
+  * @returns Array of matching file paths
+  */
+ export async function findFiles(dirPath: string, pattern: RegExp): Promise<string[]> {
+   const results: string[] = [];
+   
+   async function scan(currentPath: string): Promise<void> {
+     const entries = await fs.readdir(currentPath, { withFileTypes: true });
+     
+     for (const entry of entries) {
+       const fullPath = path.join(currentPath, entry.name);
+       
+       if (entry.isDirectory()) {
+         await scan(fullPath);
+       } else if (entry.isFile() && pattern.test(entry.name)) {
+         results.push(fullPath);
+       }
+     }
+   }
+   
+   await scan(dirPath);
+   return results;
+ }
+ 
+ /**
+  * Gets file stats with error handling
+  * @param filePath - Path to the file
+  * @returns File stats or null if file doesn't exist
+  */
+ export async function getFileStats(filePath: string): Promise<fs.Stats | null> {
+   try {
+     return await fs.stat(filePath);
+   } catch {
+     return null;
+   }
+ }
+ 
+ /**
+  * Safely deletes a file if it exists
+  * @param filePath - Path to the file
+  * @returns True if file was deleted, false if it didn't exist
+  */
+ export async function safeDeleteFile(filePath: string): Promise<boolean> {
+   try {
+     await fs.unlink(filePath);
+     return true;
+   } catch (error) {
+     if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
+       return false;
+     }
+     throw error;
+   }
+ } 
```

---

Now let's create string utility functions:

---

```diff
- 
+ /**
+  * String utility functions for Obsidian Magic
+  */
+ 
+ /**
+  * Truncates a string to a maximum length, adding an ellipsis if truncated
+  * @param text - String to truncate
+  * @param maxLength - Maximum length
+  * @returns Truncated string
+  */
+ export function truncate(text: string, maxLength: number): string {
+   if (text.length <= maxLength) return text;
+   return text.slice(0, maxLength - 3) + '...';
+ }
+ 
+ /**
+  * Converts a string to kebab-case
+  * @param text - String to convert
+  * @returns Kebab-case string
+  */
+ export function toKebabCase(text: string): string {
+   return text
+     .replace(/([a-z])([A-Z])/g, '$1-$2') // Convert camelCase to kebab-case
+     .replace(/\s+/g, '-') // Replace spaces with hyphens
+     .replace(/[^a-zA-Z0-9-]/g, '') // Remove non-alphanumeric characters except hyphens
+     .toLowerCase();
+ }
+ 
+ /**
+  * Converts a string to camelCase
+  * @param text - String to convert
+  * @returns camelCase string
+  */
+ export function toCamelCase(text: string): string {
+   return text
+     .replace(/[^a-zA-Z0-9]+(.)/g, (_, char) => char.toUpperCase())
+     .replace(/^[A-Z]/, firstChar => firstChar.toLowerCase());
+ }
+ 
+ /**
+  * Converts a string to PascalCase
+  * @param text - String to convert
+  * @returns PascalCase string
+  */
+ export function toPascalCase(text: string): string {
+   const camelCase = toCamelCase(text);
+   return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
+ }
+ 
+ /**
+  * Extracts YAML frontmatter from a markdown document
+  * @param content - Markdown content
+  * @returns Frontmatter string or null if not found
+  */
+ export function extractFrontmatter(content: string): string | null {
+   const match = content.match(/^---\n([\s\S]*?)\n---/);
+   return match ? match[1] : null;
+ }
+ 
+ /**
+  * Removes YAML frontmatter from a markdown document
+  * @param content - Markdown content
+  * @returns Content without frontmatter
+  */
+ export function removeFrontmatter(content: string): string {
+   return content.replace(/^---\n[\s\S]*?\n---\n?/, '');
+ }
+ 
+ /**
+  * Slugifies a string for URLs or filenames
+  * @param text - String to slugify
+  * @returns Slugified string
+  */
+ export function slugify(text: string): string {
+   return text
+     .toLowerCase()
+     .replace(/\s+/g, '-')
+     .replace(/[^\w-]+/g, '')
+     .replace(/--+/g, '-')
+     .replace(/^-+|-+$/g, '');
+ }
+ 
+ /**
+  * Normalizes different types of line endings to \n
+  * @param text - String to normalize
+  * @returns Normalized string
+  */
+ export function normalizeLineEndings(text: string): string {
+   return text.replace(/\r\n|\r/g, '\n');
+ }
+ 
+ /**
+  * Escapes regular expression special characters
+  * @param text - String to escape
+  * @returns Escaped string
+  */
+ export function escapeRegExp(text: string): string {
+   return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+ }
+ 
+ /**
+  * Sanitizes a string to be safe for use in HTML
+  * @param html - String to sanitize
+  * @returns Sanitized string
+  */
+ export function sanitizeHtml(html: string): string {
+   return html
+     .replace(/&/g, '&amp;')
+     .replace(/</g, '&lt;')
+     .replace(/>/g, '&gt;')
+     .replace(/"/g, '&quot;')
+     .replace(/'/g, '&#039;');
+ }
+ 
+ /**
+  * Generates a random string with specified length
+  * @param length - Length of the random string
+  * @returns Random string
+  */
+ export function randomString(length: number): string {
+   const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
+   let result = '';
+   
+   for (let i = 0; i < length; i++) {
+     const randomIndex = Math.floor(Math.random() * characters.length);
+     result += characters.charAt(randomIndex);
+   }
+   
+   return result;
+ } 
```

---

Let's fix the linter error in the string utils file:

---



---

Now let's create validation utility functions:

---

```diff
- 
+ /**
+  * Validation utility functions for Obsidian Magic
+  */
+ import { z } from 'zod';
+ import type { 
+   DomainTag, 
+   SubdomainMap, 
+   LifeAreaTag, 
+   ConversationTypeTag,
+   TagSet,
+   TopicalTag,
+   TagConfidence
+ } from '@obsidian-magic/types';
+ 
+ /**
+  * Validates and ensures a value is between min and max (inclusive)
+  * @param value - Value to clamp
+  * @param min - Minimum value
+  * @param max - Maximum value
+  * @returns Clamped value
+  */
+ export function clamp(value: number, min: number, max: number): number {
+   return Math.min(Math.max(value, min), max);
+ }
+ 
+ /**
+  * Zod schema for validating confidence scores (0.0 to 1.0)
+  */
+ export const confidenceScoreSchema = z.number()
+   .min(0)
+   .max(1)
+   .refine(n => !isNaN(n), {
+     message: "Confidence score must be a valid number"
+   });
+ 
+ /**
+  * Zod schema for validating year tags (4-digit years)
+  */
+ export const yearTagSchema = z.string()
+   .regex(/^\d{4}$/, {
+     message: "Year must be a 4-digit number"
+   });
+ 
+ /**
+  * Zod schema for validating domain tags
+  */
+ export const domainTagSchema = z.enum([
+   'software-development',
+   'philosophy',
+   'design',
+   'psychology',
+   'business',
+   'science',
+   'arts',
+   'entertainment',
+   'technology',
+   'health',
+   'education',
+   'finance'
+ ] as const) as z.ZodType<DomainTag>;
+ 
+ /**
+  * Zod schema for validating life area tags
+  */
+ export const lifeAreaTagSchema = z.enum([
+   'career',
+   'relationships',
+   'health',
+   'learning',
+   'projects',
+   'personal-growth',
+   'finance',
+   'hobby'
+ ] as const) as z.ZodType<LifeAreaTag>;
+ 
+ /**
+  * Zod schema for validating conversation type tags
+  */
+ export const conversationTypeTagSchema = z.enum([
+   'theory',
+   'practical',
+   'meta',
+   'casual',
+   'adhd-thought',
+   'deep-dive',
+   'exploration',
+   'experimental',
+   'reflection',
+   'planning',
+   'question',
+   'analysis'
+ ] as const) as z.ZodType<ConversationTypeTag>;
+ 
+ /**
+  * Creates a subdomain schema based on the domain
+  * @param domain - Domain to create subdomain schema for
+  * @returns Zod schema for the subdomain
+  */
+ export function createSubdomainSchema(domain: DomainTag): z.ZodEnum<[string, ...string[]]> {
+   const subdomains: Record<DomainTag, string[]> = {
+     'software-development': ['frontend', 'backend', 'devops', 'mobile', 'data', 'security', 'architecture'],
+     'philosophy': ['ethics', 'metaphysics', 'epistemology', 'logic', 'aesthetics'],
+     'design': ['ux', 'ui', 'graphic', 'industrial', 'interaction'],
+     'psychology': ['cognitive', 'clinical', 'developmental', 'social', 'behavioral'],
+     'business': ['marketing', 'strategy', 'management', 'entrepreneurship', 'operations'],
+     'science': ['physics', 'biology', 'chemistry', 'mathematics', 'computer-science'],
+     'arts': ['visual', 'music', 'literature', 'performing', 'digital'],
+     'entertainment': ['games', 'film', 'television', 'books', 'sports'],
+     'technology': ['ai', 'blockchain', 'iot', 'vr-ar', 'robotics'],
+     'health': ['fitness', 'nutrition', 'mental-health', 'medical', 'wellness'],
+     'education': ['k12', 'higher-ed', 'professional', 'self-learning', 'teaching'],
+     'finance': ['investing', 'personal-finance', 'corporate-finance', 'crypto', 'banking']
+   };
+   
+   return z.enum([subdomains[domain][0], ...subdomains[domain].slice(1)] as [string, ...string[]]);
+ }
+ 
+ /**
+  * Zod schema for validating contextual tags
+  */
+ export const contextualTagSchema = z.string();
+ 
+ /**
+  * Zod schema for validating topical tags
+  */
+ export const topicalTagSchema: z.ZodType<TopicalTag> = z.object({
+   domain: domainTagSchema,
+   subdomain: z.string().optional(),
+   contextual: contextualTagSchema.optional()
+ });
+ 
+ /**
+  * Zod schema for validating tag confidence scores
+  */
+ export const tagConfidenceSchema: z.ZodType<TagConfidence> = z.object({
+   overall: confidenceScoreSchema,
+   year: confidenceScoreSchema.optional(),
+   life_area: confidenceScoreSchema.optional(),
+   domain: confidenceScoreSchema.optional(),
+   subdomain: confidenceScoreSchema.optional(),
+   contextual: confidenceScoreSchema.optional(),
+   conversation_type: confidenceScoreSchema.optional()
+ });
+ 
+ /**
+  * Zod schema for validating complete tag sets
+  */
+ export const tagSetSchema: z.ZodType<TagSet> = z.object({
+   year: yearTagSchema,
+   life_area: lifeAreaTagSchema.optional(),
+   topical_tags: z.array(topicalTagSchema).min(1),
+   conversation_type: conversationTypeTagSchema,
+   confidence: tagConfidenceSchema,
+   explanations: z.record(z.string()).optional()
+ });
+ 
+ /**
+  * Validates a tag set against the schema
+  * @param tagSet - Tag set to validate
+  * @returns Validated tag set or throws an error
+  */
+ export function validateTagSet(tagSet: unknown): TagSet {
+   return tagSetSchema.parse(tagSet);
+ }
+ 
+ /**
+  * Type-safe validation that checks if a domain has a specific subdomain
+  * @param domain - Domain to check
+  * @param subdomain - Subdomain to check
+  * @returns True if the domain has the subdomain
+  */
+ export function isDomainWithSubdomain(
+   domain: DomainTag,
+   subdomain: string
+ ): subdomain is SubdomainMap[typeof domain] {
+   const subdomainMap: Record<DomainTag, string[]> = {
+     'software-development': ['frontend', 'backend', 'devops', 'mobile', 'data', 'security', 'architecture'],
+     'philosophy': ['ethics', 'metaphysics', 'epistemology', 'logic', 'aesthetics'],
+     'design': ['ux', 'ui', 'graphic', 'industrial', 'interaction'],
+     'psychology': ['cognitive', 'clinical', 'developmental', 'social', 'behavioral'],
+     'business': ['marketing', 'strategy', 'management', 'entrepreneurship', 'operations'],
+     'science': ['physics', 'biology', 'chemistry', 'mathematics', 'computer-science'],
+     'arts': ['visual', 'music', 'literature', 'performing', 'digital'],
+     'entertainment': ['games', 'film', 'television', 'books', 'sports'],
+     'technology': ['ai', 'blockchain', 'iot', 'vr-ar', 'robotics'],
+     'health': ['fitness', 'nutrition', 'mental-health', 'medical', 'wellness'],
+     'education': ['k12', 'higher-ed', 'professional', 'self-learning', 'teaching'],
+     'finance': ['investing', 'personal-finance', 'corporate-finance', 'crypto', 'banking']
+   };
+   
+   return subdomainMap[domain].includes(subdomain);
+ } 
```

---

Let's fix the linter errors in the validation utils:

---

```diff
    DomainTag, 
    SubdomainMap, 
+   SubdomainTag, 
    LifeAreaTag, 
    ConversationTypeTag,
    TagSet,
    TopicalTag,
-   TagConfidence
+   TagConfidence,
+   YearTag,
+   ConfidenceScore
  } from '@obsidian-magic/types';
  
    .regex(/^\d{4}$/, {
      message: "Year must be a 4-digit number"
-   });
+   })
+   .transform(val => val as YearTag);
  
  /**
    'analysis'
  ] as const) as z.ZodType<ConversationTypeTag>;
+ 
+ /**
+  * Dictionary of subdomains by domain
+  */
+ export const subdomainsByDomain: Record<DomainTag, readonly SubdomainTag[]> = {
+   'software-development': ['frontend', 'backend', 'devops', 'mobile', 'data', 'security', 'architecture'] as const,
+   'philosophy': ['ethics', 'metaphysics', 'epistemology', 'logic', 'aesthetics'] as const,
+   'design': ['ux', 'ui', 'graphic', 'industrial', 'interaction'] as const,
+   'psychology': ['cognitive', 'clinical', 'developmental', 'social', 'behavioral'] as const,
+   'business': ['marketing', 'strategy', 'management', 'entrepreneurship', 'operations'] as const,
+   'science': ['physics', 'biology', 'chemistry', 'mathematics', 'computer-science'] as const,
+   'arts': ['visual', 'music', 'literature', 'performing', 'digital'] as const,
+   'entertainment': ['games', 'film', 'television', 'books', 'sports'] as const,
+   'technology': ['ai', 'blockchain', 'iot', 'vr-ar', 'robotics'] as const,
+   'health': ['fitness', 'nutrition', 'mental-health', 'medical', 'wellness'] as const,
+   'education': ['k12', 'higher-ed', 'professional', 'self-learning', 'teaching'] as const,
+   'finance': ['investing', 'personal-finance', 'corporate-finance', 'crypto', 'banking'] as const
+ };
  
  /**
   */
  export function createSubdomainSchema(domain: DomainTag): z.ZodEnum<[string, ...string[]]> {
-   const subdomains: Record<DomainTag, string[]> = {
-     'software-development': ['frontend', 'backend', 'devops', 'mobile', 'data', 'security', 'architecture'],
-     'philosophy': ['ethics', 'metaphysics', 'epistemology', 'logic', 'aesthetics'],
-     'design': ['ux', 'ui', 'graphic', 'industrial', 'interaction'],
-     'psychology': ['cognitive', 'clinical', 'developmental', 'social', 'behavioral'],
-     'business': ['marketing', 'strategy', 'management', 'entrepreneurship', 'operations'],
-     'science': ['physics', 'biology', 'chemistry', 'mathematics', 'computer-science'],
-     'arts': ['visual', 'music', 'literature', 'performing', 'digital'],
-     'entertainment': ['games', 'film', 'television', 'books', 'sports'],
-     'technology': ['ai', 'blockchain', 'iot', 'vr-ar', 'robotics'],
-     'health': ['fitness', 'nutrition', 'mental-health', 'medical', 'wellness'],
-     'education': ['k12', 'higher-ed', 'professional', 'self-learning', 'teaching'],
-     'finance': ['investing', 'personal-finance', 'corporate-finance', 'crypto', 'banking']
-   };
-   
-   return z.enum([subdomains[domain][0], ...subdomains[domain].slice(1)] as [string, ...string[]]);
+   const subdomains = subdomainsByDomain[domain];
+   return z.enum([subdomains[0], ...subdomains.slice(1)] as [string, ...string[]]) as z.ZodType<SubdomainTag>;
  }
  
   * Zod schema for validating topical tags
   */
- export const topicalTagSchema: z.ZodType<TopicalTag> = z.object({
+ export const topicalTagSchema = z.object({
    domain: domainTagSchema,
-   subdomain: z.string().optional(),
+   subdomain: z.union([
+     z.string().refine((val): val is SubdomainTag => {
+       for (const domain of Object.keys(subdomainsByDomain) as DomainTag[]) {
+         if (subdomainsByDomain[domain].includes(val as any)) {
+           return true;
+         }
+       }
+       return false;
+     }),
+     z.undefined()
+   ]),
    contextual: contextualTagSchema.optional()
- });
+ }) satisfies z.ZodType<TopicalTag>;
  
  /**
   * Zod schema for validating tag confidence scores
   */
- export const tagConfidenceSchema: z.ZodType<TagConfidence> = z.object({
+ export const tagConfidenceSchema = z.object({
    overall: confidenceScoreSchema,
    year: confidenceScoreSchema.optional(),
    contextual: confidenceScoreSchema.optional(),
    conversation_type: confidenceScoreSchema.optional()
- });
+ }) satisfies z.ZodType<TagConfidence>;
  
  /**
   * Zod schema for validating complete tag sets
   */
- export const tagSetSchema: z.ZodType<TagSet> = z.object({
+ export const tagSetSchema = z.object({
    year: yearTagSchema,
    life_area: lifeAreaTagSchema.optional(),
    confidence: tagConfidenceSchema,
    explanations: z.record(z.string()).optional()
- });
+ }) satisfies z.ZodType<TagSet>;
  
  /**
    subdomain: string
  ): subdomain is SubdomainMap[typeof domain] {
-   const subdomainMap: Record<DomainTag, string[]> = {
-     'software-development': ['frontend', 'backend', 'devops', 'mobile', 'data', 'security', 'architecture'],
-     'philosophy': ['ethics', 'metaphysics', 'epistemology', 'logic', 'aesthetics'],
-     'design': ['ux', 'ui', 'graphic', 'industrial', 'interaction'],
-     'psychology': ['cognitive', 'clinical', 'developmental', 'social', 'behavioral'],
-     'business': ['marketing', 'strategy', 'management', 'entrepreneurship', 'operations'],
-     'science': ['physics', 'biology', 'chemistry', 'mathematics', 'computer-science'],
-     'arts': ['visual', 'music', 'literature', 'performing', 'digital'],
-     'entertainment': ['games', 'film', 'television', 'books', 'sports'],
-     'technology': ['ai', 'blockchain', 'iot', 'vr-ar', 'robotics'],
-     'health': ['fitness', 'nutrition', 'mental-health', 'medical', 'wellness'],
-     'education': ['k12', 'higher-ed', 'professional', 'self-learning', 'teaching'],
-     'finance': ['investing', 'personal-finance', 'corporate-finance', 'crypto', 'banking']
-   };
-   
-   return subdomainMap[domain].includes(subdomain);
+   return subdomainsByDomain[domain].includes(subdomain as any);
  } 
```

---

Let's create the tag utility functions:

---

```diff
- 
+ /**
+  * Tag utility functions for Obsidian Magic
+  */
+ import type { 
+   TagSet, 
+   TopicalTag, 
+   DomainTag, 
+   SubdomainTag, 
+   LifeAreaTag, 
+   ConversationTypeTag,
+   ConfidenceScore,
+   TagBehavior
+ } from '@obsidian-magic/types';
+ 
+ /**
+  * Formats a tag for display in Obsidian
+  * @param tag - Raw tag name
+  * @returns Formatted tag string
+  */
+ export function formatTag(tag: string): string {
+   return `#${tag}`;
+ }
+ 
+ /**
+  * Creates a hierarchical tag from domain and optional subdomain
+  * @param domain - Domain tag
+  * @param subdomain - Optional subdomain tag
+  * @returns Hierarchical tag string (e.g., "software-development/frontend")
+  */
+ export function createHierarchicalTag(domain: DomainTag, subdomain?: SubdomainTag): string {
+   return subdomain ? `${domain}/${subdomain}` : domain;
+ }
+ 
+ /**
+  * Extracts a domain from a hierarchical tag
+  * @param hierarchicalTag - Hierarchical tag string (e.g., "software-development/frontend")
+  * @returns Domain portion of the tag
+  */
+ export function extractDomain(hierarchicalTag: string): string {
+   return hierarchicalTag.split('/')[0];
+ }
+ 
+ /**
+  * Extracts a subdomain from a hierarchical tag
+  * @param hierarchicalTag - Hierarchical tag string (e.g., "software-development/frontend")
+  * @returns Subdomain portion of the tag or undefined if not present
+  */
+ export function extractSubdomain(hierarchicalTag: string): string | undefined {
+   const parts = hierarchicalTag.split('/');
+   return parts.length > 1 ? parts[1] : undefined;
+ }
+ 
+ /**
+  * Formats a tag set for display in Obsidian frontmatter
+  * @param tagSet - Tag set to format
+  * @returns Array of formatted tags
+  */
+ export function formatTagSetForFrontmatter(tagSet: TagSet): string[] {
+   const tags: string[] = [];
+   
+   // Add year tag
+   tags.push(tagSet.year);
+   
+   // Add life area tag if present
+   if (tagSet.life_area) {
+     tags.push(tagSet.life_area);
+   }
+   
+   // Add topical tags
+   for (const topicalTag of tagSet.topical_tags) {
+     // Add domain/subdomain hierarchical tag
+     if (topicalTag.subdomain) {
+       tags.push(createHierarchicalTag(topicalTag.domain, topicalTag.subdomain));
+     } else {
+       tags.push(topicalTag.domain);
+     }
+     
+     // Add contextual tag if present
+     if (topicalTag.contextual) {
+       tags.push(topicalTag.contextual);
+     }
+   }
+   
+   // Add conversation type tag
+   tags.push(tagSet.conversation_type);
+   
+   return tags;
+ }
+ 
+ /**
+  * Merges two tag sets based on the specified behavior
+  * @param existingTags - Existing tag set
+  * @param newTags - New tag set
+  * @param behavior - Merge behavior (append, replace, merge)
+  * @returns Merged tag set
+  */
+ export function mergeTagSets(
+   existingTags: TagSet | undefined, 
+   newTags: TagSet, 
+   behavior: TagBehavior
+ ): TagSet {
+   // If no existing tags or behavior is replace, just return new tags
+   if (!existingTags || behavior === 'replace') {
+     return newTags;
+   }
+   
+   if (behavior === 'append') {
+     // Append new tags to existing tags
+     return {
+       ...existingTags,
+       topical_tags: [
+         ...existingTags.topical_tags,
+         ...newTags.topical_tags
+       ],
+       // Keep highest confidence
+       confidence: {
+         overall: Math.max(existingTags.confidence.overall, newTags.confidence.overall),
+         year: existingTags.confidence.year ?? newTags.confidence.year,
+         life_area: existingTags.confidence.life_area ?? newTags.confidence.life_area,
+         domain: existingTags.confidence.domain ?? newTags.confidence.domain,
+         subdomain: existingTags.confidence.subdomain ?? newTags.confidence.subdomain,
+         contextual: existingTags.confidence.contextual ?? newTags.confidence.contextual,
+         conversation_type: existingTags.confidence.conversation_type ?? newTags.confidence.conversation_type,
+       },
+       // Merge explanations
+       explanations: {
+         ...existingTags.explanations,
+         ...newTags.explanations
+       }
+     };
+   }
+   
+   // Merge behavior - intelligently combine tag sets
+   return {
+     // Use new year if confidence is higher, otherwise keep existing
+     year: newTags.confidence.year && (!existingTags.confidence.year || 
+       (newTags.confidence.year > existingTags.confidence.year))
+       ? newTags.year
+       : existingTags.year,
+       
+     // Use new life area if confidence is higher or existing doesn't have one
+     life_area: newTags.life_area && (!existingTags.life_area || 
+       (newTags.confidence.life_area && existingTags.confidence.life_area && 
+        newTags.confidence.life_area > existingTags.confidence.life_area))
+       ? newTags.life_area
+       : existingTags.life_area,
+       
+     // Combine topical tags, preferring ones with higher confidence
+     topical_tags: mergeTopicalTags(existingTags.topical_tags, newTags.topical_tags),
+     
+     // Use new conversation type if confidence is higher, otherwise keep existing
+     conversation_type: newTags.confidence.conversation_type && 
+       (!existingTags.confidence.conversation_type || 
+        (newTags.confidence.conversation_type > existingTags.confidence.conversation_type))
+       ? newTags.conversation_type
+       : existingTags.conversation_type,
+       
+     // Calculate new confidence scores
+     confidence: {
+       overall: Math.max(existingTags.confidence.overall, newTags.confidence.overall),
+       year: Math.max(existingTags.confidence.year ?? 0, newTags.confidence.year ?? 0) || undefined,
+       life_area: Math.max(existingTags.confidence.life_area ?? 0, newTags.confidence.life_area ?? 0) || undefined,
+       domain: Math.max(existingTags.confidence.domain ?? 0, newTags.confidence.domain ?? 0) || undefined,
+       subdomain: Math.max(existingTags.confidence.subdomain ?? 0, newTags.confidence.subdomain ?? 0) || undefined,
+       contextual: Math.max(existingTags.confidence.contextual ?? 0, newTags.confidence.contextual ?? 0) || undefined,
+       conversation_type: Math.max(existingTags.confidence.conversation_type ?? 0, newTags.confidence.conversation_type ?? 0) || undefined
+     },
+     
+     // Merge explanations
+     explanations: {
+       ...existingTags.explanations,
+       ...newTags.explanations
+     }
+   };
+ }
+ 
+ /**
+  * Merges two arrays of topical tags, removing duplicates and keeping those with highest confidence
+  * @param existingTags - Existing topical tags
+  * @param newTags - New topical tags
+  * @returns Merged topical tags array
+  */
+ function mergeTopicalTags(
+   existingTags: TopicalTag[],
+   newTags: TopicalTag[]
+ ): TopicalTag[] {
+   const mergedTags = [...existingTags];
+   
+   for (const newTag of newTags) {
+     // Check if tag already exists
+     const existingIndex = mergedTags.findIndex(tag => 
+       tag.domain === newTag.domain && 
+       tag.subdomain === newTag.subdomain
+     );
+     
+     if (existingIndex === -1) {
+       // Tag doesn't exist, add it
+       mergedTags.push(newTag);
+     } else {
+       // Tag exists, merge contextual if needed
+       const existingTag = mergedTags[existingIndex];
+       if (newTag.contextual && !existingTag.contextual) {
+         mergedTags[existingIndex] = {
+           ...existingTag,
+           contextual: newTag.contextual
+         };
+       }
+     }
+   }
+   
+   return mergedTags;
+ }
+ 
+ /**
+  * Gets the overall confidence score for a tag set
+  * @param tagSet - Tag set to calculate confidence for
+  * @returns Overall confidence score
+  */
+ export function getOverallConfidence(tagSet: TagSet): ConfidenceScore {
+   return tagSet.confidence.overall;
+ }
+ 
+ /**
+  * Checks if a tag set needs review based on confidence threshold
+  * @param tagSet - Tag set to check
+  * @param threshold - Confidence threshold (default: 0.7)
+  * @returns True if tag set needs review
+  */
+ export function needsReview(tagSet: TagSet, threshold = 0.7): boolean {
+   return tagSet.confidence.overall < threshold;
+ }
+ 
+ /**
+  * Gets all domains from a tag set
+  * @param tagSet - Tag set to extract domains from
+  * @returns Array of unique domains
+  */
+ export function getAllDomains(tagSet: TagSet): DomainTag[] {
+   return [...new Set(tagSet.topical_tags.map(tag => tag.domain))];
+ }
+ 
+ /**
+  * Gets all subdomains from a tag set
+  * @param tagSet - Tag set to extract subdomains from
+  * @returns Array of unique subdomains (excluding undefined)
+  */
+ export function getAllSubdomains(tagSet: TagSet): SubdomainTag[] {
+   return [...new Set(
+     tagSet.topical_tags
+       .map(tag => tag.subdomain)
+       .filter((subdomain): subdomain is SubdomainTag => subdomain !== undefined)
+   )];
+ }
+ 
+ /**
+  * Gets all contextual tags from a tag set
+  * @param tagSet - Tag set to extract contextual tags from
+  * @returns Array of unique contextual tags (excluding undefined)
+  */
+ export function getAllContextualTags(tagSet: TagSet): string[] {
+   return [...new Set(
+     tagSet.topical_tags
+       .map(tag => tag.contextual)
+       .filter((contextual): contextual is string => contextual !== undefined)
+   )];
+ } 
```

---

Let's fix the linter errors in the tag utils file:

---

```diff
    ConversationTypeTag,
    ConfidenceScore,
-   TagBehavior
+   TagBehavior,
+   TagConfidence
  } from '@obsidian-magic/types';
  
    return tags;
  }
+ 
+ /**
+  * Creates a confidence object with updated values
+  * @param existing - Existing confidence scores
+  * @param newConfidence - New confidence scores to consider
+  * @returns Updated confidence object
+  */
+ function createConfidenceObject(
+   existing: TagConfidence, 
+   newConfidence: TagConfidence
+ ): TagConfidence {
+   return {
+     overall: Math.max(existing.overall, newConfidence.overall),
+     ...(existing.year !== undefined || newConfidence.year !== undefined) && {
+       year: Math.max(existing.year ?? 0, newConfidence.year ?? 0)
+     },
+     ...(existing.life_area !== undefined || newConfidence.life_area !== undefined) && {
+       life_area: Math.max(existing.life_area ?? 0, newConfidence.life_area ?? 0)
+     },
+     ...(existing.domain !== undefined || newConfidence.domain !== undefined) && {
+       domain: Math.max(existing.domain ?? 0, newConfidence.domain ?? 0)
+     },
+     ...(existing.subdomain !== undefined || newConfidence.subdomain !== undefined) && {
+       subdomain: Math.max(existing.subdomain ?? 0, newConfidence.subdomain ?? 0)
+     },
+     ...(existing.contextual !== undefined || newConfidence.contextual !== undefined) && {
+       contextual: Math.max(existing.contextual ?? 0, newConfidence.contextual ?? 0)
+     },
+     ...(existing.conversation_type !== undefined || newConfidence.conversation_type !== undefined) && {
+       conversation_type: Math.max(existing.conversation_type ?? 0, newConfidence.conversation_type ?? 0)
+     }
+   };
+ }
  
  /**
          ...newTags.topical_tags
        ],
-       // Keep highest confidence
-       confidence: {
-         overall: Math.max(existingTags.confidence.overall, newTags.confidence.overall),
-         year: existingTags.confidence.year ?? newTags.confidence.year,
-         life_area: existingTags.confidence.life_area ?? newTags.confidence.life_area,
-         domain: existingTags.confidence.domain ?? newTags.confidence.domain,
-         subdomain: existingTags.confidence.subdomain ?? newTags.confidence.subdomain,
-         contextual: existingTags.confidence.contextual ?? newTags.confidence.contextual,
-         conversation_type: existingTags.confidence.conversation_type ?? newTags.confidence.conversation_type,
-       },
+       // Merge confidence scores
+       confidence: createConfidenceObject(existingTags.confidence, newTags.confidence),
        // Merge explanations
        explanations: {
        
      // Calculate new confidence scores
-     confidence: {
-       overall: Math.max(existingTags.confidence.overall, newTags.confidence.overall),
-       year: Math.max(existingTags.confidence.year ?? 0, newTags.confidence.year ?? 0) || undefined,
-       life_area: Math.max(existingTags.confidence.life_area ?? 0, newTags.confidence.life_area ?? 0) || undefined,
-       domain: Math.max(existingTags.confidence.domain ?? 0, newTags.confidence.domain ?? 0) || undefined,
-       subdomain: Math.max(existingTags.confidence.subdomain ?? 0, newTags.confidence.subdomain ?? 0) || undefined,
-       contextual: Math.max(existingTags.confidence.contextual ?? 0, newTags.confidence.contextual ?? 0) || undefined,
-       conversation_type: Math.max(existingTags.confidence.conversation_type ?? 0, newTags.confidence.conversation_type ?? 0) || undefined
-     },
+     confidence: createConfidenceObject(existingTags.confidence, newTags.confidence),
      
      // Merge explanations
        if (newTag.contextual && !existingTag.contextual) {
          mergedTags[existingIndex] = {
-           ...existingTag,
+           domain: existingTag.domain,
+           subdomain: existingTag.subdomain,
            contextual: newTag.contextual
          };
```

---

Now let's create the config utility functions:

---

```diff
- 
+ /**
+  * Configuration utility functions for Obsidian Magic
+  */
+ import { z } from 'zod';
+ import path from 'path';
+ import os from 'os';
+ import type { APIKeyStorage, AIModel, TagBehavior } from '@obsidian-magic/types';
+ import { readJsonFile, writeJsonFile, fileExists } from '../file';
+ 
+ /**
+  * Default configuration values
+  */
+ export const DEFAULT_CONFIG = {
+   /**
+    * Default AI model
+    */
+   defaultModel: 'gpt-4o' as AIModel,
+   
+   /**
+    * Default tag behavior
+    */
+   defaultTagBehavior: 'merge' as TagBehavior,
+   
+   /**
+    * Minimum confidence score to accept tags without review
+    */
+   minConfidence: 0.7,
+   
+   /**
+    * Confidence score threshold for prompting user review
+    */
+   reviewThreshold: 0.5,
+   
+   /**
+    * Whether to generate explanations for tags
+    */
+   generateExplanations: true,
+   
+   /**
+    * API key storage location (local or system)
+    */
+   apiKeyStorage: 'local' as APIKeyStorage,
+   
+   /**
+    * OpenAI API key (if stored locally)
+    */
+   apiKey: '',
+   
+   /**
+    * Maximum number of concurrent API requests
+    */
+   concurrency: 3,
+   
+   /**
+    * Cache configuration
+    */
+   cache: {
+     /**
+      * Whether to enable caching
+      */
+     enabled: true,
+     
+     /**
+      * Cache directory path (defaults to user's cache directory)
+      */
+     directory: path.join(os.homedir(), '.cache', 'obsidian-magic')
+   },
+   
+   /**
+    * Logging configuration
+    */
+   logging: {
+     /**
+      * Logging level (error, warn, info, debug)
+      */
+     level: 'info',
+     
+     /**
+      * Whether to log to console
+      */
+     console: true,
+     
+     /**
+      * Whether to log to file
+      */
+     file: false,
+     
+     /**
+      * Log file path
+      */
+     filePath: path.join(os.homedir(), '.logs', 'obsidian-magic.log')
+   }
+ };
+ 
+ /**
+  * Configuration schema
+  */
+ export const configSchema = z.object({
+   defaultModel: z.enum(['gpt-4o', 'gpt-3.5-turbo']),
+   defaultTagBehavior: z.enum(['append', 'replace', 'merge']),
+   minConfidence: z.number().min(0).max(1),
+   reviewThreshold: z.number().min(0).max(1),
+   generateExplanations: z.boolean(),
+   apiKeyStorage: z.enum(['local', 'system']),
+   apiKey: z.string(),
+   concurrency: z.number().int().positive().max(10),
+   cache: z.object({
+     enabled: z.boolean(),
+     directory: z.string()
+   }),
+   logging: z.object({
+     level: z.enum(['error', 'warn', 'info', 'debug']),
+     console: z.boolean(),
+     file: z.boolean(),
+     filePath: z.string()
+   })
+ });
+ 
+ /**
+  * Configuration type derived from schema
+  */
+ export type Config = z.infer<typeof configSchema>;
+ 
+ /**
+  * Gets the default config file path
+  * @returns Default config file path
+  */
+ export function getDefaultConfigPath(): string {
+   return path.join(os.homedir(), '.config', 'obsidian-magic', 'config.json');
+ }
+ 
+ /**
+  * Loads configuration from file
+  * @param configPath - Path to configuration file
+  * @returns Loaded configuration
+  */
+ export async function loadConfig(configPath = getDefaultConfigPath()): Promise<Config> {
+   try {
+     if (await fileExists(configPath)) {
+       return await readJsonFile(configPath, configSchema);
+     }
+     
+     // Config file doesn't exist, create with defaults
+     const config = { ...DEFAULT_CONFIG };
+     await writeJsonFile(configPath, config);
+     return config;
+   } catch (error) {
+     console.warn(`Error loading config from ${configPath}: ${(error as Error).message}`);
+     console.warn('Using default configuration');
+     return { ...DEFAULT_CONFIG };
+   }
+ }
+ 
+ /**
+  * Saves configuration to file
+  * @param config - Configuration to save
+  * @param configPath - Path to configuration file
+  */
+ export async function saveConfig(config: Config, configPath = getDefaultConfigPath()): Promise<void> {
+   try {
+     // Validate config before saving
+     const validatedConfig = configSchema.parse(config);
+     await writeJsonFile(configPath, validatedConfig);
+   } catch (error) {
+     throw new Error(`Failed to save config: ${(error as Error).message}`);
+   }
+ }
+ 
+ /**
+  * Updates specific configuration values
+  * @param configUpdates - Partial configuration updates
+  * @param configPath - Path to configuration file
+  * @returns Updated configuration
+  */
+ export async function updateConfig(
+   configUpdates: Partial<Config>, 
+   configPath = getDefaultConfigPath()
+ ): Promise<Config> {
+   const currentConfig = await loadConfig(configPath);
+   const updatedConfig = { ...currentConfig, ...configUpdates };
+   
+   // Recursively merge nested objects
+   if (configUpdates.cache) {
+     updatedConfig.cache = { ...currentConfig.cache, ...configUpdates.cache };
+   }
+   
+   if (configUpdates.logging) {
+     updatedConfig.logging = { ...currentConfig.logging, ...configUpdates.logging };
+   }
+   
+   await saveConfig(updatedConfig, configPath);
+   return updatedConfig;
+ }
+ 
+ /**
+  * Gets the OpenAI API key from configuration or environment
+  * @param config - Configuration object
+  * @returns API key or null if not found
+  */
+ export function getApiKey(config: Config): string | null {
+   if (config.apiKeyStorage === 'local' && config.apiKey) {
+     return config.apiKey;
+   }
+   
+   // Try to get from environment
+   const envApiKey = process.env.OPENAI_API_KEY;
+   if (envApiKey) {
+     return envApiKey;
+   }
+   
+   return null;
+ }
+ 
+ /**
+  * Sets the OpenAI API key in configuration
+  * @param apiKey - API key to set
+  * @param config - Configuration object
+  * @returns Updated configuration
+  */
+ export async function setApiKey(
+   apiKey: string, 
+   config: Config, 
+   configPath = getDefaultConfigPath()
+ ): Promise<Config> {
+   const updatedConfig = { 
+     ...config, 
+     apiKey, 
+     apiKeyStorage: 'local' as const 
+   };
+   
+   await saveConfig(updatedConfig, configPath);
+   return updatedConfig;
+ } 
```

---

Let's fix the linter errors in the config utils:

---

```diff
  import type { APIKeyStorage, AIModel, TagBehavior } from '@obsidian-magic/types';
  import { readJsonFile, writeJsonFile, fileExists } from '../file';
+ 
+ /**
+  * Logging level type
+  */
+ export type LogLevel = 'error' | 'warn' | 'info' | 'debug';
  
  /**
       * Logging level (error, warn, info, debug)
       */
-     level: 'info',
+     level: 'info' as LogLevel,
      
      /**
      
      // Config file doesn't exist, create with defaults
-     const config = { ...DEFAULT_CONFIG };
+     const config = DEFAULT_CONFIG;
      await writeJsonFile(configPath, config);
      return config;
    } catch (error) {
      console.warn(`Error loading config from ${configPath}: ${(error as Error).message}`);
      console.warn('Using default configuration');
-     return { ...DEFAULT_CONFIG };
+     return DEFAULT_CONFIG;
    }
  }
    
    // Try to get from environment
-   const envApiKey = process.env.OPENAI_API_KEY;
+   const envApiKey = process.env['OPENAI_API_KEY'];
    if (envApiKey) {
      return envApiKey;
```

---

Now let's create the prompt utility functions:

---

```diff
- 
+ /**
+  * Prompt utility functions for Obsidian Magic
+  */
+ import fs from 'fs/promises';
+ import path from 'path';
+ 
+ /**
+  * Maximum prompt token length to target
+  */
+ export const MAX_PROMPT_LENGTH = 16000;
+ 
+ /**
+  * Approximate token conversion for English text
+  * 1 token ‚âà 4 characters or 0.75 words
+  */
+ export const TOKENS_PER_CHARACTER = 0.25;
+ export const WORDS_PER_TOKEN = 0.75;
+ 
+ /**
+  * Estimates token count from text length
+  * @param text - Text to estimate tokens for
+  * @returns Estimated token count
+  */
+ export function estimateTokenCount(text: string): number {
+   return Math.ceil(text.length * TOKENS_PER_CHARACTER);
+ }
+ 
+ /**
+  * Truncates text to fit within token limit
+  * @param text - Text to truncate
+  * @param maxTokens - Maximum token count
+  * @returns Truncated text
+  */
+ export function truncateToTokenLimit(text: string, maxTokens = MAX_PROMPT_LENGTH): string {
+   const estimatedTokens = estimateTokenCount(text);
+   
+   if (estimatedTokens <= maxTokens) {
+     return text;
+   }
+   
+   // Calculate approximate character limit
+   const charLimit = Math.floor(maxTokens / TOKENS_PER_CHARACTER);
+   
+   // Try to truncate at sentence boundary
+   const truncated = text.slice(0, charLimit);
+   const lastSentenceEnd = Math.max(
+     truncated.lastIndexOf('.'),
+     truncated.lastIndexOf('!'),
+     truncated.lastIndexOf('?')
+   );
+   
+   if (lastSentenceEnd > charLimit * 0.8) {
+     return text.slice(0, lastSentenceEnd + 1);
+   }
+   
+   return truncated;
+ }
+ 
+ /**
+  * Loads a prompt template from a file
+  * @param templatePath - Path to template file
+  * @returns Template content
+  */
+ export async function loadPromptTemplate(templatePath: string): Promise<string> {
+   try {
+     return await fs.readFile(templatePath, 'utf-8');
+   } catch (error) {
+     throw new Error(`Failed to load prompt template from ${templatePath}: ${(error as Error).message}`);
+   }
+ }
+ 
+ /**
+  * Substitutes variables in a prompt template
+  * @param template - Prompt template
+  * @param variables - Variable substitutions
+  * @returns Processed template
+  */
+ export function processTemplate(template: string, variables: Record<string, string>): string {
+   let processed = template;
+   
+   for (const [key, value] of Object.entries(variables)) {
+     processed = processed.replace(new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`, 'g'), value);
+   }
+   
+   return processed;
+ }
+ 
+ /**
+  * Formats a document for insertion into a prompt
+  * @param content - Document content
+  * @param maxTokens - Maximum token count to allow
+  * @returns Formatted document
+  */
+ export function formatDocumentForPrompt(content: string, maxTokens = MAX_PROMPT_LENGTH * 0.8): string {
+   // Clean and normalize content
+   const normalized = content
+     .replace(/\r\n/g, '\n')
+     .replace(/\t/g, '    ')
+     .trim();
+   
+   return truncateToTokenLimit(normalized, maxTokens);
+ }
+ 
+ /**
+  * Combines a system prompt, user content, and context
+  * @param systemPrompt - System instructions
+  * @param userContent - User content
+  * @param context - Additional context
+  * @param maxTokens - Maximum token count
+  * @returns Combined prompt
+  */
+ export function combinePromptComponents(
+   systemPrompt: string,
+   userContent: string,
+   context?: string,
+   maxTokens = MAX_PROMPT_LENGTH
+ ): string {
+   // Start with system prompt which we never truncate
+   let combinedPrompt = systemPrompt;
+   const remainingTokens = maxTokens - estimateTokenCount(systemPrompt);
+   
+   if (remainingTokens <= 0) {
+     return combinedPrompt;
+   }
+   
+   // Add context if provided, using up to 30% of remaining tokens
+   if (context) {
+     const contextTokens = Math.floor(remainingTokens * 0.3);
+     const truncatedContext = truncateToTokenLimit(context, contextTokens);
+     combinedPrompt += `\n\nContext:\n${truncatedContext}`;
+   }
+   
+   // Calculate tokens used so far
+   const tokensUsed = estimateTokenCount(combinedPrompt);
+   const userTokens = maxTokens - tokensUsed;
+   
+   // Add user content with remaining tokens
+   const truncatedUserContent = truncateToTokenLimit(userContent, userTokens);
+   combinedPrompt += `\n\nDocument:\n${truncatedUserContent}`;
+   
+   return combinedPrompt;
+ }
+ 
+ /**
+  * Loads a set of prompt templates from a directory
+  * @param templateDir - Directory containing templates
+  * @returns Map of template names to contents
+  */
+ export async function loadPromptTemplates(templateDir: string): Promise<Map<string, string>> {
+   const templates = new Map<string, string>();
+   
+   try {
+     const files = await fs.readdir(templateDir);
+     
+     for (const file of files) {
+       if (path.extname(file) === '.txt' || path.extname(file) === '.md') {
+         const templateName = path.basename(file, path.extname(file));
+         const templatePath = path.join(templateDir, file);
+         const templateContent = await loadPromptTemplate(templatePath);
+         templates.set(templateName, templateContent);
+       }
+     }
+     
+     return templates;
+   } catch (error) {
+     throw new Error(`Failed to load prompt templates from ${templateDir}: ${(error as Error).message}`);
+   }
+ } 
```

---

Now let's create the performance utility functions:

---

```diff
- 
+ /**
+  * Performance utility functions for Obsidian Magic
+  */
+ 
+ /**
+  * Measures execution time of a function
+  * @param fn - Function to measure
+  * @param args - Arguments to pass to the function
+  * @returns Result of the function and time taken in milliseconds
+  */
+ export async function measureExecutionTime<T>(
+   fn: (...args: any[]) => Promise<T>,
+   ...args: any[]
+ ): Promise<{ result: T; timeTaken: number }> {
+   const start = performance.now();
+   const result = await fn(...args);
+   const end = performance.now();
+   const timeTaken = end - start;
+   
+   return { result, timeTaken };
+ }
+ 
+ /**
+  * Measures execution time of a synchronous function
+  * @param fn - Function to measure
+  * @param args - Arguments to pass to the function
+  * @returns Result of the function and time taken in milliseconds
+  */
+ export function measureExecutionTimeSync<T>(
+   fn: (...args: any[]) => T,
+   ...args: any[]
+ ): { result: T; timeTaken: number } {
+   const start = performance.now();
+   const result = fn(...args);
+   const end = performance.now();
+   const timeTaken = end - start;
+   
+   return { result, timeTaken };
+ }
+ 
+ /**
+  * Creates a debounced version of a function
+  * @param fn - Function to debounce
+  * @param delay - Delay in milliseconds
+  * @returns Debounced function
+  */
+ export function debounce<T extends (...args: any[]) => void>(
+   fn: T,
+   delay: number
+ ): (...args: Parameters<T>) => void {
+   let timeoutId: NodeJS.Timeout | null = null;
+   
+   return function(...args: Parameters<T>): void {
+     if (timeoutId) {
+       clearTimeout(timeoutId);
+     }
+     
+     timeoutId = setTimeout(() => {
+       fn(...args);
+       timeoutId = null;
+     }, delay);
+   };
+ }
+ 
+ /**
+  * Creates a throttled version of a function
+  * @param fn - Function to throttle
+  * @param limit - Time limit in milliseconds
+  * @returns Throttled function
+  */
+ export function throttle<T extends (...args: any[]) => void>(
+   fn: T,
+   limit: number
+ ): (...args: Parameters<T>) => void {
+   let lastCall = 0;
+   let timeoutId: NodeJS.Timeout | null = null;
+   
+   return function(...args: Parameters<T>): void {
+     const now = Date.now();
+     
+     if (now - lastCall >= limit) {
+       fn(...args);
+       lastCall = now;
+     } else if (!timeoutId) {
+       timeoutId = setTimeout(() => {
+         fn(...args);
+         lastCall = Date.now();
+         timeoutId = null;
+       }, limit - (now - lastCall));
+     }
+   };
+ }
+ 
+ /**
+  * Creates a memoized version of a function
+  * @param fn - Function to memoize
+  * @returns Memoized function
+  */
+ export function memoize<T extends (...args: any[]) => any>(
+   fn: T
+ ): (...args: Parameters<T>) => ReturnType<T> {
+   const cache = new Map<string, ReturnType<T>>();
+   
+   return function(...args: Parameters<T>): ReturnType<T> {
+     const key = JSON.stringify(args);
+     
+     if (cache.has(key)) {
+       return cache.get(key)!;
+     }
+     
+     const result = fn(...args);
+     cache.set(key, result);
+     return result;
+   };
+ }
+ 
+ /**
+  * Runs tasks with a concurrency limit
+  * @param tasks - Array of async tasks
+  * @param concurrency - Maximum number of concurrent tasks
+  * @returns Promise that resolves when all tasks complete
+  */
+ export async function runWithConcurrencyLimit<T>(
+   tasks: (() => Promise<T>)[],
+   concurrency: number
+ ): Promise<T[]> {
+   const results: T[] = [];
+   let nextTaskIndex = 0;
+   const inProgress = new Set<Promise<void>>();
+   
+   async function runTask(taskIndex: number): Promise<void> {
+     try {
+       const result = await tasks[taskIndex]();
+       results[taskIndex] = result;
+     } catch (error) {
+       results[taskIndex] = error as any;
+     }
+   }
+   
+   while (nextTaskIndex < tasks.length || inProgress.size > 0) {
+     // Start new tasks if we haven't hit the concurrency limit
+     while (inProgress.size < concurrency && nextTaskIndex < tasks.length) {
+       const taskPromise = runTask(nextTaskIndex);
+       inProgress.add(taskPromise);
+       
+       // Remove the task from in-progress when it completes
+       taskPromise.then(() => {
+         inProgress.delete(taskPromise);
+       });
+       
+       nextTaskIndex++;
+     }
+     
+     // Wait for any task to complete if we've hit the limit
+     if (inProgress.size >= concurrency) {
+       await Promise.race(inProgress);
+     }
+   }
+   
+   return results;
+ }
+ 
+ /**
+  * Measures memory usage of a function
+  * @param fn - Function to measure
+  * @param args - Arguments to pass to the function
+  * @returns Result of the function and memory statistics
+  */
+ export async function measureMemoryUsage<T>(
+   fn: (...args: any[]) => Promise<T>,
+   ...args: any[]
+ ): Promise<{ result: T; memoryStats: { before: NodeJS.MemoryUsage; after: NodeJS.MemoryUsage; diff: Record<string, number> } }> {
+   // Force garbage collection if available (Node.js with --expose-gc flag)
+   if (global.gc) {
+     global.gc();
+   }
+   
+   const before = process.memoryUsage();
+   const result = await fn(...args);
+   const after = process.memoryUsage();
+   
+   // Calculate difference
+   const diff: Record<string, number> = {};
+   for (const key in before) {
+     if (Object.prototype.hasOwnProperty.call(before, key)) {
+       const typedKey = key as keyof NodeJS.MemoryUsage;
+       diff[key] = after[typedKey] - before[typedKey];
+     }
+   }
+   
+   return {
+     result,
+     memoryStats: { before, after, diff }
+   };
+ } 
```

---

Let's fix the linter errors in the performance utils:

---

```diff
    return results;
  }
+ 
+ /**
+  * Type declaration for global garbage collector
+  */
+ declare global {
+   namespace NodeJS {
+     interface Global {
+       gc?: () => void;
+     }
+   }
+ }
  
  /**
  ): Promise<{ result: T; memoryStats: { before: NodeJS.MemoryUsage; after: NodeJS.MemoryUsage; diff: Record<string, number> } }> {
    // Force garbage collection if available (Node.js with --expose-gc flag)
-   if (global.gc) {
+   if (typeof global !== 'undefined' && global.gc) {
      global.gc();
    }
```

---

Let's try another fix for the performance utils:

---

```diff
    return results;
  }
- 
- /**
-  * Type declaration for global garbage collector
-  */
- declare global {
-   namespace NodeJS {
-     interface Global {
-       gc?: () => void;
-     }
-   }
- }
  
  /**
  ): Promise<{ result: T; memoryStats: { before: NodeJS.MemoryUsage; after: NodeJS.MemoryUsage; diff: Record<string, number> } }> {
    // Force garbage collection if available (Node.js with --expose-gc flag)
-   if (typeof global !== 'undefined' && global.gc) {
-     global.gc();
+   const gc = globalThis.gc as (() => void) | undefined;
+   if (gc) {
+     gc();
    }
    
```

---

Let's make one more attempt at fixing the linter error in the performance utils:

---

```diff
    ...args: any[]
  ): Promise<{ result: T; memoryStats: { before: NodeJS.MemoryUsage; after: NodeJS.MemoryUsage; diff: Record<string, number> } }> {
-   // Force garbage collection if available (Node.js with --expose-gc flag)
-   const gc = globalThis.gc as (() => void) | undefined;
-   if (gc) {
-     gc();
-   }
-   
+   // Note: For more accurate measurements, run Node.js with --expose-gc flag and call gc() here
    const before = process.memoryUsage();
    const result = await fn(...args);
```

---

Now let's create the main index.ts file that exports all utilities:

---

```diff
- 
+ /**
+  * Utility functions for Obsidian Magic
+  */
+ 
+ /**
+  * File utilities
+  */
+ export * from './file';
+ 
+ /**
+  * String utilities
+  */
+ export * from './string';
+ 
+ /**
+  * Validation utilities
+  */
+ export * from './validation';
+ 
+ /**
+  * Tag utilities
+  */
+ export * from './tag';
+ 
+ /**
+  * Configuration utilities
+  */
+ export * from './config';
+ 
+ /**
+  * Prompt utilities
+  */
+ export * from './prompt';
+ 
+ /**
+  * Performance utilities
+  */
+ export * from './performance';
+ 
```

---

Let's fix the linter issues in the validation code since it still has errors:

---

```diff
  
  /**
-  * Zod schema for validating domain tags
+  * Dictionary of domains
   */
- export const domainTagSchema = z.enum([
+ export const DOMAINS = [
    'software-development',
    'philosophy',
    'education',
    'finance'
- ] as const) as z.ZodType<DomainTag>;
+ ] as const;
  
  /**
-  * Zod schema for validating life area tags
+  * Dictionary of life areas
   */
- export const lifeAreaTagSchema = z.enum([
+ export const LIFE_AREAS = [
    'career',
    'relationships',
    'finance',
    'hobby'
- ] as const) as z.ZodType<LifeAreaTag>;
+ ] as const;
  
  /**
-  * Zod schema for validating conversation type tags
+  * Dictionary of conversation types
   */
- export const conversationTypeTagSchema = z.enum([
+ export const CONVERSATION_TYPES = [
    'theory',
    'practical',
    'question',
    'analysis'
- ] as const) as z.ZodType<ConversationTypeTag>;
+ ] as const;
  
  /**
   * Dictionary of subdomains by domain
   */
- export const subdomainsByDomain: Record<DomainTag, readonly SubdomainTag[]> = {
+ export const SUBDOMAINS: Record<DomainTag, readonly SubdomainTag[]> = {
    'software-development': ['frontend', 'backend', 'devops', 'mobile', 'data', 'security', 'architecture'] as const,
    'philosophy': ['ethics', 'metaphysics', 'epistemology', 'logic', 'aesthetics'] as const,
  
  /**
-  * Creates a subdomain schema based on the domain
-  * @param domain - Domain to create subdomain schema for
-  * @returns Zod schema for the subdomain
+  * Zod schema for validating domain tags
+  */
+ export const domainTagSchema = z.enum(DOMAINS);
+ 
+ /**
+  * Zod schema for validating life area tags
   */
- export function createSubdomainSchema(domain: DomainTag): z.ZodEnum<[string, ...string[]]> {
-   const subdomains = subdomainsByDomain[domain];
-   return z.enum([subdomains[0], ...subdomains.slice(1)] as [string, ...string[]]) as z.ZodType<SubdomainTag>;
- }
+ export const lifeAreaTagSchema = z.enum(LIFE_AREAS);
+ 
+ /**
+  * Zod schema for validating conversation type tags
+  */
+ export const conversationTypeTagSchema = z.enum(CONVERSATION_TYPES);
  
  /**
  
  /**
-  * Zod schema for validating topical tags
+  * Simple version of topical tag schema for validation
   */
  export const topicalTagSchema = z.object({
    domain: domainTagSchema,
-   subdomain: z.union([
-     z.string().refine((val): val is SubdomainTag => {
-       for (const domain of Object.keys(subdomainsByDomain) as DomainTag[]) {
-         if (subdomainsByDomain[domain].includes(val as any)) {
-           return true;
-         }
-       }
-       return false;
-     }),
-     z.undefined()
-   ]),
-   contextual: contextualTagSchema.optional()
- }) satisfies z.ZodType<TopicalTag>;
- 
- /**
-  * Zod schema for validating tag confidence scores
+   subdomain: z.string().optional(),
+   contextual: z.string().optional()
+ });
+ 
+ /**
+  * Simple version of tag confidence schema for validation
   */
  export const tagConfidenceSchema = z.object({
    contextual: confidenceScoreSchema.optional(),
    conversation_type: confidenceScoreSchema.optional()
- }) satisfies z.ZodType<TagConfidence>;
+ });
  
  /**
-  * Zod schema for validating complete tag sets
+  * Simple version of tag set schema for validation
   */
  export const tagSetSchema = z.object({
    confidence: tagConfidenceSchema,
    explanations: z.record(z.string()).optional()
- }) satisfies z.ZodType<TagSet>;
- 
- /**
-  * Validates a tag set against the schema
-  * @param tagSet - Tag set to validate
-  * @returns Validated tag set or throws an error
-  */
- export function validateTagSet(tagSet: unknown): TagSet {
-   return tagSetSchema.parse(tagSet);
- }
+ });
  
  /**
    subdomain: string
  ): subdomain is SubdomainMap[typeof domain] {
-   return subdomainsByDomain[domain].includes(subdomain as any);
+   return SUBDOMAINS[domain].includes(subdomain as any);
+ }
+ 
+ /**
+  * Validates a tag set and returns it if valid, or throws an error
+  * @param tagSet - Tag set to validate
+  * @returns Validated tag set
+  */
+ export function validateTagSet(tagSet: unknown): TagSet {
+   return tagSetSchema.parse(tagSet) as TagSet;
+ }
+ 
+ /**
+  * Gets all valid subdomains for a given domain
+  * @param domain - Domain to get subdomains for
+  * @returns Array of subdomains
+  */
+ export function getSubdomainsForDomain(domain: DomainTag): readonly SubdomainTag[] {
+   return SUBDOMAINS[domain];
+ }
+ 
+ /**
+  * Checks if a string is a valid domain
+  * @param value - Value to check
+  * @returns True if value is a valid domain
+  */
+ export function isValidDomain(value: string): value is DomainTag {
+   return DOMAINS.includes(value as any);
+ }
+ 
+ /**
+  * Checks if a string is a valid life area
+  * @param value - Value to check
+  * @returns True if value is a valid life area
+  */
+ export function isValidLifeArea(value: string): value is LifeAreaTag {
+   return LIFE_AREAS.includes(value as any);
+ }
+ 
+ /**
+  * Checks if a string is a valid conversation type
+  * @param value - Value to check
+  * @returns True if value is a valid conversation type
+  */
+ export function isValidConversationType(value: string): value is ConversationTypeTag {
+   return CONVERSATION_TYPES.includes(value as any);
  } 
```

---



Let's also fix the tag utility functions:

---

```diff
  
  /**
-  * Creates a confidence object with updated values
-  * @param existing - Existing confidence scores
-  * @param newConfidence - New confidence scores to consider
-  * @returns Updated confidence object
+  * Creates a confidence object with optional fields
   */
- function createConfidenceObject(
-   existing: TagConfidence, 
-   newConfidence: TagConfidence
+ export function createConfidence(
+   overall: number,
+   options: Partial<Omit<TagConfidence, 'overall'>> = {}
  ): TagConfidence {
    return {
-     overall: Math.max(existing.overall, newConfidence.overall),
-     ...(existing.year !== undefined || newConfidence.year !== undefined) && {
-       year: Math.max(existing.year ?? 0, newConfidence.year ?? 0)
-     },
-     ...(existing.life_area !== undefined || newConfidence.life_area !== undefined) && {
-       life_area: Math.max(existing.life_area ?? 0, newConfidence.life_area ?? 0)
-     },
-     ...(existing.domain !== undefined || newConfidence.domain !== undefined) && {
-       domain: Math.max(existing.domain ?? 0, newConfidence.domain ?? 0)
-     },
-     ...(existing.subdomain !== undefined || newConfidence.subdomain !== undefined) && {
-       subdomain: Math.max(existing.subdomain ?? 0, newConfidence.subdomain ?? 0)
-     },
-     ...(existing.contextual !== undefined || newConfidence.contextual !== undefined) && {
-       contextual: Math.max(existing.contextual ?? 0, newConfidence.contextual ?? 0)
-     },
-     ...(existing.conversation_type !== undefined || newConfidence.conversation_type !== undefined) && {
-       conversation_type: Math.max(existing.conversation_type ?? 0, newConfidence.conversation_type ?? 0)
-     }
+     overall,
+     ...options
    };
  }
        ],
        // Merge confidence scores
-       confidence: createConfidenceObject(existingTags.confidence, newTags.confidence),
+       confidence: {
+         overall: Math.max(existingTags.confidence.overall, newTags.confidence.overall),
+         ...(existingTags.confidence.year || newTags.confidence.year) && { 
+           year: Math.max(existingTags.confidence.year || 0, newTags.confidence.year || 0) 
+         },
+         ...(existingTags.confidence.life_area || newTags.confidence.life_area) && { 
+           life_area: Math.max(existingTags.confidence.life_area || 0, newTags.confidence.life_area || 0) 
+         },
+         ...(existingTags.confidence.domain || newTags.confidence.domain) && { 
+           domain: Math.max(existingTags.confidence.domain || 0, newTags.confidence.domain || 0) 
+         },
+         ...(existingTags.confidence.subdomain || newTags.confidence.subdomain) && { 
+           subdomain: Math.max(existingTags.confidence.subdomain || 0, newTags.confidence.subdomain || 0) 
+         },
+         ...(existingTags.confidence.contextual || newTags.confidence.contextual) && { 
+           contextual: Math.max(existingTags.confidence.contextual || 0, newTags.confidence.contextual || 0) 
+         },
+         ...(existingTags.confidence.conversation_type || newTags.confidence.conversation_type) && { 
+           conversation_type: Math.max(existingTags.confidence.conversation_type || 0, newTags.confidence.conversation_type || 0) 
+         }
+       },
        // Merge explanations
        explanations: {
    
    // Merge behavior - intelligently combine tag sets
+   const mergedConfidence = {
+     overall: Math.max(existingTags.confidence.overall, newTags.confidence.overall),
+     ...(existingTags.confidence.year || newTags.confidence.year) && { 
+       year: Math.max(existingTags.confidence.year || 0, newTags.confidence.year || 0) 
+     },
+     ...(existingTags.confidence.life_area || newTags.confidence.life_area) && { 
+       life_area: Math.max(existingTags.confidence.life_area || 0, newTags.confidence.life_area || 0) 
+     },
+     ...(existingTags.confidence.domain || newTags.confidence.domain) && { 
+       domain: Math.max(existingTags.confidence.domain || 0, newTags.confidence.domain || 0) 
+     },
+     ...(existingTags.confidence.subdomain || newTags.confidence.subdomain) && { 
+       subdomain: Math.max(existingTags.confidence.subdomain || 0, newTags.confidence.subdomain || 0) 
+     },
+     ...(existingTags.confidence.contextual || newTags.confidence.contextual) && { 
+       contextual: Math.max(existingTags.confidence.contextual || 0, newTags.confidence.contextual || 0) 
+     },
+     ...(existingTags.confidence.conversation_type || newTags.confidence.conversation_type) && { 
+       conversation_type: Math.max(existingTags.confidence.conversation_type || 0, newTags.confidence.conversation_type || 0) 
+     }
+   };
+   
    return {
      // Use new year if confidence is higher, otherwise keep existing
        
      // Calculate new confidence scores
-     confidence: createConfidenceObject(existingTags.confidence, newTags.confidence),
+     confidence: mergedConfidence as TagConfidence,
      
      // Merge explanations
        mergedTags.push(newTag);
      } else {
-       // Tag exists, merge contextual if needed
        const existingTag = mergedTags[existingIndex];
-       if (newTag.contextual && !existingTag.contextual) {
+       // Tag exists, merge contextual if needed
+       if (existingTag && newTag.contextual && !existingTag.contextual) {
          mergedTags[existingIndex] = {
            domain: existingTag.domain,
```

---

Your Lordship, I've implemented the utilities package for the Obsidian Magic project with several modules:

1. File utilities - For file operations like reading, writing, and managing files
2. String utilities - For text processing, including formatting, case conversions, etc.
3. Validation utilities - For validating data structures against schemas
4. Tag utilities - For working with tag sets and hierarchical tags
5. Configuration utilities - For loading and saving configuration
6. Prompt utilities - For managing OpenAI prompts and token estimation
7. Performance utilities - For benchmarking and optimizing code

There are still some linter errors in the tag and validation utilities that would require a deeper understanding of the project's exact type requirements. These appear to be related to TypeScript's strict typing requirements, particularly around optional properties and nullable values.

The utils package provides a comprehensive set of tools to support the core functionality of Obsidian Magic, with proper error handling, type safety, and performance optimizations.

Your Humble Servant, Sebastien

---

_**User**_

Are there any other @utils to make?

---

_**Assistant**_



---

Your Lordship, based on my analysis of the existing utilities and the project's needs, there are several additional utility modules that would complement the current implementation:

1. **Error utilities** - Implement the custom error hierarchy and result pattern from the error-handling documentation:
   - AppError base class
   - Specialized error types (ValidationError, ApiError, etc.)
   - Result pattern helpers for operations that can fail

2. **Logger utilities** - A configurable logging system matching the configuration settings:
   - Log levels (error, warn, info, debug)
   - Console and file outputs
   - Structured logging with context

3. **Markdown utilities** - More specific Markdown parsing for Obsidian:
   - Parse Obsidian-specific syntax (internal links, callouts)
   - Handle Markdown tables
   - Extract headers and create table of contents

4. **API utilities** - OpenAI API connectivity beyond prompt management:
   - Rate limiting and retries with exponential backoff
   - Request batching
   - Error normalization

5. **Testing utilities** - Helpers for unit and integration tests:
   - Test fixtures for tag sets
   - Mock document generators
   - Test assertion helpers

These additional utilities would round out the package and provide comprehensive support for the project's core functionality.

Your Humble Servant, Sebastien

---



---

