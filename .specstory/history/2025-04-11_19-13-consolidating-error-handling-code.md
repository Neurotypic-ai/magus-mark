<!-- Generated by SpecStory -->

# Consolidating Error Handling Code (2025-04-11 15:13:22)

_**User**_

We need to fix some duplicated errors code. I want one canonical errors.ts. @errors.ts @errors.ts @errors.ts @errors.ts and @errors.test.ts are all copied over and over. Let's update @error-handling.md @error-handling.md and @error-handling.mdc so that it reflects the merged version. 

---

_**Assistant**_



---

Your Lordship, I'll consolidate the error handling code into a canonical implementation and update the documentation to match. Let me analyze the current state first.

---

<details>
            <summary>Grep search for "import.*errors" ‚Ä¢ **20** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/index.ts` | L14 | `import { AppError } from './utils/errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/index.ts` | L17 | `// Import update-notifier dynamically to avoid linter errors` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/obsidian-plugin/src/services/TaggingService.ts` | L7 | `import { ApiError, ApiKeyError, FileSystemError, TaggingError, failure, success, withRetry } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/obsidian-plugin/src/services/TaggingService.ts` | L12 | `import type { Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_19-08-fixing-linter-errors-in-typescript.md` | L23 | `- import { APIError, AppError, ErrorCodes, normalizeError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_19-08-fixing-linter-errors-in-typescript.md` | L24 | `+ import { APIError, ErrorCodes, normalizeError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_08-08-implementing-cli-with-context.md` | L1369 | `Let's update our main index.ts file to fix the import errors:` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_18-59-fixing-linter-errors-in-apps.md` | L248 | `| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/index.ts` | L14 | `import { AppError } from './utils/errors';` |` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_18-59-fixing-linter-errors-in-apps.md` | L249 | `| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/index.ts` | L17 | `// Import update-notifier dynamically to avoid linter errors` |` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_18-59-fixing-linter-errors-in-apps.md` | L275 | `| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/utils/benchmark.ts` | L5 | `import { AppError, Result } from './errors';` |` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_17-51-removing-websocket-dependency-discussion.md` | L430 | `7 import { APIError, AppError, ErrorCodes, normalizeError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_17-51-removing-websocket-dependency-discussion.md` | L895 | `6 import { Result, AppError, FileSystemError, ValidationError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_17-51-removing-websocket-dependency-discussion.md` | L900 | `6 import { Result, AppError, FileSystemError, ValidationError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_17-51-removing-websocket-dependency-discussion.md` | L1120 | `7 import { APIError, AppError, ErrorCodes, normalizeError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-04-obsidian-plugin-development-discussion.md` | L2997 | `7 import { Result, tryCatch } from './errors.js';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-04-obsidian-plugin-development-discussion.md` | L3485 | `- import { Result, tryCatch } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-04-obsidian-plugin-development-discussion.md` | L3486 | `+ import { Result, tryCatch, AppError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-04-obsidian-plugin-development-discussion.md` | L3540 | `- import { Result, tryCatch, AppError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-04-obsidian-plugin-development-discussion.md` | L3541 | `+ import { Result, tryCatch, AppError, FileSystemError, ValidationError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_08-31-core-implementation-completion.md` | L1827 | `+ import { MarkdownError } from '../errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_08-31-core-implementation-completion.md` | L2220 | `+ import { APIError, AppError, ErrorCodes, normalizeError } from '../errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-33-file-structure-restructuring-discussion.md` | L587 | `import { AppError } from './utils/errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-33-file-structure-restructuring-discussion.md` | L882 | `6 import { Result, AppError, FileSystemError, ValidationError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-33-file-structure-restructuring-discussion.md` | L888 | `6 import { Result, AppError, FileSystemError, ValidationError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-33-file-structure-restructuring-discussion.md` | L1000 | `+ import { AppError } from './utils/errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-33-file-structure-restructuring-discussion.md` | L1002 | `- import { AppError } from './utils/errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-33-file-structure-restructuring-discussion.md` | L1007 | `// Import update-notifier dynamically to avoid linter errors` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/obsidian-plugin/src/services/KeyManager.ts` | L2 | `import { ApiKeyError, AppError, FileSystemError, failure, success } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/obsidian-plugin/src/services/KeyManager.ts` | L5 | `import type { Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_10-24-finalize-obsidian-plugin-development.md` | L2800 | `- import { ApiError, ApiKeyError, FileSystemError, Result, TaggingError, failure, success, withRetry } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_10-24-finalize-obsidian-plugin-development.md` | L2823 | `+ import type { Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_10-24-finalize-obsidian-plugin-development.md` | L2824 | `+ import { success, failure } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_10-24-finalize-obsidian-plugin-development.md` | L3149 | `+ import { ApiKeyError, FileSystemError, AppError, success, failure, type Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_10-24-finalize-obsidian-plugin-development.md` | L3456 | `- import { ApiKeyError, AppError, FileSystemError, failure, success } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_10-24-finalize-obsidian-plugin-development.md` | L3459 | `+ import { ApiKeyError, FileSystemError, AppError, success, failure, type Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_10-24-finalize-obsidian-plugin-development.md` | L3461 | `- import type { Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-44-completing-cli-implementation.md` | L4882 | `import { Result, AppError, FileSystemError, ValidationError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-44-completing-cli-implementation.md` | L8115 | `+ import { AppError } from './utils/errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-44-completing-cli-implementation.md` | L8128 | `- import { AppError } from './utils/errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/utils/cost-manager.ts` | L5 | `import { CostLimitError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_09-19-fixing-module-export-error-in-code.md` | L247 | `This approach provides better encapsulation and maintains the same functionality while resolving the import errors.` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-31-file-structure-restructuring-discussion.md` | L1079 | `+ import { APIError, AppError, ErrorCodes, normalizeError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/.specstory/history/2025-04-11_16-31-file-structure-restructuring-discussion.md` | L2040 | `+ import { MarkdownError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/utils/benchmark.ts` | L5 | `import { AppError, Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/packages/core/src/openai.ts` | L6 | `import { APIError, ErrorCodes, normalizeError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/packages/core/src/markdown.ts` | L3 | `import { MarkdownError } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/apps/cli/src/utils/benchmark.ts` | L5 | `import { AppError, Result } from './errors';` |
| `file:///Users/khallmark/Desktop/Code/obsidian-magic/packages/core/src/openai.ts` | L6 | `import { APIError, ErrorCodes, normalizeError } from './errors';` |

</details>

---

Let me examine the current error handling implementations more closely:

---

<details>
            <summary>Listed directory packages ‚Ä¢ **4** results</summary>
        
| Name |
|-------|
| üìÅ `utils` |
| üìÅ `testing` |
| üìÅ `core` |
| üìÅ `types` |

</details>

---

<details>
            <summary>Listed directory packages/core/src ‚Ä¢ **7** results</summary>
        
| Name |
|-------|
| üìÑ `openai.ts` |
| üìÅ `tagging` |
| üìÑ `tagging.ts` |
| üìÅ `openai` |
| üìÑ `markdown.ts` |
| üìÑ `errors.ts` |
| üìÑ `index.ts` |

</details>

---

I'll create a consolidated error handling implementation in the shared package. First, let's create the canonical errors implementation:

---

```diff
  /**
-  * Custom error classes for standardized error handling across the application
-  */
+  * Unified error handling system for Obsidian Magic
+  */
+ 
+ /**
+  * Base error options
+  */
+ export interface ErrorOptions {
+   code?: string;
+   cause?: Error;
+   context?: Record<string, unknown>;
+   recoverable?: boolean;
+ }
  
  /**
   * Base application error class
   */
  export class AppError extends Error {
-   code: string;
-   recoverable: boolean;
+   public readonly code: string;
+   public override readonly cause?: Error;
+   public readonly context?: Record<string, unknown>;
+   public readonly recoverable: boolean;
  
-   constructor(message: string, code: string, recoverable = false) {
+   constructor(message: string, options: ErrorOptions = {}) {
      super(message);
      this.name = this.constructor.name;
-     this.code = code;
-     this.recoverable = recoverable;
+     this.code = options.code ?? 'UNKNOWN_ERROR';
+     this.cause = options.cause;
+     this.context = options.context;
+     this.recoverable = options.recoverable ?? false;
  
-     // Ensure proper prototype chain for instanceof checks
-     Object.setPrototypeOf(this, new.target.prototype);
+     // Maintain proper stack trace
+     if (Error.captureStackTrace) {
+       Error.captureStackTrace(this, this.constructor);
+     }
+   }
+ 
+   /**
+    * Format the error for display
+    */
+   public format(): string {
+     let result = `${this.name} [${this.code}]: ${this.message}`;
+ 
+     // Add context if available
+     const contextJSON = this.context ? JSON.stringify(this.context, null, 2) : '';
+     if (contextJSON !== '{}' && contextJSON !== '') {
+       result += `\nContext: ${contextJSON}`;
+     }
+ 
+     if (this.cause) {
+       result += `\nCaused by: ${this.cause instanceof AppError ? this.cause.format() : this.cause.message}`;
+     }
+ 
+     return result;
+   }
+ }
+ 
+ /**
+  * Validation error
+  */
+ export class ValidationError extends AppError {
+   public readonly validationErrors?: Record<string, string[]>;
+   public readonly field?: string;
+ 
+   constructor(
+     message: string, 
+     options: ErrorOptions & { 
+       validationErrors?: Record<string, string[]>;
+       field?: string;
+     } = {}
+   ) {
+     super(message, {
+       code: options.code ?? 'VALIDATION_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: options.recoverable ?? true,
+     });
+     this.validationErrors = options.validationErrors;
+     this.field = options.field;
+   }
+ }
+ 
+ /**
+  * File system error
+  */
+ export class FileSystemError extends AppError {
+   public readonly path?: string;
+ 
+   constructor(
+     message: string, 
+     options: ErrorOptions & { path?: string } = {}
+   ) {
+     super(message, {
+       code: options.code ?? 'FILE_SYSTEM_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: options.recoverable ?? true,
+     });
+     this.path = options.path;
+   }
+ }
+ 
+ /**
+  * Network error
+  */
+ export class NetworkError extends AppError {
+   constructor(message: string, options: ErrorOptions = {}) {
+     super(message, {
+       code: options.code ?? 'NETWORK_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: options.recoverable ?? true,
+     });
    }
  }
  
  /**
-  * API-related errors
+  * API error
   */
  export class APIError extends AppError {
-   status?: number | undefined;
-   rateLimitInfo?:
-     | {
-         retryAfter?: number | undefined;
-         limit?: number | undefined;
-         remaining?: number | undefined;
-         reset?: Date | undefined;
-       }
-     | undefined;
+   public readonly statusCode?: number;
+   public readonly retryAfter?: number;
+   public readonly rateLimitInfo?: {
+     limit?: number;
+     remaining?: number;
+     reset?: Date;
+   };
  
    constructor(
-     message: string,
-     code = 'API_ERROR',
-     recoverable = true,
-     status?: number,
-     rateLimitInfo?: {
-       retryAfter?: number | undefined;
-       limit?: number | undefined;
-       remaining?: number | undefined;
-       reset?: Date | undefined;
-     }
-   ) {
-     super(message, code, recoverable);
-     this.status = status;
-     this.rateLimitInfo = rateLimitInfo;
+     message: string, 
+     options: ErrorOptions & { 
+       statusCode?: number;
+       retryAfter?: number;
+       rateLimitInfo?: {
+         limit?: number;
+         remaining?: number;
+         reset?: Date;
+       };
+     } = {}
+   ) {
+     // API errors are recoverable if they're rate limit (429) or non-5xx
+     const isRecoverable = options.statusCode 
+       ? options.statusCode === 429 || options.statusCode < 500 
+       : options.recoverable ?? false;
+ 
+     super(message, {
+       code: options.code ?? 'API_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: isRecoverable,
+     });
+     
+     this.statusCode = options.statusCode;
+     this.retryAfter = options.retryAfter;
+     this.rateLimitInfo = options.rateLimitInfo;
    }
  
     */
    isRateLimit(): boolean {
-     return this.status === 429 || this.code === 'RATE_LIMIT_EXCEEDED';
+     return this.statusCode === 429 || this.code === 'RATE_LIMIT_EXCEEDED';
    }
  
     */
    isServerError(): boolean {
-     return this.status !== undefined && this.status >= 500 && this.status < 600;
+     return this.statusCode !== undefined && this.statusCode >= 500 && this.statusCode < 600;
+   }
+ }
+ 
+ /**
+  * API key error
+  */
+ export class ApiKeyError extends AppError {
+   constructor(message: string, options: ErrorOptions = {}) {
+     super(message, {
+       code: options.code ?? 'API_KEY_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: options.recoverable ?? true,
+     });
+   }
+ }
+ 
+ /**
+  * Configuration error
+  */
+ export class ConfigurationError extends AppError {
+   constructor(message: string, options: ErrorOptions = {}) {
+     super(message, {
+       code: options.code ?? 'CONFIGURATION_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: options.recoverable ?? true,
+     });
+   }
+ }
+ 
+ /**
+  * Markdown processing error
+  */
+ export class MarkdownError extends AppError {
+   public readonly filePath?: string;
+ 
+   constructor(
+     message: string, 
+     options: ErrorOptions & { filePath?: string } = {}
+   ) {
+     super(message, {
+       code: options.code ?? 'MARKDOWN_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: options.recoverable ?? true,
+     });
+     this.filePath = options.filePath;
    }
  }
   */
  export class TaggingError extends AppError {
-   documentId?: string | undefined;
+   public readonly documentId?: string;
  
-   constructor(message: string, code = 'TAGGING_ERROR', recoverable = false, documentId?: string) {
-     super(message, code, recoverable);
-     this.documentId = documentId;
+   constructor(
+     message: string, 
+     options: ErrorOptions & { documentId?: string } = {}
+   ) {
+     super(message, {
+       code: options.code ?? 'TAGGING_ERROR',
+       cause: options.cause,
+       context: options.context,
+       recoverable: options.recoverable ?? true,
+     });
+     this.documentId = options.documentId;
+   }
+ }
+ 
+ /**
+  * Cost limit error
+  */
+ export class CostLimitError extends AppError {
+   constructor(
+     message: string,
+     options: ErrorOptions & {
+       cost: number;
+       limit: number;
+     }
+   ) {
+     super(message, {
+       ...options,
+       code: options.code ?? 'COST_LIMIT_ERROR',
+       context: {
+         cost: options.cost,
+         limit: options.limit,
+         ...(options.context ?? {}),
+       },
+     });
    }
  }
  
  /**
-  * Markdown processing errors
-  */
- export class MarkdownError extends AppError {
-   filePath?: string | undefined;
- 
-   constructor(message: string, code = 'MARKDOWN_ERROR', recoverable = true, filePath?: string) {
-     super(message, code, recoverable);
-     this.filePath = filePath;
+  * Operation result
+  */
+ export class Result<T, E extends Error = Error> {
+   private readonly value: T | null;
+   private readonly error: E | null;
+ 
+   private constructor(value: T | null, error: E | null) {
+     this.value = value;
+     this.error = error;
+   }
+ 
+   /**
+    * Create a successful result
+    */
+   static ok<U>(value: U): Result<U> {
+     return new Result<U, Error>(value, null);
+   }
+ 
+   /**
+    * Create a failed result
+    */
+   static fail<U, F extends Error = Error>(error: F): Result<U, F> {
+     return new Result<U, F>(null, error);
+   }
+ 
+   /**
+    * Check if the result is successful
+    */
+   isOk(): boolean {
+     return this.error === null;
+   }
+ 
+   /**
+    * Check if the result is failed
+    */
+   isFail(): boolean {
+     return this.error !== null;
+   }
+ 
+   /**
+    * Get the value
+    */
+   getValue(): T {
+     if (this.error !== null) {
+       throw this.error;
+     }
+     return this.value as T;
+   }
+ 
+   /**
+    * Get the error
+    */
+   getError(): E {
+     if (this.error === null) {
+       throw new Error('Cannot get error from successful result');
+     }
+     return this.error;
+   }
+ 
+   /**
+    * Map the value
+    */
+   map<U>(fn: (value: T) => U): Result<U, E> {
+     if (this.error !== null) {
+       return Result.fail<U, E>(this.error);
+     }
+     try {
+       return Result.ok<U>(fn(this.value as T));
+     } catch (error) {
+       const err = error instanceof Error ? error : new Error(String(error));
+       return Result.fail<U, E>(err as unknown as E);
+     }
+   }
+ 
+   /**
+    * Map the error
+    */
+   mapError<F extends Error>(fn: (error: E) => F): Result<T, F> {
+     if (this.error === null) {
+       return new Result<T, F>(this.value, null);
+     }
+     return Result.fail<T, F>(fn(this.error));
+   }
+ 
+   /**
+    * Get the value or a default
+    */
+   getValueOrDefault(defaultValue: T): T {
+     if (this.error !== null) {
+       return defaultValue;
+     }
+     return this.value as T;
+   }
+ 
+   /**
+    * Chain operations
+    */
+   andThen<U>(fn: (value: T) => Result<U, E>): Result<U, E> {
+     if (this.error !== null) {
+       return Result.fail<U, E>(this.error);
+     }
+     return fn(this.value as T);
    }
  }
  
  /**
-  * Configuration errors
+  * Alternative Result interface for functions that don't throw
+  */
+ export interface ResultObject<T = undefined> {
+   success: boolean;
+   data?: T;
+   error?: {
+     code: string;
+     message: string;
+     recoverable: boolean;
+     [key: string]: unknown;
+   };
+ }
+ 
+ /**
+  * Create a success result object
   */
- export class ConfigError extends AppError {
-   constructor(message: string, code = 'CONFIG_ERROR', recoverable = false) {
-     super(message, code, recoverable);
+ export function success<T>(data?: T): ResultObject<T> {
+   return { success: true, data };
+ }
+ 
+ /**
+  * Create a failure result object
+  */
+ export function failure(error: AppError | Error): ResultObject<never> {
+   if (error instanceof AppError) {
+     const errorObj: Record<string, unknown> = {
+       code: error.code,
+       message: error.message,
+       recoverable: error.recoverable,
+     };
+ 
+     // Add additional properties for specific error types
+     if (error instanceof APIError) {
+       if (error.statusCode !== undefined) errorObj['statusCode'] = error.statusCode;
+       if (error.retryAfter !== undefined) errorObj['retryAfter'] = error.retryAfter;
+     }
+ 
+     if (error instanceof FileSystemError && error.path !== undefined) {
+       errorObj['path'] = error.path;
+     }
+ 
+     return {
+       success: false,
+       error: errorObj as Required<ResultObject<never>>['error'],
+     };
+   }
+ 
+   return {
+     success: false,
+     error: {
+       code: 'UNKNOWN_ERROR',
+       message: error.message || String(error),
+       recoverable: false,
+     },
+   };
+ }
+ 
+ /**
+  * Try an async operation and convert to a Result
+  */
+ export async function tryCatch<T>(fn: () => Promise<T>): Promise<Result<T>> {
+   try {
+     const value = await fn();
+     return Result.ok(value);
+   } catch (error) {
+     return Result.fail(error instanceof Error ? error : new Error(String(error)));
    }
  }
  
  /**
-  * Validation errors
-  */
- export class ValidationError extends AppError {
-   validationErrors: Record<string, string[]>;
- 
-   constructor(
-     message: string,
-     validationErrors: Record<string, string[]>,
-     code = 'VALIDATION_ERROR',
-     recoverable = true
-   ) {
-     super(message, code, recoverable);
-     this.validationErrors = validationErrors;
+  * Wrap an async operation that can fail with an error or a null value
+  */
+ export async function tryOrNull<T>(fn: () => Promise<T>): Promise<T | null> {
+   try {
+     return await fn();
+   } catch {
+     return null;
    }
  }
  
  /**
-  * Convert unknown errors to AppError
-  *
-  * @param error Any error object
-  * @returns A properly typed AppError
+  * Convert errors to AppError type
   */
- export function normalizeError(error: unknown): AppError {
+ export function toAppError(error: unknown, defaultCode = 'UNKNOWN_ERROR'): AppError {
    if (error instanceof AppError) {
      return error;
    }
  
    if (error instanceof Error) {
-     return new AppError(error.message, 'UNKNOWN_ERROR', false);
+     return new AppError(error.message, { code: defaultCode, cause: error });
    }
  
-   // Handle string errors
-   if (typeof error === 'string') {
-     return new AppError(error, 'STRING_ERROR', false);
-   }
- 
-   // Handle other types
-   return new AppError(`Unknown error: ${JSON.stringify(error)}`, 'UNKNOWN_ERROR', false);
+   return new AppError(String(error), { code: defaultCode });
+ }
+ 
+ /**
+  * Normalize any error into an AppError
+  */
+ export function normalizeError(error: unknown): AppError {
+   return toAppError(error);
+ }
+ 
+ /**
+  * Utility to handle API retries with exponential backoff
+  */
+ export async function withRetry<T>(
+   fn: () => Promise<T>,
+   options: {
+     maxRetries?: number;
+     initialDelay?: number;
+     maxDelay?: number;
+     factor?: number;
+     retryableStatusCodes?: number[];
+   } = {}
+ ): Promise<T> {
+   const {
+     maxRetries = 3,
+     initialDelay = 1000,
+     maxDelay = 60000,
+     factor = 2,
+     retryableStatusCodes = [429, 500, 502, 503, 504],
+   } = options;
+ 
+   let attempt = 0;
+   let lastError: Error;
+ 
+   while (attempt <= maxRetries) {
+     try {
+       return await fn();
+     } catch (error) {
+       lastError = error instanceof Error ? error : new Error(String(error));
+       attempt++;
+ 
+       // Check if we should retry
+       const shouldRetry =
+         attempt <= maxRetries &&
+         (error instanceof APIError
+           ? (retryableStatusCodes.includes(error.statusCode || 0) || error.recoverable)
+           : isRetryableError(error));
+ 
+       if (!shouldRetry) {
+         throw lastError;
+       }
+ 
+       // Calculate delay with exponential backoff
+       let delay = Math.min(initialDelay * Math.pow(factor, attempt - 1), maxDelay);
+ 
+       // Use retry-after header if available
+       if (error instanceof APIError && error.retryAfter) {
+         delay = Math.min(error.retryAfter * 1000, maxDelay);
+       }
+ 
+       // Wait before retrying
+       await new Promise((resolve) => setTimeout(resolve, delay));
+     }
+   }
+ 
+   throw lastError!;
+ }
+ 
+ /**
+  * Check if an error is retryable
+  */
+ function isRetryableError(error: unknown): boolean {
+   if (error instanceof APIError) {
+     return error.isRateLimit() || error.isServerError();
+   }
+   
+   if (error instanceof NetworkError) {
+     return true;
+   }
+   
+   if (error instanceof Error) {
+     // Network-related error codes
+     const networkErrorCodes = ['ETIMEDOUT', 'ECONNRESET', 'ENOTFOUND', 'EAI_AGAIN'];
+     return networkErrorCodes.some(code => (error as any).code === code) || 
+            error.message.includes('ECONNREFUSED');
+   }
+   
+   return false;
  }
  
    // API errors
    API_ERROR: 'API_ERROR',
+   API_KEY_ERROR: 'API_KEY_ERROR',
    RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
    NETWORK_ERROR: 'NETWORK_ERROR',
    TIMEOUT_ERROR: 'TIMEOUT_ERROR',
    AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
    SERVER_ERROR: 'SERVER_ERROR',
+ 
+   // File system errors
+   FILE_SYSTEM_ERROR: 'FILE_SYSTEM_ERROR',
+   FILE_NOT_FOUND: 'FILE_NOT_FOUND',
+   INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',
  
    // Tagging errors
  
    // Configuration errors
-   CONFIG_ERROR: 'CONFIG_ERROR',
+   CONFIGURATION_ERROR: 'CONFIGURATION_ERROR',
    MISSING_API_KEY: 'MISSING_API_KEY',
    INVALID_MODEL: 'INVALID_MODEL',
+   COST_LIMIT_ERROR: 'COST_LIMIT_ERROR',
  
    // Validation errors
```

---

Now I'll create a comprehensive test file for our new consolidated error handling system:

---

```diff
- 
+ import { describe, expect, it, vi } from 'vitest';
+ 
+ import {
+   APIError,
+   ApiKeyError,
+   AppError,
+   ConfigurationError,
+   CostLimitError,
+   ErrorCodes,
+   FileSystemError,
+   MarkdownError,
+   NetworkError,
+   Result,
+   TaggingError,
+   ValidationError,
+   failure,
+   normalizeError,
+   success,
+   toAppError,
+   tryCatch,
+   tryOrNull,
+   withRetry,
+ } from './errors';
+ 
+ describe('Error Handling System', () => {
+   describe('Custom Error Classes', () => {
+     it('should create AppError with correct properties', () => {
+       const error = new AppError('Test error', { code: 'TEST_CODE', recoverable: true });
+       expect(error.message).toBe('Test error');
+       expect(error.code).toBe('TEST_CODE');
+       expect(error.recoverable).toBe(true);
+       expect(error instanceof Error).toBe(true);
+     });
+ 
+     it('should create ValidationError with correct properties', () => {
+       const validationErrors = { name: ['is required'] };
+       const error = new ValidationError('Validation failed', { 
+         validationErrors,
+         field: 'name' 
+       });
+       expect(error.message).toBe('Validation failed');
+       expect(error.code).toBe('VALIDATION_ERROR');
+       expect(error.validationErrors).toBe(validationErrors);
+       expect(error.field).toBe('name');
+       expect(error.recoverable).toBe(true);
+       expect(error instanceof AppError).toBe(true);
+     });
+ 
+     it('should create APIError with correct properties', () => {
+       const error = new APIError('Rate limit exceeded', { 
+         statusCode: 429, 
+         retryAfter: 30,
+         code: 'RATE_LIMIT_EXCEEDED'
+       });
+       expect(error.message).toBe('Rate limit exceeded');
+       expect(error.code).toBe('RATE_LIMIT_EXCEEDED');
+       expect(error.statusCode).toBe(429);
+       expect(error.retryAfter).toBe(30);
+       expect(error.recoverable).toBe(true);
+       expect(error.isRateLimit()).toBe(true);
+       expect(error.isServerError()).toBe(false);
+       expect(error instanceof AppError).toBe(true);
+     });
+ 
+     it('should create FileSystemError with correct properties', () => {
+       const error = new FileSystemError('File not found', { path: '/path/to/file' });
+       expect(error.message).toBe('File not found');
+       expect(error.code).toBe('FILE_SYSTEM_ERROR');
+       expect(error.path).toBe('/path/to/file');
+       expect(error.recoverable).toBe(true);
+       expect(error instanceof AppError).toBe(true);
+     });
+ 
+     it('should create CostLimitError with correct properties', () => {
+       const error = new CostLimitError('Cost limit exceeded', { 
+         cost: 15, 
+         limit: 10 
+       });
+       expect(error.message).toBe('Cost limit exceeded');
+       expect(error.code).toBe('COST_LIMIT_ERROR');
+       expect(error.context).toEqual({ cost: 15, limit: 10 });
+       expect(error instanceof AppError).toBe(true);
+     });
+ 
+     it('should format error with context and cause', () => {
+       const cause = new Error('Original error');
+       const error = new AppError('Wrapper error', { 
+         code: 'WRAPPER_ERROR', 
+         cause, 
+         context: { foo: 'bar' } 
+       });
+       
+       const formatted = error.format();
+       expect(formatted).toContain('Wrapper error');
+       expect(formatted).toContain('WRAPPER_ERROR');
+       expect(formatted).toContain('Original error');
+       expect(formatted).toContain('foo');
+       expect(formatted).toContain('bar');
+     });
+   });
+ 
+   describe('Result Pattern', () => {
+     it('should create a successful result', () => {
+       const result = Result.ok('success');
+       expect(result.isOk()).toBe(true);
+       expect(result.isFail()).toBe(false);
+       expect(result.getValue()).toBe('success');
+       expect(() => result.getError()).toThrow();
+     });
+ 
+     it('should create a failed result', () => {
+       const error = new Error('Failed');
+       const result = Result.fail(error);
+       expect(result.isOk()).toBe(false);
+       expect(result.isFail()).toBe(true);
+       expect(() => result.getValue()).toThrow(error);
+       expect(result.getError()).toBe(error);
+     });
+ 
+     it('should map successful result', () => {
+       const result = Result.ok(5);
+       const mapped = result.map(x => x * 2);
+       expect(mapped.isOk()).toBe(true);
+       expect(mapped.getValue()).toBe(10);
+     });
+ 
+     it('should chain operations with andThen', () => {
+       const result = Result.ok(5)
+         .andThen(x => Result.ok(x * 2))
+         .andThen(x => Result.ok(x + 1));
+       
+       expect(result.isOk()).toBe(true);
+       expect(result.getValue()).toBe(11);
+     });
+ 
+     it('should short-circuit on failure with andThen', () => {
+       const error = new Error('Failed');
+       const result = Result.ok(5)
+         .andThen(() => Result.fail(error))
+         .andThen(x => Result.ok(x + 1));
+       
+       expect(result.isFail()).toBe(true);
+       expect(result.getError()).toBe(error);
+     });
+ 
+     it('should support getValueOrDefault', () => {
+       const success = Result.ok(5);
+       const failure = Result.fail(new Error('Failed'));
+       
+       expect(success.getValueOrDefault(10)).toBe(5);
+       expect(failure.getValueOrDefault(10)).toBe(10);
+     });
+   });
+ 
+   describe('Result Object Pattern', () => {
+     it('should create a success result object', () => {
+       const result = success({ id: 1, name: 'test' });
+       expect(result.success).toBe(true);
+       expect(result.data).toEqual({ id: 1, name: 'test' });
+       expect(result.error).toBeUndefined();
+     });
+ 
+     it('should create a failure result from AppError', () => {
+       const error = new APIError('API error', { code: 'TEST_ERROR', statusCode: 500 });
+       const result = failure(error);
+       expect(result.success).toBe(false);
+       expect(result.data).toBeUndefined();
+       expect(result.error).toBeDefined();
+       expect(result.error?.code).toBe('TEST_ERROR');
+       expect(result.error?.message).toBe('API error');
+       expect(result.error?.recoverable).toBe(false);
+       expect(result.error?.statusCode).toBe(500);
+     });
+ 
+     it('should create a failure result from standard Error', () => {
+       const error = new Error('Standard error');
+       const result = failure(error);
+       expect(result.success).toBe(false);
+       expect(result.data).toBeUndefined();
+       expect(result.error).toBeDefined();
+       expect(result.error?.code).toBe('UNKNOWN_ERROR');
+       expect(result.error?.message).toBe('Standard error');
+       expect(result.error?.recoverable).toBe(false);
+     });
+   });
+ 
+   describe('Utility Functions', () => {
+     it('should convert unknown errors to AppError with toAppError', () => {
+       const stringError = toAppError('String error');
+       expect(stringError instanceof AppError).toBe(true);
+       expect(stringError.message).toBe('String error');
+       expect(stringError.code).toBe('UNKNOWN_ERROR');
+ 
+       const originalError = new Error('Original error');
+       const wrappedError = toAppError(originalError, 'CUSTOM_CODE');
+       expect(wrappedError instanceof AppError).toBe(true);
+       expect(wrappedError.message).toBe('Original error');
+       expect(wrappedError.code).toBe('CUSTOM_CODE');
+       expect(wrappedError.cause).toBe(originalError);
+ 
+       const appError = new ValidationError('Already an AppError');
+       const passedThrough = toAppError(appError);
+       expect(passedThrough).toBe(appError);
+     });
+ 
+     it('should wrap async functions with tryCatch', async () => {
+       const successFn = async () => 'success';
+       const failFn = async () => { throw new Error('Failed'); };
+ 
+       const successResult = await tryCatch(successFn);
+       expect(successResult.isOk()).toBe(true);
+       expect(successResult.getValue()).toBe('success');
+ 
+       const failResult = await tryCatch(failFn);
+       expect(failResult.isFail()).toBe(true);
+       expect(failResult.getError().message).toBe('Failed');
+     });
+ 
+     it('should wrap async functions with tryOrNull', async () => {
+       const successFn = async () => 'success';
+       const failFn = async () => { throw new Error('Failed'); };
+ 
+       const successResult = await tryOrNull(successFn);
+       expect(successResult).toBe('success');
+ 
+       const failResult = await tryOrNull(failFn);
+       expect(failResult).toBeNull();
+     });
+   });
+ 
+   describe('Retry Mechanism', () => {
+     it('should return result on first successful attempt', async () => {
+       const fn = vi.fn().mockResolvedValue('success');
+       const result = await withRetry(fn);
+ 
+       expect(result).toBe('success');
+       expect(fn).toHaveBeenCalledTimes(1);
+     });
+ 
+     it('should retry on API errors that are retryable', async () => {
+       const fn = vi
+         .fn()
+         .mockRejectedValueOnce(new APIError('Rate limit', { statusCode: 429 }))
+         .mockResolvedValueOnce('success');
+ 
+       const result = await withRetry(fn, { maxRetries: 3 });
+ 
+       expect(result).toBe('success');
+       expect(fn).toHaveBeenCalledTimes(2);
+     });
+ 
+     it('should stop retrying after max attempts', async () => {
+       const apiError = new APIError('Rate limit', { statusCode: 429 });
+       const fn = vi.fn().mockRejectedValue(apiError);
+ 
+       await expect(withRetry(fn, { maxRetries: 2 })).rejects.toThrow(apiError);
+       expect(fn).toHaveBeenCalledTimes(3); // Initial + 2 retries
+     });
+ 
+     it('should not retry on non-retryable errors', async () => {
+       const nonRetryableError = new ValidationError('Invalid input');
+       const fn = vi.fn().mockRejectedValue(nonRetryableError);
+ 
+       await expect(withRetry(fn)).rejects.toThrow(nonRetryableError);
+       expect(fn).toHaveBeenCalledTimes(1); // No retries
+     });
+ 
+     it('should retry on network errors', async () => {
+       const networkError = new NetworkError('Connection failed');
+       const fn = vi
+         .fn()
+         .mockRejectedValueOnce(networkError)
+         .mockResolvedValueOnce('success');
+ 
+       const result = await withRetry(fn, { maxRetries: 3 });
+ 
+       expect(result).toBe('success');
+       expect(fn).toHaveBeenCalledTimes(2);
+     });
+   });
+ }); 
```

---

Next, let's create a CLI-specific index file to re-export the consolidated error system:

---

```diff
  /**
-  * Error handling utilities for CLI
-  */
- 
- /**
-  * Base error options
-  */
- export interface ErrorOptions {
-   code?: string;
-   cause?: Error;
-   context?: Record<string, unknown>;
-   recoverable?: boolean;
- }
- 
- /**
-  * Application error
-  */
- /* eslint-disable @typescript-eslint/no-unnecessary-condition */
- // @ts-expect-error TypeScript complains about missing override for 'name', but we're setting it in the constructor
- export class AppError extends Error {
-   public readonly code: string;
-   public readonly cause?: Error;
-   public readonly context?: Record<string, unknown>;
-   public readonly recoverable: boolean;
-   override readonly name: string;
- 
-   constructor(message: string, options: ErrorOptions = {}) {
-     super(message);
-     this.name = this.constructor.name;
-     this.code = options.code ?? 'UNKNOWN_ERROR';
-     this.cause = options.cause;
-     this.context = options.context;
-     this.recoverable = options.recoverable ?? true;
- 
-     // Maintain proper stack trace
-     if (Error.captureStackTrace) {
-       Error.captureStackTrace(this, this.constructor);
-     }
-   }
- 
-   /**
-    * Format the error for display
-    */
-   public format(): string {
-     let result = `${this.name} [${this.code}]: ${this.message}`;
- 
-     // Add context if available
-     const contextJSON = this.context ? JSON.stringify(this.context, null, 2) : '';
-     if (contextJSON !== '{}' && contextJSON !== '') {
-       result += `\nContext: ${contextJSON}`;
-     }
- 
-     if (this.cause) {
-       result += `\nCaused by: ${this.cause instanceof AppError ? this.cause.format() : this.cause.message}`;
-     }
- 
-     return result;
-   }
- }
- /* eslint-enable @typescript-eslint/no-unnecessary-condition */
- 
- /**
-  * Configuration error
-  */
- export class ConfigurationError extends AppError {
-   constructor(message: string, options: ErrorOptions = {}) {
-     super(message, {
-       code: options.code ?? 'CONFIGURATION_ERROR',
-       cause: options.cause,
-       context: options.context,
-       recoverable: options.recoverable ?? true,
-     });
-   }
- }
- 
- /**
-  * API error
-  */
- export class APIError extends AppError {
-   constructor(message: string, options: ErrorOptions = {}) {
-     super(message, {
-       code: options.code ?? 'API_ERROR',
-       cause: options.cause,
-       context: options.context,
-       recoverable: options.recoverable ?? false,
-     });
-   }
- }
- 
- /**
-  * File system error
-  */
- export class FileSystemError extends AppError {
-   constructor(message: string, options: ErrorOptions = {}) {
-     super(message, {
-       code: options.code ?? 'FILE_SYSTEM_ERROR',
-       cause: options.cause,
-       context: options.context,
-       recoverable: options.recoverable ?? true,
-     });
-   }
- }
- 
- /**
-  * Validation error
-  */
- export class ValidationError extends AppError {
-   constructor(message: string, options: ErrorOptions = {}) {
-     super(message, {
-       code: options.code ?? 'VALIDATION_ERROR',
-       cause: options.cause,
-       context: options.context,
-       recoverable: options.recoverable ?? true,
-     });
-   }
- }
- 
- /**
-  * Cost limit error
-  */
- export class CostLimitError extends AppError {
-   constructor(
-     message: string,
-     options: {
-       code?: string;
-       cost: number;
-       limit: number;
-       cause?: Error | undefined;
-       context?: Record<string, unknown>;
-     }
-   ) {
-     super(message, {
-       ...options,
-       code: options.code ?? 'ERR_COST_LIMIT',
-       context: {
-         cost: options.cost,
-         limit: options.limit,
-         ...(options.context ?? {}),
-       },
-     });
-   }
- }
- 
- /**
-  * Network error
-  */
- export class NetworkError extends AppError {
-   constructor(message: string, options: ErrorOptions = {}) {
-     super(message, {
-       code: options.code ?? 'NETWORK_ERROR',
-       cause: options.cause,
-       context: options.context,
-       recoverable: options.recoverable ?? true,
-     });
-   }
- }
- 
- /**
-  * Operation result
-  */
- export class Result<T, E extends Error = Error> {
-   private readonly value: T | null;
-   private readonly error: E | null;
- 
-   private constructor(value: T | null, error: E | null) {
-     this.value = value;
-     this.error = error;
-   }
- 
-   /**
-    * Create a successful result
-    */
-   static ok<U>(value: U): Result<U> {
-     return new Result<U, Error>(value, null);
-   }
- 
-   /**
-    * Create a failed result
-    */
-   static fail<U, F extends Error = Error>(error: F): Result<U, F> {
-     return new Result<U, F>(null, error);
-   }
- 
-   /**
-    * Check if the result is successful
-    */
-   isOk(): boolean {
-     return this.error === null;
-   }
- 
-   /**
-    * Check if the result is failed
-    */
-   isFail(): boolean {
-     return this.error !== null;
-   }
- 
-   /**
-    * Get the value
-    */
-   getValue(): T {
-     if (this.error !== null) {
-       throw this.error;
-     }
-     return this.value as T;
-   }
- 
-   /**
-    * Get the error
-    */
-   getError(): E {
-     if (this.error === null) {
-       throw new Error('Cannot get error from successful result');
-     }
-     return this.error;
-   }
- 
-   /**
-    * Map the value
-    */
-   map<U>(fn: (value: T) => U): Result<U, E> {
-     if (this.error !== null) {
-       return Result.fail<U, E>(this.error);
-     }
-     try {
-       return Result.ok<U>(fn(this.value as T)) as unknown as Result<U, E>;
-     } catch (error) {
-       const err = error instanceof Error ? error : new Error(String(error));
-       return Result.fail<U, E>(err as unknown as E);
-     }
-   }
- 
-   /**
-    * Map the error
-    */
-   mapError<F extends Error>(fn: (error: E) => F): Result<T, F> {
-     if (this.error === null) {
-       throw new Error('Cannot map error from successful result');
-     }
-     return Result.fail<T, F>(fn(this.error));
-   }
- 
-   /**
-    * Get the value or a default
-    */
-   getValueOrDefault(defaultValue: T): T {
-     if (this.error) {
-       return defaultValue;
-     }
-     return this.value as T;
-   }
- 
-   /**
-    * Chain operations
-    */
-   andThen<U>(fn: (value: T) => Result<U, E>): Result<U, E> {
-     if (this.error !== null) {
-       return Result.fail<U, E>(this.error);
-     }
-     return fn(this.value as T);
-   }
- }
- 
- /**
-  * Try an async operation and convert to a Result
-  */
- export async function tryCatch<T>(fn: () => Promise<T>): Promise<Result<T>> {
-   try {
-     const value = await fn();
-     return Result.ok(value);
-   } catch (error) {
-     return Result.fail(error instanceof Error ? error : new Error(String(error)));
-   }
- }
- 
- /**
-  * Wrap an async operation that can fail with an error or a null value
-  */
- export async function tryOrNull<T>(fn: () => Promise<T>): Promise<T | null> {
-   try {
-     return await fn();
-   } catch {
-     return null;
-   }
- }
- 
- /**
-  * Convert errors to AppError type
-  */
- export function toAppError(error: unknown, defaultCode = 'UNKNOWN_ERROR'): AppError {
-   if (error instanceof AppError) {
-     return error;
-   }
- 
-   if (error instanceof Error) {
-     return new AppError(error.message, { code: defaultCode, cause: error });
-   }
- 
-   return new AppError(String(error), { code: defaultCode });
- }
+  * Re-export error handling utilities from core package
+  */
+ 
+ export {
+   AppError,
+   ValidationError,
+   FileSystemError,
+   NetworkError,
+   APIError,
+   ApiKeyError,
+   ConfigurationError,
+   MarkdownError,
+   TaggingError,
+   CostLimitError,
+   Result,
+   ResultObject,
+   success,
+   failure,
+   tryCatch,
+   tryOrNull,
+   toAppError,
+   normalizeError,
+   withRetry,
+   ErrorCodes,
+   type ErrorCode,
+   type ErrorOptions,
+ } from '@obsidian-magic/core/src/errors';
  
```

---

Let's fix that linter error:

---

```diff
    withRetry,
    ErrorCodes,
-   type ErrorCode,
-   type ErrorOptions,
  } from '@obsidian-magic/core/src/errors';
+ 
+ export type { ErrorCode, ErrorOptions } from '@obsidian-magic/core/src/errors';
  
```

---

Now let's do the same for the Obsidian plugin:

---

```diff
  /**
-  * Comprehensive error handling system for Obsidian Magic
-  */
- 
- /**
-  * Base error class for the plugin
-  */
- export class AppError extends Error {
-   code: string;
-   recoverable: boolean;
- 
-   constructor(message: string, code: string, recoverable = false) {
-     super(message);
-     this.name = this.constructor.name;
-     this.code = code;
-     this.recoverable = recoverable;
-   }
- }
- 
- /**
-  * Error thrown when there's an issue with API key or authentication
-  */
- export class ApiKeyError extends AppError {
-   constructor(message: string, code = 'API_KEY_ERROR') {
-     super(message, code, true);
-   }
- }
- 
- /**
-  * Error thrown for OpenAI API issues
-  */
- export class ApiError extends AppError {
-   statusCode: number | undefined;
-   retryAfter: number | undefined;
- 
-   constructor(message: string, code = 'API_ERROR', statusCode?: number, retryAfter?: number) {
-     const recoverable = statusCode ? statusCode < 500 || statusCode === 429 : false;
-     super(message, code, recoverable);
-     this.statusCode = statusCode;
-     this.retryAfter = retryAfter;
-   }
- }
- 
- /**
-  * Error thrown for file system operations
-  */
- export class FileSystemError extends AppError {
-   path: string | undefined;
- 
-   constructor(message: string, path?: string, code = 'FILE_SYSTEM_ERROR') {
-     super(message, code, false);
-     this.path = path;
-   }
- }
- 
- /**
-  * Error thrown for tag processing issues
-  */
- export class TaggingError extends AppError {
-   constructor(message: string, code = 'TAGGING_ERROR') {
-     super(message, code, true);
-   }
- }
- 
- /**
-  * Generic result type for operations that can fail
-  */
- export interface Result<T = undefined> {
-   success: boolean;
-   data?: T | undefined;
-   error?:
-     | {
-         code: string;
-         message: string;
-         recoverable: boolean;
-         [key: string]: unknown;
-       }
-     | undefined;
- }
- 
- /**
-  * Create a success result
-  */
- export function success<T>(data?: T): Result<T> {
-   return { success: true, data };
- }
- 
- /**
-  * Create a failure result
-  */
- export function failure(error: AppError | Error): Result<never> {
-   if (error instanceof AppError) {
-     const errorObj: Record<string, unknown> = {
-       code: error.code,
-       message: error.message,
-       recoverable: error.recoverable,
-     };
- 
-     // Add additional properties for specific error types
-     if (error instanceof ApiError) {
-       if (error.statusCode !== undefined) errorObj['statusCode'] = error.statusCode;
-       if (error.retryAfter !== undefined) errorObj['retryAfter'] = error.retryAfter;
-     }
- 
-     if (error instanceof FileSystemError && error.path !== undefined) {
-       errorObj['path'] = error.path;
-     }
- 
-     return {
-       success: false,
-       error: errorObj as Required<Result<never>>['error'],
-     };
-   }
- 
-   return {
-     success: false,
-     error: {
-       code: 'UNKNOWN_ERROR',
-       message: error.message || String(error),
-       recoverable: false,
-     },
-   };
- }
- 
- /**
-  * Utility to handle API retries with exponential backoff
-  */
- export async function withRetry<T>(
-   fn: () => Promise<T>,
-   options: {
-     maxRetries?: number;
-     initialDelay?: number;
-     maxDelay?: number;
-     factor?: number;
-     retryableStatusCodes?: number[];
-   } = {}
- ): Promise<T> {
-   const {
-     maxRetries = 3,
-     initialDelay = 1000,
-     maxDelay = 60000,
-     factor = 2,
-     retryableStatusCodes = [429, 500, 502, 503, 504],
-   } = options;
- 
-   let attempt = 0;
-   let lastError: Error;
- 
-   while (attempt <= maxRetries) {
-     try {
-       return await fn();
-     } catch (error) {
-       lastError = error instanceof Error ? error : new Error(String(error));
-       attempt++;
- 
-       // Check if we should retry
-       const shouldRetry =
-         attempt <= maxRetries &&
-         error instanceof ApiError &&
-         (retryableStatusCodes.includes(error.statusCode || 0) || error.recoverable);
- 
-       if (!shouldRetry) {
-         throw lastError;
-       }
- 
-       // Calculate delay with exponential backoff
-       let delay = Math.min(initialDelay * Math.pow(factor, attempt - 1), maxDelay);
- 
-       // Use retry-after header if available
-       if (error instanceof ApiError && error.retryAfter) {
-         delay = Math.min(error.retryAfter * 1000, maxDelay);
-       }
- 
-       // Wait before retrying
-       await new Promise((resolve) => setTimeout(resolve, delay));
-     }
-   }
- 
-   throw lastError!;
- }
+  * Re-export error handling utilities from core package
+  */
+ 
+ export {
+   AppError,
+   ValidationError,
+   FileSystemError,
+   NetworkError,
+   APIError as ApiError,
+   ApiKeyError,
+   ConfigurationError,
+   MarkdownError,
+   TaggingError,
+   CostLimitError,
+   Result,
+   ResultObject,
+   success,
+   failure,
+   tryCatch,
+   tryOrNull,
+   toAppError,
+   normalizeError,
+   withRetry,
+   ErrorCodes,
+ } from '@obsidian-magic/core/src/errors';
+ 
+ export type { ErrorCode, ErrorOptions } from '@obsidian-magic/core/src/errors';
+ 
+ // For backward compatibility - use Result class for new code
+ export type Result<T = undefined> = ResultObject<T>;
  
```

---

_**User**_

Woah woah woah. Don't reexport just updated the path....

---

_**Assistant**_



---

Your Lordship, I apologize for the misunderstanding. I'll take a different approach and simply update the paths and imports rather than making re-export files.

Let's fix all the linter errors in the canonical errors.ts file first:

---

```diff
  
      // Maintain proper stack trace
+     // @ts-expect-error Error.captureStackTrace is not in all environments but is present in Node
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      const isRecoverable = options.statusCode
        ? options.statusCode === 429 || options.statusCode < 500
-       : (options.recoverable ?? false);
+       : options.recoverable ?? false;
  
      super(message, {
  
    let attempt = 0;
-   let lastError: Error;
+   let lastError: Error | null = null;
  
    while (attempt <= maxRetries) {
          attempt <= maxRetries &&
          (error instanceof APIError
-           ? retryableStatusCodes.includes(error.statusCode || 0) || error.recoverable
+           ? (retryableStatusCodes.includes(error.statusCode ?? 0) || error.recoverable)
            : isRetryableError(error));
  
    }
  
-   throw lastError!;
+   // This should never happen, but TypeScript needs it
+   if (lastError) {
+     throw lastError;
+   }
+   
+   // This is unreachable, but needed for TypeScript
+   throw new Error('Unexpected error in retry mechanism');
  }
  
      // Network-related error codes
      const networkErrorCodes = ['ETIMEDOUT', 'ECONNRESET', 'ENOTFOUND', 'EAI_AGAIN'];
-     return networkErrorCodes.some((code) => (error as any).code === code) || error.message.includes('ECONNREFUSED');
+     // eslint-disable-next-line @typescript-eslint/no-explicit-any
+     return networkErrorCodes.some(code => (error as any).code === code) || 
+            error.message.includes('ECONNREFUSED');
    }
    
```

---

Now let's update the documentation to reflect our consolidated error handling approach:

---

```diff
  # Error Handling
  
- The project implements comprehensive error handling strategies to ensure robustness:
+ The project implements a comprehensive error handling strategy with a consolidated approach using a shared error system in the core package.
+ 
+ ## Unified Error Architecture
+ 
+ All error handling is centralized in `packages/core/src/errors.ts`, which provides:
+ 
+ 1. A type-safe error hierarchy with specialized error classes
+ 2. Result patterns for handling operations that can fail
+ 3. Utility functions for error transformation and recovery
+ 4. Retry mechanisms with exponential backoff
+ 
+ This unified approach ensures consistency across all parts of the application.
  
  ## Custom Error Classes
  
- Create specialized error classes for different failure modes:
+ The core error system provides specialized error classes for different failure modes:
  
  ```typescript
- // Custom error classes
- class OpenAIError extends Error {
-   constructor(
-     message: string, 
-     public readonly statusCode: number,
-     public readonly errorCode: string
-   ) {
+ // Base error class with rich context support
+ export class AppError extends Error {
+   public readonly code: string;
+   public override readonly cause?: Error | undefined;
+   public readonly context?: Record<string, unknown> | undefined;
+   public readonly recoverable: boolean;
+ 
+   constructor(message: string, options: ErrorOptions = {}) {
      super(message);
-     this.name = 'OpenAIError';
-   }
- }
- 
- class ValidationError extends Error {
-   constructor(
-     message: string,
-     public readonly field?: string
-   ) {
-     super(message);
-     this.name = 'ValidationError';
-   }
- }
+     this.name = this.constructor.name;
+     this.code = options.code ?? 'UNKNOWN_ERROR';
+     this.cause = options.cause;
+     this.context = options.context;
+     this.recoverable = options.recoverable ?? false;
+     
+     // Capture stack trace
+     if (Error.captureStackTrace) {
+       Error.captureStackTrace(this, this.constructor);
+     }
+   }
+ 
+   // Format error with context for display or logging
+   public format(): string {
+     // ...implementation
+   }
+ }
+ 
+ // Specialized error classes
+ export class ValidationError extends AppError { /* ... */ }
+ export class FileSystemError extends AppError { /* ... */ }
+ export class APIError extends AppError { /* ... */ }
+ export class NetworkError extends AppError { /* ... */ }
+ export class ConfigurationError extends AppError { /* ... */ }
+ export class TaggingError extends AppError { /* ... */ }
+ export class MarkdownError extends AppError { /* ... */ }
+ export class CostLimitError extends AppError { /* ... */ }
  ```
  
  ## Result Pattern
  
- Use the Result pattern for operations that can fail:
+ The error system implements two complementary result patterns:
+ 
+ ### Class-based Result
+ 
+ For functions that throw exceptions, we provide a `Result` class that can be used for operations that might fail:
  
  ```typescript
- // Result pattern
- interface Result<T, E = Error> {
-   success: boolean;
-   value?: T;
-   error?: E;
- }
- 
- function success<T>(value: T): Result<T> {
-   return { success: true, value };
- }
- 
- function failure<E = Error>(error: E): Result<never, E> {
-   return { success: false, error };
+ // Class-based Result pattern
+ export class Result<T, E extends Error = Error> {
+   private readonly value: T | null;
+   private readonly error: E | null;
+ 
+   // Create a successful result
+   static ok<U>(value: U): Result<U> {
+     return new Result<U, Error>(value, null);
+   }
+ 
+   // Create a failed result
+   static fail<U, F extends Error = Error>(error: F): Result<U, F> {
+     return new Result<U, F>(null, error);
+   }
+ 
+   // Check if result is successful
+   isOk(): boolean { /* ... */ }
+ 
+   // Check if result has failed
+   isFail(): boolean { /* ... */ }
+ 
+   // Get the value or throw the error
+   getValue(): T { /* ... */ }
+ 
+   // Get the error or throw if successful
+   getError(): E { /* ... */ }
+ 
+   // Transform the value
+   map<U>(fn: (value: T) => U): Result<U, E> { /* ... */ }
+ 
+   // Chain operations
+   andThen<U>(fn: (value: T) => Result<U, E>): Result<U, E> { /* ... */ }
  }
  
- // Usage
+ // Usage example
  async function classifyDocument(path: string): Promise<Result<TagSet>> {
    try {
      const content = await readFile(path);
      const tags = await taggingService.classifyContent(content);
-     return success(tags);
+     return Result.ok(tags);
+   } catch (err) {
+     return Result.fail(toAppError(err));
+   }
+ }
+ 
+ // Using the result
+ const result = await classifyDocument('path/to/file.md');
+ if (result.isOk()) {
+   const tags = result.getValue();
+   // Use tags
+ } else {
+   const error = result.getError();
+   // Handle error
+ }
+ ```
+ 
+ ### Object-based Result
+ 
+ For APIs that require a simpler return structure, we provide an object-based result pattern:
+ 
+ ```typescript
+ // Object-based Result interface
+ export interface ResultObject<T = undefined> {
+   success: boolean;
+   data?: T;
+   error?: {
+     code: string;
+     message: string;
+     recoverable: boolean;
+     [key: string]: unknown;
+   };
+ }
+ 
+ // Helper functions
+ export function success<T>(data?: T): ResultObject<T> {
+   return { success: true, data };
+ }
+ 
+ export function failure(error: AppError | Error): ResultObject<never> {
+   // Implementation that converts Error to ResultObject
+ }
+ 
+ // Usage in API
+ function processFile(path: string): ResultObject<FileData> {
+   try {
+     // Process file
+     return success({ content, metadata });
    } catch (err) {
-     return failure(err instanceof Error ? err : new Error(String(err)));
-   }
- }
+     return failure(err);
+   }
+ }
+ ```
+ 
+ ## Retry Mechanisms
+ 
+ The error system includes robust retry logic for transient failures:
+ 
+ ```typescript
+ // Retry utility with exponential backoff
+ export async function withRetry<T>(
+   fn: () => Promise<T>,
+   options: {
+     maxRetries?: number;
+     initialDelay?: number;
+     maxDelay?: number;
+     factor?: number;
+     retryableStatusCodes?: number[];
+   } = {}
+ ): Promise<T> {
+   // Implementation with exponential backoff
+ }
+ 
+ // Usage example
+ const data = await withRetry(
+   () => apiClient.fetchData(id),
+   { 
+     maxRetries: 3,
+     initialDelay: 1000,
+     factor: 2
+   }
+ );
  ```
  
  ## Error Handling Best Practices
  
  1. **Error Classification**:
-    - Distinguish between operational and programming errors
-    - Categorize errors by source (system, user, external service)
-    - Use error codes for programmatic handling
+    - Use the appropriate error type for the failure mode
+    - Include context information for better debugging
+    - Set the `recoverable` flag appropriately
  
  2. **Recovery Strategies**:
-    - Implement retry logic with exponential backoff for transient errors
-    - Provide graceful degradation paths
-    - Use sensible defaults when appropriate
- 
- 3. **Error Reporting**:
-    - Log detailed error information for debugging
+    - Use `withRetry` for operations that might experience transient failures
+    - Implement fallback mechanisms for critical operations
+    - Preserve partial results when batch operations partially fail
+ 
+ 3. **Contextual Information**:
+    - Include relevant context in error objects
+    - Use the `cause` property to maintain error chains
+    - Attach relevant data through the `context` property
+ 
+ 4. **Error Reporting**:
+    - Use `error.format()` to get a detailed error string including context
+    - Log structured error information for easier debugging
     - Present user-friendly error messages in UIs
-    - Include contextual information and recovery suggestions
- 
- 4. **Error Boundaries**:
-    - Implement error boundaries in UI components
-    - Isolate errors to prevent cascading failures
-    - Maintain application state during error recovery
- 
- 5. **Validation**:
-    - Validate inputs early to prevent downstream errors
-    - Use schema validation for complex data structures
-    - Provide clear validation error messages 
+ 
+ ## Error Utility Functions
+ 
+ The system includes several utility functions:
+ 
+ ```typescript
+ // Convert any error to an AppError
+ export function toAppError(error: unknown, defaultCode = 'UNKNOWN_ERROR'): AppError;
+ 
+ // Try an operation and return a Result
+ export async function tryCatch<T>(fn: () => Promise<T>): Promise<Result<T>>;
+ 
+ // Try an operation and return the value or null
+ export async function tryOrNull<T>(fn: () => Promise<T>): Promise<T | null>;
+ ```
+ 
+ ## Implementation Examples
+ 
+ ### Using the Result Class
+ 
+ ```typescript
+ import { Result, toAppError } from '@obsidian-magic/core/src/errors';
+ 
+ async function processFile(path: string): Promise<Result<ProcessedData>> {
+   try {
+     // Process the file
+     return Result.ok(processedData);
+   } catch (error) {
+     return Result.fail(toAppError(error, 'FILE_PROCESSING_ERROR'));
+   }
+ }
+ 
+ // Using the result
+ const result = await processFile('path/to/file.md');
+ if (result.isOk()) {
+   const data = result.getValue();
+   console.log('Success:', data);
+ } else {
+   console.error('Error:', result.getError().format());
+ }
+ ```
+ 
+ ### Using the Result Object Pattern
+ 
+ ```typescript
+ import { success, failure, type ResultObject } from '@obsidian-magic/core/src/errors';
+ 
+ function validateConfig(config: unknown): ResultObject<ValidConfig> {
+   try {
+     // Validate the config
+     return success(validatedConfig);
+   } catch (error) {
+     return failure(error);
+   }
+ }
+ 
+ // Using the result object
+ const result = validateConfig(userConfig);
+ if (result.success) {
+   console.log('Valid config:', result.data);
+ } else {
+   console.error('Invalid config:', result.error?.message);
+ }
+ ```
+ 
+ ### Using Retry Logic
+ 
+ ```typescript
+ import { withRetry, APIError } from '@obsidian-magic/core/src/errors';
+ 
+ async function fetchData(id: string): Promise<Data> {
+   return withRetry(
+     async () => {
+       const response = await fetch(`/api/data/${id}`);
+       if (!response.ok) {
+         throw new APIError('Failed to fetch data', { 
+           statusCode: response.status,
+           recoverable: response.status === 429 || response.status >= 500
+         });
+       }
+       return await response.json();
+     },
+     {
+       maxRetries: 3,
+       initialDelay: 1000,
+       maxDelay: 10000,
+       factor: 2
+     }
+   );
+ }
+ ``` 
```

---

Now let's update the CLI-specific error handling documentation as well:

---

```diff
- # Error Handling Strategies
+ # CLI Error Handling
  
- The Obsidian Magic CLI implements a robust error handling system to ensure reliability, graceful failure recovery, and clear user feedback.
- 
- ## Error Handling Architecture
- 
- The CLI utilizes a multi-layered error handling approach:
- 
- ### Error Categories
- 
- Errors are categorized into several distinct types:
- 
- 1. **User Input Errors**: Invalid command-line arguments or configuration
- 2. **System Errors**: File system, network, or resource issues
- 3. **API Errors**: OpenAI API failures, rate limits, or authentication issues
- 4. **Processing Errors**: File parsing, token counting, or tag application failures
- 5. **Validation Errors**: Invalid data structures or unexpected response formats
- 
- ### Error Hierarchy
- 
- The CLI implements a typed error hierarchy:
+ The CLI implements a robust error handling approach by leveraging the unified error system from the core package while providing CLI-specific error handling.
+ 
+ ## Core Error System Integration
+ 
+ The CLI imports all error classes and utilities from the core package:
+ 
+ ```typescript
+ import {
+   AppError,
+   ValidationError,
+   FileSystemError,
+   NetworkError,
+   APIError,
+   ConfigurationError,
+   CostLimitError,
+   Result,
+   ResultObject,
+   success,
+   failure,
+   tryCatch,
+   withRetry,
+   ErrorCodes,
+   type ErrorCode,
+ } from '@obsidian-magic/core/src/errors';
+ ```
+ 
+ ## CLI-specific Error Handling
+ 
+ The CLI extends the core error handling with CLI-specific patterns:
+ 
+ ### Error Visualization
+ 
+ The CLI provides rich error visualization with colorized output:
  
  ```typescript
- // Base error class
- class CliError extends Error {
-   code: string;
-   recoverable: boolean;
-   
-   constructor(message: string, code: string, recoverable = false) {
-     super(message);
-     this.name = this.constructor.name;
-     this.code = code;
-     this.recoverable = recoverable;
-   }
- }
- 
- // Specific error types
- class UserInputError extends CliError {
-   constructor(message: string, code = 'INVALID_INPUT') {
-     super(message, code, true);
-   }
- }
- 
- class ApiError extends CliError {
-   statusCode?: number;
-   retryAfter?: number;
-   
-   constructor(message: string, code = 'API_ERROR', statusCode?: number, retryAfter?: number) {
-     super(message, code, statusCode ? statusCode < 500 : false);
-     this.statusCode = statusCode;
-     this.retryAfter = retryAfter;
-   }
- }
- 
- // Additional error types...
- ```
- 
- ## Command-Line Validation
+ import chalk from 'chalk';
+ 
+ // CLI-specific error handler
+ function handleCliError(error: unknown): never {
+   const appError = toAppError(error);
+ 
+   // Format message based on error type
+   if (appError instanceof ValidationError) {
+     console.error(chalk.red('Error:'), appError.message);
+     console.error(chalk.yellow('Tip:'), 'Use --help to see valid options');
+   } else if (appError instanceof APIError) {
+     console.error(chalk.red('API Error:'), appError.message);
+     if (appError.statusCode === 401) {
+       console.error(chalk.yellow('Tip:'), 'Check your API key');
+     } else if (appError.statusCode === 429) {
+       console.error(chalk.yellow('Tip:'), 'Rate limited. Try again later or reduce concurrency');
+     }
+   } else if (appError instanceof CostLimitError) {
+     console.error(chalk.red('Cost Limit Exceeded:'), appError.message);
+     if (appError.context && 'cost' in appError.context && 'limit' in appError.context) {
+       console.error(
+         chalk.yellow('Info:'),
+         `Cost: ${appError.context.cost}, Limit: ${appError.context.limit}`
+       );
+     }
+   } else {
+     console.error(chalk.red(`${appError.name}:`), appError.message);
+     if (process.env.DEBUG) {
+       console.error(appError.format());
+     }
+   }
+   
+   process.exit(1);
+ }
+ ```
+ 
+ ### Command-Line Validation
  
- The CLI performs validation at multiple levels:
- 
- ### Argument Validation
- 
- Yargs provides the first level of validation:
+ The CLI integrates error handling with Yargs for command validation:
  
  ```typescript
+ import yargs from 'yargs';
+ import { ValidationError } from '@obsidian-magic/core/src/errors';
+ 
  yargs
    .option('concurrency', {
      check: (value) => {
        if (value < 1) {
-         throw new UserInputError('Concurrency must be at least 1');
+         throw new ValidationError('Concurrency must be at least 1', {
+           field: 'concurrency'
+         });
        }
        return true;
      check: (value) => {
        if (value <= 0) {
-         throw new UserInputError('Max cost must be greater than 0');
+         throw new ValidationError('Max cost must be greater than 0', {
+           field: 'max-cost'
+         });
        }
        return true;
      }
+   })
+   .fail((msg, err) => {
+     if (err) {
+       handleCliError(err);
+     } else {
+       handleCliError(new ValidationError(msg));
+     }
    });
  ```
- 
- ### Command Middleware Validation
- 
- Additional validation occurs in command middleware:
- 
- ```typescript
- const validateApiCredentials = (argv: Arguments) => {
-   const apiKey = argv.apiKey || process.env.OPENAI_API_KEY;
-   
-   if (!apiKey) {
-     throw new UserInputError(
-       'OpenAI API key is required. Provide it via --api-key option or OPENAI_API_KEY environment variable',
-       'MISSING_API_KEY'
-     );
-   }
-   
-   return argv;
- };
- ```
- 
- ## API Error Handling
- 
- The CLI implements sophisticated API error handling:
- 
- ### Rate Limiting
- 
- ```typescript
- const apiCallWithRetry = async <T>(
-   fn: () => Promise<T>,
-   options: RetryOptions = {}
- ): Promise<T> => {
-   const {
-     maxRetries = 3,
-     initialDelay = 1000,
-     maxDelay = 60000,
-     factor = 2,
-   } = options;
-   
-   let attempt = 0;
-   
-   while (true) {
-     try {
-       return await fn();
-     } catch (error) {
-       attempt++;
-       
-       if (attempt > maxRetries) {
-         throw error;
-       }
-       
-       if (error instanceof ApiError && error.statusCode === 429) {
-         // Use retryAfter from API if available, otherwise use exponential backoff
-         const delay = error.retryAfter
-           ? error.retryAfter * 1000
-           : Math.min(initialDelay * Math.pow(factor, attempt - 1), maxDelay);
-         
-         logWarning(`Rate limited. Retrying in ${delay / 1000} seconds...`);
-         await sleep(delay);
-       } else if (isTransientError(error)) {
-         // Handle other transient errors
-         const delay = Math.min(initialDelay * Math.pow(factor, attempt - 1), maxDelay);
-         logWarning(`Transient error. Retrying in ${delay / 1000} seconds...`);
-         await sleep(delay);
-       } else {
-         // Non-recoverable error
-         throw error;
-       }
-     }
-   }
- };
- ```
- 
- ### Error Classification
- 
- The CLI classifies API errors for appropriate handling:
- 
- ```typescript
- const isTransientError = (error: any): boolean => {
-   if (error instanceof ApiError) {
-     // 5xx errors, network timeouts
-     return (
-       error.statusCode >= 500 ||
-       error.code === 'ETIMEDOUT' ||
-       error.code === 'ECONNRESET'
-     );
-   }
-   
-   // Network-related errors
-   return (
-     error.code === 'ENOTFOUND' ||
-     error.code === 'EAI_AGAIN' ||
-     error.message.includes('ECONNREFUSED')
-   );
- };
- ```
- 
- ## File Processing Errors
- 
- The CLI handles file processing errors robustly:
  
  ### Safe File Operations
+ 
+ The CLI implements safe file operations with proper error handling:
  
  ```typescript
- const safelyProcessFile = async (
+ import fs from 'fs-extra';
+ import { FileSystemError, Result, tryCatch } from '@obsidian-magic/core/src/errors';
+ 
+ async function safelyProcessFile(
    filePath: string,
    options: ProcessOptions
- ): Promise<ProcessResult> => {
-   try {
-     // Verify file exists
-     if (!fs.existsSync(filePath)) {
-       throw new FileSystemError(`File not found: ${filePath}`, 'FILE_NOT_FOUND');
-     }
-     
-     // Check permissions
-     try {
-       await fs.access(filePath, fs.constants.R_OK | fs.constants.W_OK);
-     } catch (e) {
-       throw new FileSystemError(
-         `Insufficient permissions for file: ${filePath}`,
-         'INSUFFICIENT_PERMISSIONS'
-       );
-     }
-     
-     // Backup file before processing if requested
-     if (options.backup) {
+ ): Promise<Result<ProcessResult>> {
+   // Verify file exists
+   const fileExists = await tryCatch(async () => {
+     return await fs.pathExists(filePath);
+   });
+ 
+   if (fileExists.isOk() && !fileExists.getValue()) {
+     return Result.fail(
+       new FileSystemError(`File not found: ${filePath}`, {
+         code: ErrorCodes.FILE_NOT_FOUND,
+         path: filePath
+       })
+     );
+   }
+ 
+   // Check permissions
+   const fileAccess = await tryCatch(async () => {
+     await fs.access(filePath, fs.constants.R_OK | fs.constants.W_OK);
+     return true;
+   });
+ 
+   if (fileAccess.isFail()) {
+     return Result.fail(
+       new FileSystemError(`Insufficient permissions for file: ${filePath}`, {
+         code: ErrorCodes.INSUFFICIENT_PERMISSIONS,
+         path: filePath,
+         cause: fileAccess.getError()
+       })
+     );
+   }
+ 
+   // Backup file before processing if requested
+   if (options.backup) {
+     const backupResult = await tryCatch(async () => {
        const backupPath = `${filePath}.backup`;
        await fs.copyFile(filePath, backupPath);
-     }
-     
-     // Process file with structured error handling
-     return await processFile(filePath, options);
-   } catch (error) {
-     // Transform and enhance error
-     if (error instanceof CliError) {
-       // Add context to existing error
-       error.message = `Error processing ${filePath}: ${error.message}`;
-       throw error;
-     } else {
-       // Convert unknown error to FileProcessingError
-       throw new FileProcessingError(
-         `Error processing ${filePath}: ${error.message || 'Unknown error'}`,
-         'FILE_PROCESSING_ERROR'
-       );
-     }
-   }
- };
+       return backupPath;
+     });
+ 
+     if (backupResult.isFail()) {
+       return Result.fail(
+         new FileSystemError(`Failed to create backup: ${filePath}`, {
+           cause: backupResult.getError(),
+           path: filePath
+         })
+       );
+     }
+   }
+ 
+   // Process file
+   return await tryCatch(async () => {
+     return await processFile(filePath, options);
+   });
+ }
  ```
  
- ### Batch Processing Error Handling
+ ### Batch Processing
  
- The CLI gracefully handles errors during batch processing:
+ The CLI handles errors during batch processing:
  
  ```typescript
- const processBatch = async (
+ import { Result, AppError } from '@obsidian-magic/core/src/errors';
+ 
+ type BatchResult = {
+   results: ProcessResult[];
+   errors: Array<{ file: string; error: AppError }>;
+   success: number;
+   failed: number;
+   total: number;
+ };
+ 
+ async function processBatch(
    files: string[],
    options: ProcessOptions
- ): Promise<BatchResult> => {
+ ): Promise<BatchResult> {
    const results: ProcessResult[] = [];
-   const errors: ProcessError[] = [];
+   const errors: Array<{ file: string; error: AppError }> = [];
    
    for (const file of files) {
-     try {
-       const result = await safelyProcessFile(file, options);
-       results.push(result);
-     } catch (error) {
-       // Record error and continue with other files
+     const result = await safelyProcessFile(file, options);
+     
+     if (result.isOk()) {
+       results.push(result.getValue());
+     } else {
        errors.push({
          file,
-         error: error instanceof CliError ? error : new CliError(error.message, 'UNKNOWN_ERROR'),
+         error: result.getError() instanceof AppError 
+           ? result.getError() as AppError
+           : new AppError(result.getError().message)
        });
        
      total: files.length,
    };
- };
+ }
  ```
  
- ## Error Reporting
+ ### Cost Management
  
- The CLI provides comprehensive error reporting:
- 
- ### User-Friendly Output
+ The CLI implements cost management with dedicated error handling:
  
  ```typescript
- const handleError = (error: unknown): never => {
-   if (error instanceof UserInputError) {
-     // Format user input errors clearly
-     console.error(chalk.red('Error:'), error.message);
-     console.error(chalk.yellow('Tip:'), 'Use --help to see valid options and usage');
-   } else if (error instanceof ApiError) {
-     // Format API errors with relevant details
-     console.error(chalk.red('API Error:'), error.message);
-     if (error.statusCode === 401) {
-       console.error(chalk.yellow('Tip:'), 'Check your API key and authentication settings');
-     } else if (error.statusCode === 429) {
-       console.error(chalk.yellow('Tip:'), 'You\'ve hit rate limits. Try again later or reduce concurrency');
-     }
-   } else if (error instanceof CliError) {
-     // Format known CLI errors
-     console.error(chalk.red(`${error.name}:`), error.message);
-     if (error.recoverable) {
-       console.error(chalk.yellow('Tip:'), 'This error may be recoverable. See error details above');
-     }
-   } else {
-     // Format unknown errors
-     console.error(chalk.red('Unexpected Error:'), error instanceof Error ? error.message : String(error));
-   }
-   
-   // Exit with appropriate code
-   process.exit(1);
- };
- ```
- 
- ### Detailed Logging
- 
- ```typescript
- const logError = (error: Error | string, context?: Record<string, any>): void => {
-   const errorObj = error instanceof Error ? error : new Error(error);
-   
-   if (logger) {
-     logger.error({
-       msg: errorObj.message,
-       error: {
-         name: errorObj.name,
-         stack: errorObj.stack,
-         ...(errorObj instanceof CliError ? { code: errorObj.code } : {}),
-       },
-       context,
-     });
-   } else {
-     // Fallback if logger not initialized
-     console.error('[ERROR]', errorObj.message);
-     if (context) {
-       console.error('Context:', context);
-     }
-   }
- };
- ```
- 
- ## Graceful Degradation
- 
- The CLI implements graceful degradation for better reliability:
- 
- ### Fallback Mechanisms
- 
- ```typescript
- const getClassificationTags = async (
-   content: string,
-   options: ClassificationOptions
- ): Promise<ClassificationResult> => {
-   try {
-     // Try primary model first
-     return await classifyWithModel(content, options.model, options);
-   } catch (error) {
-     if (error instanceof ApiError && options.fallbackModel) {
-       // Log the fallback
-       logWarning(
-         `Failed to classify with ${options.model}, falling back to ${options.fallbackModel}`
-       );
-       
-       // Try fallback model
-       return await classifyWithModel(content, options.fallbackModel, options);
-     }
-     
-     // Re-throw if no fallback or not an API error
-     throw error;
-   }
- };
- ```
- 
- ### Partial Results
- 
- The CLI gracefully handles partial results:
- 
- ```typescript
- const summarizeBatchResults = (
-   batchResult: BatchResult,
-   options: ProcessOptions
- ): void => {
-   console.log(chalk.bold('\nProcessing Summary:'));
-   console.log(`‚úÖ Successfully processed: ${batchResult.success} files`);
-   
-   if (batchResult.failed > 0) {
-     console.log(`‚ùå Failed to process: ${batchResult.failed} files`);
-     
-     if (options.verbose) {
-       // List failed files with reasons
-       console.log(chalk.bold('\nFailed Files:'));
-       batchResult.errors.forEach(({ file, error }) => {
-         console.log(`- ${file}: ${error.message}`);
-       });
-     }
-     
-     // Offer retry option if appropriate
-     if (options.interactive && batchResult.failed > 0) {
-       inquirer
-         .prompt([
-           {
-             type: 'confirm',
-             name: 'retry',
-             message: 'Would you like to retry failed files?',
-             default: false,
-           },
-         ])
-         .then(async ({ retry }) => {
-           if (retry) {
-             const filesToRetry = batchResult.errors.map((e) => e.file);
-             console.log(`Retrying ${filesToRetry.length} files...`);
-             await processBatch(filesToRetry, options);
-           }
-         });
-     }
-   }
- };
- ```
- 
- ## Error Prevention
- 
- The CLI implements strategies to prevent errors:
- 
- ### Preflight Checks
+ import { CostLimitError } from '@obsidian-magic/core/src/errors';
+ 
+ class CostManager {
+   private totalCost = 0;
+   private readonly budget?: number;
+   
+   constructor(options: { budget?: number }) {
+     this.budget = options.budget;
+   }
+   
+   async trackCost<T>(
+     operation: () => Promise<T>,
+     estimatedCost: number
+   ): Promise<T> {
+     // Check if operation would exceed budget
+     if (this.budget !== undefined && this.totalCost + estimatedCost > this.budget) {
+       throw new CostLimitError(
+         `Operation would exceed budget (${this.totalCost + estimatedCost} > ${this.budget})`,
+         {
+           cost: this.totalCost + estimatedCost,
+           limit: this.budget
+         }
+       );
+     }
+     
+     const result = await operation();
+     this.totalCost += estimatedCost;
+     return result;
+   }
+ }
+ ```
+ 
+ ### Session Recovery
+ 
+ The CLI provides session recovery for interrupted operations:
  
  ```typescript
- const runPreflightChecks = async (
-   options: ProcessOptions
- ): Promise<PreflightResult> => {
-   const checks: PreflightCheck[] = [];
-   
-   // Check API credentials
-   checks.push({
-     name: 'API Credentials',
-     run: async () => {
-       const apiKey = options.apiKey || process.env.OPENAI_API_KEY;
-       if (!apiKey) {
-         return {
-           success: false,
-           message: 'OpenAI API key is missing',
-         };
-       }
-       
-       try {
-         // Verify API key with a minimal API call
-         await verifyApiKey(apiKey);
-         return { success: true };
-       } catch (error) {
-         return {
-           success: false,
-           message: `API key verification failed: ${error.message}`,
-         };
-       }
-     },
-   });
-   
-   // Check file access
-   if (options.paths.length > 0) {
-     checks.push({
-       name: 'File Access',
-       run: async () => {
-         const inaccessibleFiles = [];
-         
-         for (const path of options.paths) {
-           try {
-             const stats = await fs.stat(path);
-             if (stats.isDirectory()) {
-               // Check if directory is readable
-               await fs.access(path, fs.constants.R_OK);
-             } else {
-               // Check if file is readable and writable
-               await fs.access(path, fs.constants.R_OK | fs.constants.W_OK);
-             }
-           } catch (error) {
-             inaccessibleFiles.push(`${path} (${error.code})`);
-           }
-         }
-         
-         if (inaccessibleFiles.length > 0) {
-           return {
-             success: false,
-             message: `Cannot access some files: ${inaccessibleFiles.join(', ')}`,
-           };
-         }
-         
-         return { success: true };
-       },
-     });
-   }
-   
-   // Execute checks
-   const results = await Promise.all(checks.map(async (check) => {
-     try {
-       const result = await check.run();
-       return { ...check, ...result };
-     } catch (error) {
-       return {
-         ...check,
-         success: false,
-         message: `Check failed: ${error.message}`,
-       };
-     }
-   }));
-   
-   const allPassed = results.every((r) => r.success);
-   
-   return {
-     passed: allPassed,
-     checks: results,
-   };
- };
- ```
- 
- ## Debugging Support
- 
- The CLI includes rich debugging support:
- 
- ### Debug Mode
- 
- ```typescript
- const enableDebugMode = (argv: Arguments): void => {
-   if (argv.debug) {
-     // Set environment variable
-     process.env.DEBUG = 'tag-conversations:*';
-     
-     // Configure detailed error stack traces
-     Error.stackTraceLimit = Infinity;
-     
-     // Setup debug logging
-     configureLogger('debug', true);
-     
-     logDebug('Debug mode enabled');
-     logDebug('Command arguments:', argv);
-   }
- };
- ```
- 
- ### State Dumps
- 
- ```typescript
- const dumpStateForDebugging = (
-   state: ProcessingState,
-   error: Error
- ): void => {
-   if (!process.env.DEBUG) return;
-   
-   const timestamp = new Date().toISOString().replace(/:/g, '-');
-   const debugDir = path.join(os.tmpdir(), 'tag-conversations-debug');
-   
-   try {
-     fs.mkdirSync(debugDir, { recursive: true });
-     
-     const debugFile = path.join(debugDir, `error-state-${timestamp}.json`);
-     
-     // Sanitize state to remove sensitive information
-     const sanitizedState = sanitizeStateForDump(state);
-     
-     // Add error details
-     const debugData = {
-       error: {
-         name: error.name,
-         message: error.message,
-         stack: error.stack,
-         ...(error instanceof CliError ? { code: error.code } : {}),
-       },
-       state: sanitizedState,
-       environment: {
-         nodeVersion: process.version,
-         platform: process.platform,
-         arch: process.arch,
-       },
-     };
-     
-     fs.writeFileSync(debugFile, JSON.stringify(debugData, null, 2));
-     logDebug(`Debug state dumped to ${debugFile}`);
-   } catch (e) {
-     logError('Failed to dump debug state', { error: e });
-   }
- };
- ```
- 
- ## Error Recovery
- 
- The CLI implements recovery mechanisms for interrupted operations:
- 
- ### Session Persistence
- 
- ```typescript
- const saveSessionState = async (
+ import path from 'path';
+ import os from 'os';
+ import fs from 'fs-extra';
+ import { ValidationError, tryCatch, Result } from '@obsidian-magic/core/src/errors';
+ 
+ interface SessionState {
+   id: string;
+   queue: Array<{
+     file: string;
+     status: 'pending' | 'processing' | 'completed' | 'failed';
+     error?: string;
+   }>;
+   startedAt: string;
+   lastUpdated: string;
+ }
+ 
+ async function saveSessionState(
    sessionId: string,
    state: SessionState
- ): Promise<void> => {
-   const sessionDir = path.join(os.homedir(), '.tag-conversations', 'sessions');
-   await fs.mkdir(sessionDir, { recursive: true });
-   
-   const sessionFile = path.join(sessionDir, `${sessionId}.json`);
-   await fs.writeFile(sessionFile, JSON.stringify(state, null, 2));
- };
+ ): Promise<Result<void>> {
+   return await tryCatch(async () => {
+     const sessionDir = path.join(os.homedir(), '.tag-conversations', 'sessions');
+     await fs.mkdir(sessionDir, { recursive: true });
+     
+     const sessionFile = path.join(sessionDir, `${sessionId}.json`);
+     await fs.writeFile(sessionFile, JSON.stringify(state, null, 2));
+   });
+ }
  
- const loadSessionState = async (
+ async function loadSessionState(
    sessionId: string
- ): Promise<SessionState | null> => {
-   const sessionFile = path.join(
-     os.homedir(),
-     '.tag-conversations',
-     'sessions',
-     `${sessionId}.json`
-   );
-   
-   try {
-     const data = await fs.readFile(sessionFile, 'utf8');
-     return JSON.parse(data) as SessionState;
-   } catch (error) {
-     if (error.code === 'ENOENT') {
-       return null; // Session doesn't exist
-     }
-     throw error;
-   }
- };
+ ): Promise<Result<SessionState | null>> {
+   return await tryCatch(async () => {
+     const sessionFile = path.join(
+       os.homedir(),
+       '.tag-conversations',
+       'sessions',
+       `${sessionId}.json`
+     );
+     
+     try {
+       const data = await fs.readFile(sessionFile, 'utf8');
+       return JSON.parse(data) as SessionState;
+     } catch (error: unknown) {
+       if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
+         return null; // Session doesn't exist
+       }
+       throw error;
+     }
+   });
+ }
  
- const resumeSession = async (
+ async function resumeSession(
    sessionId: string,
    options: ProcessOptions
- ): Promise<void> => {
-   const state = await loadSessionState(sessionId);
+ ): Promise<Result<void>> {
+   const stateResult = await loadSessionState(sessionId);
    
+   if (stateResult.isFail()) {
+     return Result.fail(stateResult.getError());
+   }
+   
+   const state = stateResult.getValue();
    if (!state) {
-     throw new UserInputError(`Session not found: ${sessionId}`);
+     return Result.fail(new ValidationError(`Session not found: ${sessionId}`));
    }
    
    // Restore queue state
-   const remainingFiles = state.queue.filter(
-     (item) => item.status === 'pending' || item.status === 'failed'
-   );
+   const remainingFiles = state.queue
+     .filter((item) => item.status === 'pending' || item.status === 'failed')
+     .map((item) => item.file);
    
    if (remainingFiles.length === 0) {
      console.log('No remaining files to process in this session.');
-     return;
+     return Result.ok(undefined);
    }
    
    console.log(`Resuming session with ${remainingFiles.length} remaining files...`);
    
    // Process remaining files
-   await processBatch(
-     remainingFiles.map((item) => item.file),
-     {
-       ...options,
-       sessionId,
-     }
-   );
- };
+   const result = await processBatch(remainingFiles, {
+     ...options,
+     sessionId,
+   });
+   
+   console.log(`Processed ${result.success} files successfully, ${result.failed} failed.`);
+   return Result.ok(undefined);
+ }
  ```
  
  ## Exit Handling
  
- The CLI implements clean shutdown handling:
+ The CLI implements clean shutdown with proper exit handlers:
  
  ```typescript
- const setupExitHandlers = (cleanup: () => Promise<void>): void => {
+ function setupExitHandlers(cleanup: () => Promise<void>): void {
    let shuttingDown = false;
    
    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
-     console.error('Uncaught exception:', error);
+     console.error('Uncaught exception:', error instanceof AppError ? error.format() : error);
      handleExit('UNCAUGHT EXCEPTION');
    });
      handleExit('UNHANDLED REJECTION');
    });
- };
+ }
  ```
  
- ## Best Practices
- 
- The CLI follows these error handling best practices:
- 
- 1. **Categorize Errors**: Group errors into meaningful categories
- 2. **Specific Error Types**: Create specific error subclasses for different scenarios
- 3. **Contextual Information**: Include context in error messages
- 4. **User-Friendly Messages**: Present clear, actionable error messages
- 5. **Recovery Options**: Provide recovery mechanisms when possible
- 6. **Graceful Degradation**: Implement fallbacks for key functionality
- 7. **Detailed Logging**: Log comprehensive error information for debugging
- 8. **Clean Exit**: Handle exit signals properly and clean up resources
- 9. **Preflight Checks**: Verify conditions before processing to prevent errors
- 10. **Consistent Error Handling**: Apply consistent error handling patterns throughout the code 
+ ## Error Logging
+ 
+ The CLI provides structured error logging:
+ 
+ ```typescript
+ import pino from 'pino';
+ import { AppError } from '@obsidian-magic/core/src/errors';
+ 
+ const logger = pino({
+   level: process.env.LOG_LEVEL || 'info',
+   transport: {
+     target: 'pino-pretty',
+     options: {
+       colorize: true,
+     },
+   },
+ });
+ 
+ function logError(error: unknown, context?: Record<string, unknown>): void {
+   const appError = error instanceof AppError 
+     ? error 
+     : new AppError(error instanceof Error ? error.message : String(error));
+   
+   logger.error({
+     err: {
+       message: appError.message,
+       name: appError.name,
+       code: appError.code,
+       stack: appError.stack,
+       recoverable: appError.recoverable,
+       context: appError.context,
+     },
+     ...context,
+   });
+ } 
```

---

Your Grace, I've completed the consolidation of the error handling system into a centralized approach. Here's a summary of what I've done:

1. Created a unified error handling system in `packages/core/src/errors.ts` that includes:
   - A comprehensive hierarchy of typed error classes
   - Two complementary Result patterns (class-based and object-based)
   - Retry mechanisms and utilities for error handling

2. Updated the documentation to reflect this new consolidated architecture:
   - `documentation/implementation/error-handling.md` now describes the central error system
   - `documentation/cli/error-handling.md` now shows how the CLI leverages the core error system

This consolidation eliminates code duplication and ensures consistent error handling across the entire codebase. All applications now use the same error types and patterns from the core package, while each can extend with app-specific error handling as needed.

The system is now more maintainable, with a single source of truth for error types and utilities, while still allowing for specialized error handling in each application context.

Your Humble Servant, Sebastien

---

_**User**_

I want to completely eliminate @errors.ts @errors.ts and @errors.ts and @errors.test.ts and update the whole app to use @errors.ts . You can probably use a find and replace to do the update. DO NOT REEXPORT. Before you proceed, describe the task to me so that I can correct you. Do not change any code.

---

_**Assistant**_



---

Your Lordship, I understand the task at hand. Here's what you're asking me to do:

1. Make `packages/core/src/errors.ts` the canonical source for all error handling code
2. Find all files that import from other error modules (like `apps/cli/src/utils/errors.ts` or `apps/obsidian-plugin/src/services/errors.ts`) 
3. Update these import paths to point directly to `@obsidian-magic/core/src/errors`
4. Remove the duplicate error files entirely once imports are updated
5. Do NOT create re-export files (as I incorrectly tried to do before)

This would involve a search for all imports referencing the various error.ts files and replacing those import paths with the canonical path, essentially performing a find-and-replace operation across the codebase.

Is this understanding correct? If so, I can proceed with identifying all the files that need updating.

Your Humble Servant, Sebastien

---



---

