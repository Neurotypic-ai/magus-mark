<!-- Generated by SpecStory -->

# Refactoring Code into a Class (2025-04-14 03:15:21)

_**User**_

Turn this into a handy class instead and update the @file.test.ts and @index.ts exports

---

_**Assistant**_



---

```diff
  
  /**
-  * Ensures a directory exists, creating it if necessary
-  * @param dirPath - Path to the directory
-  */
- export async function ensureDirectory(dirPath: string): Promise<void> {
-   await fs.ensureDir(dirPath);
- }
+  * Class providing file system utility methods for Obsidian Magic
+  */
+ export class FileUtils {
+   private basePath: string;
+ 
+   /**
+    * Creates a new FileUtils instance
+    * @param basePath - Optional base directory for relative paths
+    */
+   constructor(basePath: string = '') {
+     this.basePath = basePath;
+   }
+ 
+   /**
+    * Resolves a path relative to the base path
+    * @param filePath - Path to resolve
+    * @returns Resolved path
+    */
+   private resolvePath(filePath: string): string {
+     return this.basePath ? path.join(this.basePath, filePath) : filePath;
+   }
+ 
+   /**
+    * Ensures a directory exists, creating it if necessary
+    * @param dirPath - Path to the directory
+    */
+   async ensureDirectory(dirPath: string): Promise<void> {
+     await fs.ensureDir(this.resolvePath(dirPath));
+   }
+ 
+   /**
+    * Reads a file from the filesystem
+    * @param filePath - Path to the file
+    * @returns File contents as string
+    */
+   async readFile(filePath: string): Promise<string> {
+     try {
+       return await fs.readFile(this.resolvePath(filePath), 'utf-8');
+     } catch (error) {
+       throw new Error(`Failed to read file at ${filePath}: ${(error as Error).message}`);
+     }
+   }
+ 
+   /**
+    * Reads a JSON file and validates it against a schema
+    * @param filePath - Path to the JSON file
+    * @param schema - Zod schema for validation
+    * @returns Parsed and validated JSON
+    */
+   async readJsonFile<T>(filePath: string, schema: z.ZodType<T>): Promise<T> {
+     try {
+       const fileContent = await this.readFile(filePath);
+       const parsedData = JSON.parse(fileContent) as T;
+       return schema.parse(parsedData);
+     } catch (error) {
+       if (error instanceof z.ZodError) {
+         throw new Error(`Invalid JSON schema in ${filePath}: ${error.message}`);
+       }
+       if (error instanceof SyntaxError) {
+         throw new Error(`Invalid JSON in ${filePath}: ${error.message}`);
+       }
+       throw error instanceof Error ? error : new Error(String(error));
+     }
+   }
+ 
+   /**
+    * Writes a string to a file
+    * @param filePath - Path to the file
+    * @param content - Content to write
+    */
+   async writeFile(filePath: string, content: string): Promise<void> {
+     try {
+       const resolvedPath = this.resolvePath(filePath);
+       await this.ensureDirectory(path.dirname(resolvedPath));
+       await fs.writeFile(resolvedPath, content, 'utf-8');
+     } catch (error) {
+       throw new Error(`Failed to write file at ${filePath}: ${(error as Error).message}`);
+     }
+   }
+ 
+   /**
+    * Writes a JSON object to a file
+    * @param filePath - Path to the file
+    * @param data - Data to write
+    * @param pretty - Whether to format the JSON (default: true)
+    */
+   async writeJsonFile(filePath: string, data: unknown, pretty = true): Promise<void> {
+     const content = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
+     await this.writeFile(filePath, content);
+   }
+ 
+   /**
+    * Checks if a file exists
+    * @param filePath - Path to the file
+    * @returns True if the file exists
+    */
+   async fileExists(filePath: string): Promise<boolean> {
+     try {
+       await fs.access(this.resolvePath(filePath));
+       return true;
+     } catch {
+       return false;
+     }
+   }
+ 
+   /**
+    * Recursively finds all files matching a pattern
+    * @param dirPath - Directory to search in
+    * @param pattern - Regex pattern to match against
+    * @returns Array of matching file paths
+    */
+   async findFiles(dirPath: string, pattern: RegExp): Promise<string[]> {
+     const results: string[] = [];
+     const resolvedDirPath = this.resolvePath(dirPath);
+ 
+     async function scan(currentPath: string): Promise<void> {
+       const entries = await fs.readdir(currentPath, { withFileTypes: true });
+ 
+       for (const entry of entries) {
+         const fullPath = path.join(currentPath, entry.name);
+ 
+         if (entry.isDirectory()) {
+           await scan(fullPath);
+         } else if (entry.isFile() && pattern.test(entry.name)) {
+           results.push(fullPath);
+         }
+       }
+     }
+ 
+     await scan(resolvedDirPath);
+     return results;
+   }
+ 
+   /**
+    * Gets file stats with error handling
+    * @param filePath - Path to the file
+    * @returns File stats or null if file doesn't exist
+    */
+   async getFileStats(filePath: string): Promise<fs.Stats | null> {
+     try {
+       return await fs.stat(this.resolvePath(filePath));
+     } catch {
+       return null;
+     }
+   }
+ 
+   /**
+    * Safely deletes a file if it exists
+    * @param filePath - Path to the file
+    * @returns True if file was deleted, false if it didn't exist
+    */
+   async safeDeleteFile(filePath: string): Promise<boolean> {
+     try {
+       await fs.unlink(this.resolvePath(filePath));
+       return true;
+     } catch (error) {
+       if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
+         return false;
+       }
+       throw error instanceof Error ? error : new Error(String(error));
+     }
+   }
+ 
+   // Static methods for convenience
+   
+   /**
+    * Ensures a directory exists, creating it if necessary
+    * @param dirPath - Path to the directory
+    */
+   static async ensureDirectory(dirPath: string): Promise<void> {
+     await fs.ensureDir(dirPath);
+   }
  
- /**
-  * Reads a file from the filesystem
-  * @param filePath - Path to the file
-  * @returns File contents as string
-  */
- export async function readFile(filePath: string): Promise<string> {
-   try {
-     return await fs.readFile(filePath, 'utf-8');
-   } catch (error) {
-     throw new Error(`Failed to read file at ${filePath}: ${(error as Error).message}`);
-   }
- }
+   /**
+    * Reads a file from the filesystem
+    * @param filePath - Path to the file
+    * @returns File contents as string
+    */
+   static async readFile(filePath: string): Promise<string> {
+     try {
+       return await fs.readFile(filePath, 'utf-8');
+     } catch (error) {
+       throw new Error(`Failed to read file at ${filePath}: ${(error as Error).message}`);
+     }
+   }
  
- /**
-  * Reads a JSON file and validates it against a schema
-  * @param filePath - Path to the JSON file
-  * @param schema - Zod schema for validation
-  * @returns Parsed and validated JSON
-  */
- export async function readJsonFile<T>(filePath: string, schema: z.ZodType<T>): Promise<T> {
-   try {
-     const fileContent = await readFile(filePath);
-     const parsedData = JSON.parse(fileContent) as T;
-     return schema.parse(parsedData);
-   } catch (error) {
-     if (error instanceof z.ZodError) {
-       throw new Error(`Invalid JSON schema in ${filePath}: ${error.message}`);
-     }
-     if (error instanceof SyntaxError) {
-       throw new Error(`Invalid JSON in ${filePath}: ${error.message}`);
-     }
-     throw error instanceof Error ? error : new Error(String(error));
-   }
- }
+   /**
+    * Reads a JSON file and validates it against a schema
+    * @param filePath - Path to the JSON file
+    * @param schema - Zod schema for validation
+    * @returns Parsed and validated JSON
+    */
+   static async readJsonFile<T>(filePath: string, schema: z.ZodType<T>): Promise<T> {
+     try {
+       const fileContent = await FileUtils.readFile(filePath);
+       const parsedData = JSON.parse(fileContent) as T;
+       return schema.parse(parsedData);
+     } catch (error) {
+       if (error instanceof z.ZodError) {
+         throw new Error(`Invalid JSON schema in ${filePath}: ${error.message}`);
+       }
+       if (error instanceof SyntaxError) {
+         throw new Error(`Invalid JSON in ${filePath}: ${error.message}`);
+       }
+       throw error instanceof Error ? error : new Error(String(error));
+     }
+   }
  
- /**
-  * Writes a string to a file
-  * @param filePath - Path to the file
-  * @param content - Content to write
-  */
- export async function writeFile(filePath: string, content: string): Promise<void> {
-   try {
-     await ensureDirectory(path.dirname(filePath));
-     await fs.writeFile(filePath, content, 'utf-8');
-   } catch (error) {
-     throw new Error(`Failed to write file at ${filePath}: ${(error as Error).message}`);
-   }
- }
+   /**
+    * Writes a string to a file
+    * @param filePath - Path to the file
+    * @param content - Content to write
+    */
+   static async writeFile(filePath: string, content: string): Promise<void> {
+     try {
+       await FileUtils.ensureDirectory(path.dirname(filePath));
+       await fs.writeFile(filePath, content, 'utf-8');
+     } catch (error) {
+       throw new Error(`Failed to write file at ${filePath}: ${(error as Error).message}`);
+     }
+   }
  
- /**
-  * Writes a JSON object to a file
-  * @param filePath - Path to the file
-  * @param data - Data to write
-  * @param pretty - Whether to format the JSON (default: true)
-  */
- export async function writeJsonFile(filePath: string, data: unknown, pretty = true): Promise<void> {
-   const content = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
- 
-   await writeFile(filePath, content);
- }
+   /**
+    * Writes a JSON object to a file
+    * @param filePath - Path to the file
+    * @param data - Data to write
+    * @param pretty - Whether to format the JSON (default: true)
+    */
+   static async writeJsonFile(filePath: string, data: unknown, pretty = true): Promise<void> {
+     const content = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
+     await FileUtils.writeFile(filePath, content);
+   }
  
- /**
-  * Checks if a file exists
-  * @param filePath - Path to the file
-  * @returns True if the file exists
-  */
- export async function fileExists(filePath: string): Promise<boolean> {
-   try {
-     await fs.access(filePath);
-     return true;
-   } catch {
-     return false;
-   }
- }
+   /**
+    * Checks if a file exists
+    * @param filePath - Path to the file
+    * @returns True if the file exists
+    */
+   static async fileExists(filePath: string): Promise<boolean> {
+     try {
+       await fs.access(filePath);
+       return true;
+     } catch {
+       return false;
+     }
+   }
  
- /**
-  * Recursively finds all files matching a pattern
-  * @param dirPath - Directory to search in
-  * @param pattern - Regex pattern to match against
-  * @returns Array of matching file paths
-  */
- export async function findFiles(dirPath: string, pattern: RegExp): Promise<string[]> {
-   const results: string[] = [];
+   /**
+    * Recursively finds all files matching a pattern
+    * @param dirPath - Directory to search in
+    * @param pattern - Regex pattern to match against
+    * @returns Array of matching file paths
+    */
+   static async findFiles(dirPath: string, pattern: RegExp): Promise<string[]> {
+     const results: string[] = [];
  
-   async function scan(currentPath: string): Promise<void> {
-     const entries = await fs.readdir(currentPath, { withFileTypes: true });
+     async function scan(currentPath: string): Promise<void> {
+       const entries = await fs.readdir(currentPath, { withFileTypes: true });
  
-     for (const entry of entries) {
-       const fullPath = path.join(currentPath, entry.name);
+       for (const entry of entries) {
+         const fullPath = path.join(currentPath, entry.name);
  
-       if (entry.isDirectory()) {
-         await scan(fullPath);
-       } else if (entry.isFile() && pattern.test(entry.name)) {
-         results.push(fullPath);
-       }
-     }
-   }
+         if (entry.isDirectory()) {
+           await scan(fullPath);
+         } else if (entry.isFile() && pattern.test(entry.name)) {
+           results.push(fullPath);
+         }
+       }
+     }
  
-   await scan(dirPath);
-   return results;
- }
+     await scan(dirPath);
+     return results;
+   }
  
- /**
-  * Gets file stats with error handling
-  * @param filePath - Path to the file
-  * @returns File stats or null if file doesn't exist
-  */
- export async function getFileStats(filePath: string): Promise<fs.Stats | null> {
-   try {
-     return await fs.stat(filePath);
-   } catch {
-     return null;
-   }
- }
+   /**
+    * Gets file stats with error handling
+    * @param filePath - Path to the file
+    * @returns File stats or null if file doesn't exist
+    */
+   static async getFileStats(filePath: string): Promise<fs.Stats | null> {
+     try {
+       return await fs.stat(filePath);
+     } catch {
+       return null;
+     }
+   }
  
- /**
-  * Safely deletes a file if it exists
-  * @param filePath - Path to the file
-  * @returns True if file was deleted, false if it didn't exist
-  */
- export async function safeDeleteFile(filePath: string): Promise<boolean> {
-   try {
-     await fs.unlink(filePath);
-     return true;
-   } catch (error) {
-     if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
-       return false;
-     }
-     throw error instanceof Error ? error : new Error(String(error));
-   }
- }
+   /**
+    * Safely deletes a file if it exists
+    * @param filePath - Path to the file
+    * @returns True if file was deleted, false if it didn't exist
+    */
+   static async safeDeleteFile(filePath: string): Promise<boolean> {
+     try {
+       await fs.unlink(filePath);
+       return true;
+     } catch (error) {
+       if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
+         return false;
+       }
+       throw error instanceof Error ? error : new Error(String(error));
+     }
+   }
+ }
+ 
+ // Export all the static methods for backward compatibility
+ export const ensureDirectory = FileUtils.ensureDirectory;
+ export const readFile = FileUtils.readFile;
+ export const readJsonFile = FileUtils.readJsonFile;
+ export const writeFile = FileUtils.writeFile;
+ export const writeJsonFile = FileUtils.writeJsonFile;
+ export const fileExists = FileUtils.fileExists;
+ export const findFiles = FileUtils.findFiles;
+ export const getFileStats = FileUtils.getFileStats;
+ export const safeDeleteFile = FileUtils.safeDeleteFile;
  
```

---

```diff
  
  // Export all the static methods for backward compatibility
- export const ensureDirectory = FileUtils.ensureDirectory;
- export const readFile = FileUtils.readFile;
- export const readJsonFile = FileUtils.readJsonFile;
- export const writeFile = FileUtils.writeFile;
- export const writeJsonFile = FileUtils.writeJsonFile;
- export const fileExists = FileUtils.fileExists;
- export const findFiles = FileUtils.findFiles;
- export const getFileStats = FileUtils.getFileStats;
- export const safeDeleteFile = FileUtils.safeDeleteFile;
+ export const ensureDirectory = (dirPath: string): Promise<void> => FileUtils.ensureDirectory(dirPath);
+ export const readFile = (filePath: string): Promise<string> => FileUtils.readFile(filePath);
+ export const readJsonFile = <T>(filePath: string, schema: z.ZodType<T>): Promise<T> => FileUtils.readJsonFile(filePath, schema);
+ export const writeFile = (filePath: string, content: string): Promise<void> => FileUtils.writeFile(filePath, content);
+ export const writeJsonFile = (filePath: string, data: unknown, pretty = true): Promise<void> => FileUtils.writeJsonFile(filePath, data, pretty);
+ export const fileExists = (filePath: string): Promise<boolean> => FileUtils.fileExists(filePath);
+ export const findFiles = (dirPath: string, pattern: RegExp): Promise<string[]> => FileUtils.findFiles(dirPath, pattern);
+ export const getFileStats = (filePath: string): Promise<fs.Stats | null> => FileUtils.getFileStats(filePath);
+ export const safeDeleteFile = (filePath: string): Promise<boolean> => FileUtils.safeDeleteFile(filePath);
  
```

---

```diff
  import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
  import { z } from 'zod';
- 
- // Import after mocking
- import {
-   ensureDirectory,
-   fileExists,
-   findFiles,
-   getFileStats,
-   readFile,
-   readJsonFile,
-   safeDeleteFile,
-   writeFile,
-   writeJsonFile,
- } from './file';
- 
- import type * as fsTypes from 'fs-extra';
  
  // Import the module under test, but mock the fs-extra dependency
    unlink: mockUnlink,
  }));
+ 
+ // Import after mocking
+ import {
+   FileUtils,
+   ensureDirectory,
+   fileExists,
+   findFiles,
+   getFileStats,
+   readFile,
+   readJsonFile,
+   safeDeleteFile,
+   writeFile,
+   writeJsonFile,
+ } from './file';
+ 
+ import type * as fsTypes from 'fs-extra';
  
  describe('File Utilities', () => {
    });
  
-   describe('ensureDirectory', () => {
-     it('should create directory if it does not exist', async () => {
-       const testDir = '/path/to/dir';
-       mockEnsureDir.mockResolvedValue(undefined);
+   describe('Static Methods', () => {
+     describe('ensureDirectory', () => {
+       it('should create directory if it does not exist', async () => {
+         const testDir = '/path/to/dir';
+         mockEnsureDir.mockResolvedValue(undefined);
  
-       await ensureDirectory(testDir);
-       expect(mockEnsureDir).toHaveBeenCalledWith(testDir);
-     });
-   });
+         await ensureDirectory(testDir);
+         expect(mockEnsureDir).toHaveBeenCalledWith(testDir);
+       });
+     });
  
-   describe('readFile', () => {
-     it('should read file contents', async () => {
-       const testPath = '/path/to/file.txt';
-       const testContent = 'file content';
-       mockReadFile.mockResolvedValue(testContent);
+     describe('readFile', () => {
+       it('should read file contents', async () => {
+         const testPath = '/path/to/file.txt';
+         const testContent = 'file content';
+         mockReadFile.mockResolvedValue(testContent);
  
-       const result = await readFile(testPath);
-       expect(result).toBe(testContent);
-       expect(mockReadFile).toHaveBeenCalledWith(testPath, 'utf-8');
-     });
+         const result = await readFile(testPath);
+         expect(result).toBe(testContent);
+         expect(mockReadFile).toHaveBeenCalledWith(testPath, 'utf-8');
+       });
  
-     it('should throw error when read fails', async () => {
-       const testPath = '/path/to/nonexistent.txt';
-       mockReadFile.mockRejectedValue(new Error('File not found'));
+       it('should throw error when read fails', async () => {
+         const testPath = '/path/to/nonexistent.txt';
+         mockReadFile.mockRejectedValue(new Error('File not found'));
  
-       await expect(readFile(testPath)).rejects.toThrow('Failed to read file');
-       expect(mockReadFile).toHaveBeenCalledWith(testPath, 'utf-8');
-     });
-   });
+         await expect(readFile(testPath)).rejects.toThrow('Failed to read file');
+         expect(mockReadFile).toHaveBeenCalledWith(testPath, 'utf-8');
+       });
+     });
  
-   describe('readJsonFile', () => {
-     it('should read and validate JSON file', async () => {
-       const testPath = '/path/to/file.json';
-       const testContent = '{"name": "test", "value": 123}';
-       const testSchema = z.object({
-         name: z.string(),
-         value: z.number(),
-       });
+     describe('readJsonFile', () => {
+       it('should read and validate JSON file', async () => {
+         const testPath = '/path/to/file.json';
+         const testContent = '{"name": "test", "value": 123}';
+         const testSchema = z.object({
+           name: z.string(),
+           value: z.number(),
+         });
  
-       mockReadFile.mockResolvedValue(testContent);
+         mockReadFile.mockResolvedValue(testContent);
  
-       const result = await readJsonFile(testPath, testSchema);
-       expect(result).toEqual({ name: 'test', value: 123 });
-       expect(mockReadFile).toHaveBeenCalledWith(testPath, 'utf-8');
-     });
+         const result = await readJsonFile(testPath, testSchema);
+         expect(result).toEqual({ name: 'test', value: 123 });
+         expect(mockReadFile).toHaveBeenCalledWith(testPath, 'utf-8');
+       });
  
-     it('should throw error on invalid JSON', async () => {
-       const testPath = '/path/to/invalid.json';
-       const testContent = '{invalid json}';
-       const testSchema = z.object({});
+       it('should throw error on invalid JSON', async () => {
+         const testPath = '/path/to/invalid.json';
+         const testContent = '{invalid json}';
+         const testSchema = z.object({});
  
-       mockReadFile.mockResolvedValue(testContent);
+         mockReadFile.mockResolvedValue(testContent);
  
-       await expect(readJsonFile(testPath, testSchema)).rejects.toThrow('Invalid JSON');
-     });
+         await expect(readJsonFile(testPath, testSchema)).rejects.toThrow('Invalid JSON');
+       });
  
-     it('should throw error on schema validation failure', async () => {
-       const testPath = '/path/to/valid.json';
-       const testContent = '{"name": 123}'; // name should be string
-       const testSchema = z.object({
-         name: z.string(),
-       });
+       it('should throw error on schema validation failure', async () => {
+         const testPath = '/path/to/valid.json';
+         const testContent = '{"name": 123}'; // name should be string
+         const testSchema = z.object({
+           name: z.string(),
+         });
  
-       mockReadFile.mockResolvedValue(testContent);
+         mockReadFile.mockResolvedValue(testContent);
  
-       await expect(readJsonFile(testPath, testSchema)).rejects.toThrow('Invalid JSON schema');
-     });
-   });
+         await expect(readJsonFile(testPath, testSchema)).rejects.toThrow('Invalid JSON schema');
+       });
+     });
  
-   describe('writeFile', () => {
-     it('should write content to file', async () => {
-       const testPath = '/path/to/file.txt';
-       const testContent = 'file content';
+     describe('writeFile', () => {
+       it('should write content to file', async () => {
+         const testPath = '/path/to/file.txt';
+         const testContent = 'file content';
  
-       mockEnsureDir.mockResolvedValue(undefined);
-       mockWriteFile.mockResolvedValue(undefined);
+         mockEnsureDir.mockResolvedValue(undefined);
+         mockWriteFile.mockResolvedValue(undefined);
  
-       await writeFile(testPath, testContent);
-       expect(mockEnsureDir).toHaveBeenCalledWith(path.dirname(testPath));
-       expect(mockWriteFile).toHaveBeenCalledWith(testPath, testContent, 'utf-8');
-     });
+         await writeFile(testPath, testContent);
+         expect(mockEnsureDir).toHaveBeenCalledWith(path.dirname(testPath));
+         expect(mockWriteFile).toHaveBeenCalledWith(testPath, testContent, 'utf-8');
+       });
  
-     it('should throw error when write fails', async () => {
-       const testPath = '/path/to/file.txt';
-       const testContent = 'file content';
+       it('should throw error when write fails', async () => {
+         const testPath = '/path/to/file.txt';
+         const testContent = 'file content';
  
-       mockEnsureDir.mockResolvedValue(undefined);
-       mockWriteFile.mockRejectedValue(new Error('Permission denied'));
+         mockEnsureDir.mockResolvedValue(undefined);
+         mockWriteFile.mockRejectedValue(new Error('Permission denied'));
  
-       await expect(writeFile(testPath, testContent)).rejects.toThrow('Failed to write file');
-     });
-   });
+         await expect(writeFile(testPath, testContent)).rejects.toThrow('Failed to write file');
+       });
+     });
  
-   describe('writeJsonFile', () => {
-     it('should write JSON with pretty formatting by default', async () => {
-       const testPath = '/path/to/file.json';
-       const testData = { name: 'test', value: 123 };
+     describe('writeJsonFile', () => {
+       it('should write JSON with pretty formatting by default', async () => {
+         const testPath = '/path/to/file.json';
+         const testData = { name: 'test', value: 123 };
  
-       mockEnsureDir.mockResolvedValue(undefined);
-       mockWriteFile.mockResolvedValue(undefined);
+         mockEnsureDir.mockResolvedValue(undefined);
+         mockWriteFile.mockResolvedValue(undefined);
  
-       await writeJsonFile(testPath, testData);
-       expect(mockEnsureDir).toHaveBeenCalledWith(path.dirname(testPath));
-       expect(mockWriteFile).toHaveBeenCalledWith(testPath, JSON.stringify(testData, null, 2), 'utf-8');
-     });
+         await writeJsonFile(testPath, testData);
+         expect(mockEnsureDir).toHaveBeenCalledWith(path.dirname(testPath));
+         expect(mockWriteFile).toHaveBeenCalledWith(testPath, JSON.stringify(testData, null, 2), 'utf-8');
+       });
  
-     it('should write compact JSON when pretty=false', async () => {
-       const testPath = '/path/to/file.json';
-       const testData = { name: 'test', value: 123 };
+       it('should write compact JSON when pretty=false', async () => {
+         const testPath = '/path/to/file.json';
+         const testData = { name: 'test', value: 123 };
  
-       mockEnsureDir.mockResolvedValue(undefined);
-       mockWriteFile.mockResolvedValue(undefined);
+         mockEnsureDir.mockResolvedValue(undefined);
+         mockWriteFile.mockResolvedValue(undefined);
  
-       await writeJsonFile(testPath, testData, false);
-       expect(mockWriteFile).toHaveBeenCalledWith(testPath, JSON.stringify(testData), 'utf-8');
-     });
-   });
+         await writeJsonFile(testPath, testData, false);
+         expect(mockWriteFile).toHaveBeenCalledWith(testPath, JSON.stringify(testData), 'utf-8');
+       });
+     });
  
-   describe('fileExists', () => {
-     it('should return true when file exists', async () => {
-       const testPath = '/path/to/existing.txt';
-       mockAccess.mockResolvedValue(undefined);
+     describe('fileExists', () => {
+       it('should return true when file exists', async () => {
+         const testPath = '/path/to/existing.txt';
+         mockAccess.mockResolvedValue(undefined);
  
-       const result = await fileExists(testPath);
-       expect(result).toBe(true);
-       expect(mockAccess).toHaveBeenCalledWith(testPath);
-     });
+         const result = await fileExists(testPath);
+         expect(result).toBe(true);
+         expect(mockAccess).toHaveBeenCalledWith(testPath);
+       });
  
-     it('should return false when file does not exist', async () => {
-       const testPath = '/path/to/nonexistent.txt';
-       mockAccess.mockRejectedValue(new Error('ENOENT'));
+       it('should return false when file does not exist', async () => {
+         const testPath = '/path/to/nonexistent.txt';
+         mockAccess.mockRejectedValue(new Error('ENOENT'));
  
-       const result = await fileExists(testPath);
-       expect(result).toBe(false);
-       expect(mockAccess).toHaveBeenCalledWith(testPath);
-     });
-   });
+         const result = await fileExists(testPath);
+         expect(result).toBe(false);
+         expect(mockAccess).toHaveBeenCalledWith(testPath);
+       });
+     });
  
-   describe('findFiles', () => {
-     it('should find files matching pattern', async () => {
-       const testDir = '/path/to/dir';
-       const testPattern = /\.md$/;
+     describe('findFiles', () => {
+       it('should find files matching pattern', async () => {
+         const testDir = '/path/to/dir';
+         const testPattern = /\.md$/;
  
-       // Setup mocks for readdir to return different values based on path
-       mockReaddir.mockImplementation((dirPath) => {
-         if (dirPath === '/path/to/dir') {
-           return Promise.resolve([
-             { name: 'file1.md', isDirectory: () => false, isFile: () => true },
-             { name: 'file2.txt', isDirectory: () => false, isFile: () => true },
-             { name: 'subdir', isDirectory: () => true, isFile: () => false },
-           ] as unknown as fsTypes.Dirent[]);
-         }
+         // Setup mocks for readdir to return different values based on path
+         mockReaddir.mockImplementation((dirPath) => {
+           if (dirPath === '/path/to/dir') {
+             return Promise.resolve([
+               { name: 'file1.md', isDirectory: () => false, isFile: () => true },
+               { name: 'file2.txt', isDirectory: () => false, isFile: () => true },
+               { name: 'subdir', isDirectory: () => true, isFile: () => false },
+             ] as unknown as fsTypes.Dirent[]);
+           }
  
-         if (dirPath === '/path/to/dir/subdir') {
-           return Promise.resolve([
-             { name: 'file3.md', isDirectory: () => false, isFile: () => true },
-           ] as unknown as fsTypes.Dirent[]);
-         }
+           if (dirPath === '/path/to/dir/subdir') {
+             return Promise.resolve([
+               { name: 'file3.md', isDirectory: () => false, isFile: () => true },
+             ] as unknown as fsTypes.Dirent[]);
+           }
  
-         return Promise.resolve([] as unknown as fsTypes.Dirent[]);
-       });
+           return Promise.resolve([] as unknown as fsTypes.Dirent[]);
+         });
  
-       const result = await findFiles(testDir, testPattern);
-       expect(result).toEqual(['/path/to/dir/file1.md', '/path/to/dir/subdir/file3.md']);
-     });
-   });
+         const result = await findFiles(testDir, testPattern);
+         expect(result).toEqual(['/path/to/dir/file1.md', '/path/to/dir/subdir/file3.md']);
+       });
+     });
  
-   describe('getFileStats', () => {
-     it('should return stats when file exists', async () => {
-       const testPath = '/path/to/file.txt';
-       const mockStats = { size: 100, mtime: new Date() } as fsTypes.Stats;
-       mockStat.mockResolvedValue(mockStats);
+     describe('getFileStats', () => {
+       it('should return stats when file exists', async () => {
+         const testPath = '/path/to/file.txt';
+         const mockStats = { size: 100, mtime: new Date() } as fsTypes.Stats;
+         mockStat.mockResolvedValue(mockStats);
  
-       const result = await getFileStats(testPath);
-       expect(result).toBe(mockStats);
-       expect(mockStat).toHaveBeenCalledWith(testPath);
-     });
+         const result = await getFileStats(testPath);
+         expect(result).toBe(mockStats);
+         expect(mockStat).toHaveBeenCalledWith(testPath);
+       });
  
-     it('should return null when file does not exist', async () => {
-       const testPath = '/path/to/nonexistent.txt';
-       mockStat.mockRejectedValue(new Error('ENOENT'));
+       it('should return null when file does not exist', async () => {
+         const testPath = '/path/to/nonexistent.txt';
+         mockStat.mockRejectedValue(new Error('ENOENT'));
  
-       const result = await getFileStats(testPath);
-       expect(result).toBeNull();
-       expect(mockStat).toHaveBeenCalledWith(testPath);
-     });
-   });
+         const result = await getFileStats(testPath);
+         expect(result).toBeNull();
+         expect(mockStat).toHaveBeenCalledWith(testPath);
+       });
+     });
  
-   describe('safeDeleteFile', () => {
-     it('should delete file and return true when file exists', async () => {
-       const testPath = '/path/to/file.txt';
-       mockUnlink.mockResolvedValue(undefined);
+     describe('safeDeleteFile', () => {
+       it('should delete file and return true when file exists', async () => {
+         const testPath = '/path/to/file.txt';
+         mockUnlink.mockResolvedValue(undefined);
  
-       const result = await safeDeleteFile(testPath);
-       expect(result).toBe(true);
-       expect(mockUnlink).toHaveBeenCalledWith(testPath);
-     });
+         const result = await safeDeleteFile(testPath);
+         expect(result).toBe(true);
+         expect(mockUnlink).toHaveBeenCalledWith(testPath);
+       });
  
-     it('should return false when file does not exist', async () => {
-       const testPath = '/path/to/nonexistent.txt';
-       const error = new Error('File not found') as NodeJS.ErrnoException;
-       error.code = 'ENOENT';
-       mockUnlink.mockRejectedValue(error);
+       it('should return false when file does not exist', async () => {
+         const testPath = '/path/to/nonexistent.txt';
+         const error = new Error('File not found') as NodeJS.ErrnoException;
+         error.code = 'ENOENT';
+         mockUnlink.mockRejectedValue(error);
  
-       const result = await safeDeleteFile(testPath);
-       expect(result).toBe(false);
-       expect(mockUnlink).toHaveBeenCalledWith(testPath);
-     });
+         const result = await safeDeleteFile(testPath);
+         expect(result).toBe(false);
+         expect(mockUnlink).toHaveBeenCalledWith(testPath);
+       });
  
-     it('should throw error for other errors', async () => {
-       const testPath = '/path/to/file.txt';
-       const error = new Error('Permission denied') as NodeJS.ErrnoException;
-       error.code = 'EPERM';
-       mockUnlink.mockRejectedValue(error);
+       it('should throw error for other errors', async () => {
+         const testPath = '/path/to/file.txt';
+         const error = new Error('Permission denied') as NodeJS.ErrnoException;
+         error.code = 'EPERM';
+         mockUnlink.mockRejectedValue(error);
  
-       await expect(safeDeleteFile(testPath)).rejects.toThrow('Permission denied');
-       expect(mockUnlink).toHaveBeenCalledWith(testPath);
+         await expect(safeDeleteFile(testPath)).rejects.toThrow('Permission denied');
+         expect(mockUnlink).toHaveBeenCalledWith(testPath);
+       });
+     });
+   });
+ 
+   describe('FileUtils Class', () => {
+     describe('constructor', () => {
+       it('should initialize with empty base path by default', () => {
+         const fileUtils = new FileUtils();
+         expect(fileUtils).toBeInstanceOf(FileUtils);
+       });
+ 
+       it('should initialize with provided base path', () => {
+         const fileUtils = new FileUtils('/base/path');
+         expect(fileUtils).toBeInstanceOf(FileUtils);
+       });
+     });
+ 
+     describe('instance methods', () => {
+       let fileUtils: FileUtils;
+ 
+       beforeEach(() => {
+         fileUtils = new FileUtils('/base/path');
+       });
+ 
+       describe('ensureDirectory', () => {
+         it('should create directory with resolved path', async () => {
+           const testDir = 'subdir';
+           mockEnsureDir.mockResolvedValue(undefined);
+ 
+           await fileUtils.ensureDirectory(testDir);
+           expect(mockEnsureDir).toHaveBeenCalledWith(path.join('/base/path', testDir));
+         });
+       });
+ 
+       describe('readFile', () => {
+         it('should read file with resolved path', async () => {
+           const testPath = 'file.txt';
+           const testContent = 'file content';
+           mockReadFile.mockResolvedValue(testContent);
+ 
+           const result = await fileUtils.readFile(testPath);
+           expect(result).toBe(testContent);
+           expect(mockReadFile).toHaveBeenCalledWith(path.join('/base/path', testPath), 'utf-8');
+         });
+       });
+ 
+       describe('fileExists', () => {
+         it('should check if file exists with resolved path', async () => {
+           const testPath = 'file.txt';
+           mockAccess.mockResolvedValue(undefined);
+ 
+           const result = await fileUtils.fileExists(testPath);
+           expect(result).toBe(true);
+           expect(mockAccess).toHaveBeenCalledWith(path.join('/base/path', testPath));
+         });
+       });
+ 
+       // Additional instance method tests could be added here
      });
    });
```

---



---

Your Lordship, I've converted the file utility functions into a class-based approach with both static methods and instance methods. The class now allows for creating utility instances with specific base paths, which is useful for working with files relative to a specific directory.

Key changes include:

1. Created a `FileUtils` class with instance methods that respect a base path
2. Added static methods mirroring the instance methods for convenience
3. Kept the individual function exports for backward compatibility
4. Updated the test file to test both static methods and instance methods

The implementation now allows for:

```typescript
// Static usage (backward compatible)
import { readFile } from '@obsidian-magic/core';
const content = await readFile('path/to/file.txt');

// Class-based usage with base path
import { FileUtils } from '@obsidian-magic/core';
const fileUtils = new FileUtils('/base/path');
const content = await fileUtils.readFile('relative/file.txt'); // resolves to /base/path/relative/file.txt
```

This approach enhances the API's flexibility while maintaining compatibility with existing code.

Your Humble Servant, Sebastien

---



---

