<!-- Generated by SpecStory -->

# Test Failures Analysis and Fix Guide (2025-05-23 06:49:37)

_**User**_

Do a comprehensive analysis of the test failures and give me a guide to their fixes.

---

_**Assistant**_



---

Your Grace, I shall conduct a comprehensive analysis of the test failures in your workspace and provide you with a systematic guide to address them.

---



---

Now let me run the tests to see the current state of failures:

---

```bash
cd /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark && nx run-many --target=test --all --parallel=false
```

```
Removing from PATH: /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_
modules/.bin
Added to PATH: /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_modul
es/.bin


> nx run magus-typescript-viewer:test

> vitest run


 RUN  v3.1.3 /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/packages/mag
us-typescript-viewer

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Unhandled Er
rors ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

Vitest caught 1 unhandled error during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure you
r tests are not affected.

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Unhandled E
rror ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
TypeError: Cannot assign to read only property 'version' of object '#<process>'
 ❯ ../../../../../../../../@vite/env:19:23
 ❯ ../../../../../../../../@vite/env:13:22
 ❯ VitestExecutor.runModule ../../node_modules/.pnpm/vite-node@3.1.3_@types+node
@22.15.18_jiti@2.4.2_tsx@4.19.4_yaml@2.7.1/node_modules/vite-node/dist/cl
ient.mjs:354:9
                                                                          ❯ Vite
stExecutor.runModule ../../node_modules/.pnpm/vitest@3.1.3_@types+debug@4.1.12_@
types+node@22.15.18_@vitest+ui@3.1.3_jiti@2.4.2_jsdom@26.1.0_tsx@4
.19.4_yaml@2.7.1/node_modules/vitest/dist/chunks/execute.BpmIjFTD.js:757:17
                                                                          ❯ Vite
stExecutor.directRequest ../../node_modules/.pnpm/vite-node@3.1.3_@types+node@22
.15.18_jiti@2.4.2_tsx@4.19.4_yaml@2.7.1/node_modules/vite-node/dis
t/client.mjs:333:14
                                                                          ❯ proc
ess.processTicksAndRejections node:internal/process/task_queues:105:5
 ❯ VitestExecutor.cachedRequest ../../node_modules/.pnpm/vite-node@3.1.3_@types+
node@22.15.18_jiti@2.4.2_tsx@4.19.4_yaml@2.7.1/node_modules/vite-node/dis
t/client.mjs:168:11
                                                                          ❯ Vite
stExecutor.executeId ../../node_modules/.pnpm/vite-node@3.1.3_@types+node@22.15.
18_jiti@2.4.2_tsx@4.19.4_yaml@2.7.1/node_modules/vite-node/dist/cl
ient.mjs:147:10
                                                                          ❯ crea
teVitestExecutor ../../node_modules/.pnpm/vitest@3.1.3_@types+debug@4.1.12_@type
s+node@22.15.18_@vitest+ui@3.1.3_jiti@2.4.2_jsdom@26.1.0_tsx@4.19.
4_yaml@2.7.1/node_modules/vitest/dist/chunks/execute.BpmIjFTD.js:539:2
                                                                         
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯


 Test Files   (1)
      Tests  no tests
     Errors  1 error
   Start at  06:50:13
   Duration  170ms (transform 8ms, setup 0ms, collect 0ms, tests 0ms, environmen
t 0ms, prepare 0ms)



> nx run magus-mark-cli:test


> @magus-mark/cli@0.1.0 test /Users/khallmark/Desktop/Code/neurotypic-ai/magus-m
ark/apps/cli
> vitest run


 RUN  v3.1.3 /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/cli

 ✓ src/utils/frontmatter.test.ts (8 tests) 7ms

 ❯ src/commands/config-interactive.test.ts [queued]
 ❯ src/commands/config.test.ts [queued]
 ❯ src/commands/stats.test.ts [queued]
 ❯ src/commands/tag.test.ts [queued]
 ❯ src/commands/taxonomy.test.ts [queued]
 ❯ src/commands/test.test.ts [queued]
 ❯ src/index.test.ts 0/2
 ❯ src/types/cli.test.ts [queued]
 ✓ src/index.test.ts (2 tests) 2ms
Interactive Configuration Setup
Using minimal setup mode (essential settings only)

Review your settings:
apiKey: ****7890
defaultModel: "gpt-4"
tagMode: "merge"
Configuration updated successfully!
Next Steps:

1. Run a test command:
   magus-mark test --benchmark

2. Process your first file:
   magus-mark tag ./path/to/conversation.md

3. View command help:
   magus-mark <command> --help Getting Started
Interactive Configuration Setup

Review your settings:
apiKey: ****defg
defaultModel: "gpt-4"
tagMode: "merge"
concurrency: 5
logLevel: "info"
vaultPath: "/valid/path"
enableAnalytics: true
costLimit: 15
outputDir: "./output"
Configuration cancelled.
Interactive Configuration Setup
Using minimal setup mode (essential settings only)
 ✓ src/types/cli.test.ts (10 tests) 6ms

 ❯ src/commands/config.test.ts [queued]
 ❯ src/commands/tag.test.ts [queued]
Error fetching available models: Error: API Error
    at Object.<anonymous> (/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mar
k/apps/cli/src/commands/config-interactive.test.ts:56:54)
    at Object.mockCall (file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus
-mark/node_modules/.pnpm/@vitest+spy@3.1.3/node_modules/@vitest/spy/dist/
index.js:66:15)
                                                                             at
Object.spy [as getAvailableModels] (file:///Users/khallmark/Desktop/Code/neuroty
pic-ai/magus-mark/node_modules/.pnpm/tinyspy@3.0.2/node_modules/ti
nyspy/dist/index.js:45:80)
                                                                             at
getModelChoices (/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/cli
/src/commands/config-interactive.ts:50:39)
    at Object.handler (/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/ap
ps/cli/src/commands/config-interactive.ts:132:34)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/cli/src/comma
nds/config-interactive.test.ts:246:7
    at file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_module
s/.pnpm/@vitest+runner@3.1.3/node_modules/@vitest/runner/dist/index.js:59
6:20
                                                                         
 ❯ src/commands/config.test.ts [queued]
 ❯ src/commands/tag.test.ts [queued]

Review your settings:
apiKey: ****alid
defaultModel: "merge"
tagMode: "gpt-3.5-turbo"
Configuration updated successfully!
Next Steps:

1. Run a test command:
   magus-mark test --benchmark

2. Process your first file:
   magus-mark tag ./path/to/conversation.md

3. View command help:
   magus-mark <command> --help Getting Started
Interactive Configuration Setup
Using minimal setup mode (essential settings only)

Review your settings:
apiKey: ****1234
defaultModel: "gpt-4"
tagMode: "merge"
Configuration updated successfully!
Next Steps:

1. Run a test command:
   magus-mark test --benchmark

2. Process your first file:
   magus-mark tag ./path/to/conversation.md

3. View command help:
   magus-mark <command> --help Getting Started

 ❯ src/commands/config.test.ts [queued]
 ❯ src/commands/tag.test.ts [queued]
Failed to export configuration: __vite_ssr_import_6__.config.getAll is not a fun
ction

 ❯ src/commands/config.test.ts [queued]
 ❯ src/commands/tag.test.ts [queued]
 ✓ src/commands/config-interactive.test.ts (6 tests) 10ms
 ✓ src/commands/taxonomy.test.ts (4 tests) 4ms
 ✓ src/commands/stats.test.ts (5 tests) 28ms
stdout | src/utils/config.test.ts > Config Utility > should get and set values c
orrectly
API key has been updated.

stdout | src/utils/config.test.ts > Config Utility > should get all values corre
ctly, merging with defaults
API key has been updated.

stdout | src/utils/config.test.ts > Config Utility > should check if a key exist
s (including defaults)
API key has been updated.

stdout | src/utils/config.test.ts > Config Utility > should delete a key correct
ly
API key has been updated.

stdout | src/utils/config.test.ts > Config Utility > should clear all keys corre
ctly, reverting to defaults
API key has been updated.

 ❯ src/utils/config.test.ts (9 tests | 1 failed | 1 skipped) 7ms
   ✓ Config Utility > should get and set values correctly 1ms
   ✓ Config Utility > should return undefined for non-existent keys 0ms
   ✓ Config Utility > should return undefined for defaultModel if not set 0ms
   ✓ Config Utility > should return empty string for apiKey if not set 0ms
   ✓ Config Utility > should get all values correctly, merging with defaults 1ms
   ✓ Config Utility > should check if a key exists (including defaults) 0ms
   × Config Utility > should delete a key correctly 3ms
     → expected undefined to be '' // Object.is equality
   ✓ Config Utility > should clear all keys correctly, reverting to defaults 0ms
   ↓ Config Utility > should handle profile configuration

 ❯ src/commands/config.test.ts [queued]
 ❯ src/commands/tag.test.ts [queued]
(node:98009) [DEP0040] DeprecationWarning: The `punycode` module is deprecated.
Please use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)

 ❯ src/commands/config.test.ts [queued]
 ❯ src/commands/tag.test.ts [queued]
stderr | src/utils/cost-manager.test.ts > Cost Manager Utility > should handle c
ost limits
10:50:15 ERROR [cost-manager] Cost limit reached: $0.0479 (limit: $0.02)
10:50:15 WARN [cost-manager] Processing paused due to cost limit. Use --force to
 continue.


 ✓ src/utils/cost-manager.test.ts (6 tests) 4ms
 ✓ src/commands/config.test.ts (2 tests) 4ms
stderr | src/commands/tag.test.ts
10:50:15 WARN [cost-manager] Failed to load usage data: [vitest] No "existsSync"
 export is defined on the "fs-extra" mock. Did you forget to return it fr
om "vi.mock"?
                                                                         If you
need to partially mock a module, you can use "importOriginal" helper inside:


 ✓ src/commands/tag.test.ts (2 tests) 3ms
 ✓ src/commands/test.test.ts (5 tests) 1020ms
   ✓ testCommand > should handle errors from OpenAI API  1001ms

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Failed Test
s 1 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

 FAIL  src/utils/config.test.ts > Config Utility > should delete a key correctly
AssertionError: expected undefined to be '' // Object.is equality

- Expected: 
""

+ Received: 
undefined

 ❯ src/utils/config.test.ts:162:34
    160|     expect(config.has('apiKey')).toBe(false);
    161|     // 'get' should fall back to the default empty string (or env var i
f set, but we clear it in beforeEach)
    162|     expect(config.get('apiKey')).toBe('');
       |                                  ^
    163|     expect(config.save).toHaveBeenCalledTimes(2); // Set and Delete
    164|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed | 10 passed (11)
      Tests  1 failed | 57 passed | 1 skipped (59)
   Start at  06:50:14
   Duration  1.46s (transform 660ms, setup 0ms, collect 1.60s, tests 1.09s, envi
ronment 1ms, prepare 1.18s)

 ELIFECYCLE  Test failed. See above for more details.


> nx run magus-mark-obsidian:test


> @magus-mark/obsidian@0.1.0 test /Users/khallmark/Desktop/Code/neurotypic-ai/ma
gus-mark/apps/obsidian-plugin
> vitest run


 RUN  v3.1.3 /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/obsidia
n-plugin

 ✓ src/types/plugin.test.ts (8 tests) 4ms

 ❯ src/integration.test.ts [queued]
 ❯ src/main.test.ts [queued]
 ❯ src/services/DocumentTagService.test.ts [queued]
 ❯ src/services/KeyManager.test.ts [queued]
 ❯ src/services/TaggingService.test.ts [queued]
 ❯ src/ui/FolderTagModal.test.ts [queued]
 ✓ src/services/DocumentTagService.test.ts (6 tests) 3ms
 ❯ src/ui/TagVisualizationView.test.ts (7 tests | 1 failed) 37ms
   ✓ TagVisualizationView > should return the correct view type 4ms
   ✓ TagVisualizationView > should return the correct display text 3ms
   ✓ TagVisualizationView > should return the correct icon 7ms
   × TagVisualizationView > should render the view on open 9ms
     → expected "spy" to be called at least once
   ✓ TagVisualizationView > should extract tag data from vault 5ms
   ✓ TagVisualizationView > should handle zoom updates 3ms
   ✓ TagVisualizationView > should handle filter updates 6ms
 ✓ src/ui/TagManagementView.test.ts (6 tests) 54ms

 ❯ src/integration.test.ts [queued]
 ❯ src/main.test.ts [queued]
 ❯ src/services/KeyManager.test.ts [queued]
(node:8851) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. P
lease use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)

 ❯ src/integration.test.ts [queued]
 ❯ src/main.test.ts [queued]
 ❯ src/services/KeyManager.test.ts [queued]
(node:8854) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. P
lease use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)
(node:8850) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. P
lease use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)
stderr | src/services/KeyManager.test.ts > KeyManager > loadKey > should return
null and show Notice if local decryption fails
Error loading API key: FileSystemError: Failed to load from local storage: Faile
d to decrypt key: Invalid encrypted key format
    at KeyManager.loadFromLocalStorage (/Users/khallmark/Desktop/Code/neurotypic
-ai/magus-mark/apps/obsidian-plugin/src/services/KeyManager.ts:176:13)
    at KeyManager.loadKey (/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mar
k/apps/obsidian-plugin/src/services/KeyManager.ts:54:19)
    at /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/obsidian-plug
in/src/services/KeyManager.test.ts:133:30
    at file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_module
s/.pnpm/@vitest+runner@3.1.3/node_modules/@vitest/runner/dist/index.js:10
3:11
                                                                             at
file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_modules/.pnpm
/@vitest+runner@3.1.3/node_modules/@vitest/runner/dist/index.js:59
6:26
                                                                             at
file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_modules/.pnpm
/@vitest+runner@3.1.3/node_modules/@vitest/runner/dist/index.js:87
9:20
                                                                             at
new Promise (<anonymous>)
    at runWithTimeout (file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus-
mark/node_modules/.pnpm/@vitest+runner@3.1.3/node_modules/@vitest/runner/
dist/index.js:852:10)
                                                                             at
runTest (file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_modu
les/.pnpm/@vitest+runner@3.1.3/node_modules/@vitest/runner/dist/in
dex.js:1360:12)
                                                                             at
processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'FILE_SYSTEM_ERROR',
  cause: undefined,
  context: undefined,
  recoverable: false,
  path: undefined
}

(node:8858) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. P
lease use a userland alternative instead.
(Use `node --trace-deprecation ...` to show where the warning was created)

 ✓ src/services/KeyManager.test.ts (10 tests) 8ms
stdout | src/ui/FolderTagModal.test.ts > FolderTagModal > Folder Selection > sho
uld handle folder selection
handleFolderClick {
  currentTarget: HTMLDivElement {
    createEl: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    createDiv: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    createSpan: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    createPara: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    setText: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    empty: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    addClass: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    removeClass: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    toggleClass: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    setAttr: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    doc: Document { location: [Getter/Setter], defaultView: [Getter] },
    [Symbol(SameObject caches)]: [Object: null prototype] { dataset: DOMStringMa
p {} }
  }
}

stdout | src/ui/FolderTagModal.test.ts > FolderTagModal > Folder Selection > sho
uld handle folder search
handleFolderSearch {
  target: HTMLInputElement {
    createEl: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    createDiv: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    createSpan: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    createPara: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    setText: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    empty: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    addClass: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    removeClass: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    toggleClass: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    setAttr: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    doc: Document { location: [Getter/Setter], defaultView: [Getter] }
  }
}

stdout | src/ui/FolderTagModal.test.ts > FolderTagModal > Tag Operation > should
 tag selected folder when Tag button is clicked
handleTagButtonClick

stdout | src/ui/FolderTagModal.test.ts > FolderTagModal > Tag Operation > should
 not tag if no folder is selected
handleTagButtonClick

stdout | src/ui/FolderTagModal.test.ts > FolderTagModal > Tag Operation > should
 respect the include subfolders option
handleTagButtonClick

 ❯ src/ui/FolderTagModal.test.ts (9 tests | 8 failed) 155ms
   × FolderTagModal > UI Initialization > should create necessary UI elements on
 open using Setting mock 16ms
     → [Function Setting] is not a spy or a call to a spy!
   × FolderTagModal > UI Initialization > should populate dropdown with folders
12ms
     → expected "spy" to be called at least once
   × FolderTagModal > UI Initialization > should display a list of folders 10ms
     → expected "spy" to be called at least once
   × FolderTagModal > Folder Selection > should handle folder selection 15ms
     → expected false to be true // Object.is equality
   × FolderTagModal > Folder Selection > should handle folder search 18ms
     → expected '' to be 'none' // Object.is equality
   × FolderTagModal > Tag Operation > should tag selected folder when Tag button
 is clicked 9ms
     → expected "spy" to be called with arguments: [ ObjectContaining{…}, true ]

Number of calls: 0

   ✓ FolderTagModal > Tag Operation > should not tag if no folder is selected 49
ms
   × FolderTagModal > Tag Operation > should respect the include subfolders opti
on 16ms
     → expected "spy" to be called with arguments: [ ObjectContaining{…}, false
]

Number of calls: 0

   × FolderTagModal > Cancel Operation > should close modal when Cancel button i
s clicked 11ms
     → Cannot read properties of undefined (reading 'calls')
 ❯ src/services/TaggingService.test.ts (9 tests | 1 failed) 25ms
   ✓ TaggingService > processFile > should process a file successfully 5ms
   ✓ TaggingService > processFile > should handle API errors during processing 1
ms
   ✓ TaggingService > processFile > should handle API key errors during processi
ng 1ms
   ✓ TaggingService > processFile > should handle other errors during processing
 1ms
   ✓ TaggingService > processFile > should return error if service is not config
ured (no API key on plugin) 1ms
   ✓ TaggingService > processFiles > should process multiple files and report pr
ogress 1ms
   ✓ TaggingService > processFiles > should collect results for each file 3ms
   × TaggingService > processFiles > should handle errors for individual files 6
ms
     → expected false to be true // Object.is equality
   ✓ TaggingService > processFiles > should return errors if service is not conf
igured 6ms
stdout | src/main.test.ts > ObsidianMagicPlugin > should load settings on initia
lization
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should load settings on initia
lization
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 14,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > File Tagging Flow > shoul
d tag a file from start to finish successfully
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should initialize services on
load
Before onload, plugin.keyManager: undefined
Before onload, plugin.taggingService: undefined
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > File Tagging Flow > shoul
d tag a file from start to finish successfully
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 14,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should initialize services on
load
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 15,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > File Tagging Flow > shoul
d handle files without existing frontmatter
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > File Tagging Flow > shoul
d handle files without existing frontmatter
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 15,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > File Tagging Flow > shoul
d handle API errors gracefully
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > File Tagging Flow > shoul
d handle API errors gracefully
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 16,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Folder Tagging Flow > sho
uld tag all files in a folder
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Folder Tagging Flow > sho
uld tag all files in a folder
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 17,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Folder Tagging Flow > sho
uld filter non-markdown files when tagging a folder
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Folder Tagging Flow > sho
uld filter non-markdown files when tagging a folder
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 18,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Key Management Flow > sho
uld save API key correctly
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Key Management Flow > sho
uld save API key correctly
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 19,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Key Management Flow > sho
uld store API key in system keychain when configured
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Key Management Flow > sho
uld store API key in system keychain when configured
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 20,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Key Management Flow > sho
uld load API key from appropriate storage
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Key Management Flow > sho
uld load API key from appropriate storage
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 21,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 initialize all required services on load
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 initialize all required services on load
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 22,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 initialize all required services on load
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 initialize all required services on load
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 23,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered

stdout | src/main.test.ts > ObsidianMagicPlugin > should initialize services on
load
onload completed successfully
After onload, plugin.keyManager: <ref *2> KeyManager {
  plugin: <ref *1> ObsidianMagicPlugin {
    on: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    off: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    offref: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    trigger: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    tryTrigger: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    containerEl: undefined,
    addChild: [Function: addChild] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    removeChild: [Function: removeChild] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    register: [Function: register] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerEvent: [Function: registerEvent] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerDomEvent: [Function: registerDomEvent] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerInterval: [Function: registerInterval] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    app: App {
      __esModule: true,
      vault: [Vault],
      workspace: [Workspace],
      metadataCache: [MetadataCache],
      keymap: [Object],
      scope: [Object],
      fileManager: [Object],
      lastEvent: null,
      Setting: [class Setting extends MockEvents],
      isDesktopApp: true,
      createElement: [Function],
      loadLocalStorage: [Function],
      saveLocalStorage: [Function]
    },
    manifest: {
      id: 'test-magus-mark',
      name: 'Test Magus Mark',
      version: '1.0.0',
      minAppVersion: '0.15.0',
      description: 'Test plugin',
      author: 'Test',
      authorUrl: 'https://test.com',
      isDesktopOnly: false
    },
    unregisterEvent: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerHoverLinkSource: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerExtensions: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerMarkdownPostProcessor: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerMarkdownCodeBlockProcessor: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    settings: {
      apiKey: '',
      apiKeyStorage: 'local',
      apiKeyKeychainId: '',
      defaultTagBehavior: 'merge',
      enableAutoSync: false,
      modelPreference: 'gpt-4o',
      showRibbonIcon: true,
      statusBarDisplay: 'always'
    },
    statusBarElement: HTMLDivElement {
      createEl: [Function],
      createDiv: [Function],
      createSpan: [Function],
      createPara: [Function],
      setText: [Function],
      empty: [Function],
      addClass: [Function],
      removeClass: [Function],
      toggleClass: [Function],
      setAttr: [Function],
      doc: [Document]
    },
    taggingService: TaggingService {
      status: [BehaviorSubject],
      notice: [Subject],
      plugin: [Circular *1],
      coreServices: [Object]
    },
    documentTagService: DocumentTagService { plugin: [Circular *1] },
    keyManager: [Circular *2]
  }
}
After onload, plugin.taggingService: <ref *1> TaggingService {
  status: BehaviorSubject { listeners: [], current: 'Magic: Ready' },
  notice: Subject { listeners: [] },
  plugin: <ref *2> ObsidianMagicPlugin {
    on: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    off: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    offref: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    trigger: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    tryTrigger: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    containerEl: undefined,
    addChild: [Function: addChild] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    removeChild: [Function: removeChild] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    register: [Function: register] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerEvent: [Function: registerEvent] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerDomEvent: [Function: registerDomEvent] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerInterval: [Function: registerInterval] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    app: App {
      __esModule: true,
      vault: [Vault],
      workspace: [Workspace],
      metadataCache: [MetadataCache],
      keymap: [Object],
      scope: [Object],
      fileManager: [Object],
      lastEvent: null,
      Setting: [class Setting extends MockEvents],
      isDesktopApp: true,
      createElement: [Function],
      loadLocalStorage: [Function],
      saveLocalStorage: [Function]
    },
    manifest: {
      id: 'test-magus-mark',
      name: 'Test Magus Mark',
      version: '1.0.0',
      minAppVersion: '0.15.0',
      description: 'Test plugin',
      author: 'Test',
      authorUrl: 'https://test.com',
      isDesktopOnly: false
    },
    unregisterEvent: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerHoverLinkSource: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerExtensions: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerMarkdownPostProcessor: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerMarkdownCodeBlockProcessor: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    settings: {
      apiKey: '',
      apiKeyStorage: 'local',
      apiKeyKeychainId: '',
      defaultTagBehavior: 'merge',
      enableAutoSync: false,
      modelPreference: 'gpt-4o',
      showRibbonIcon: true,
      statusBarDisplay: 'always'
    },
    statusBarElement: HTMLDivElement {
      createEl: [Function],
      createDiv: [Function],
      createSpan: [Function],
      createPara: [Function],
      setText: [Function],
      empty: [Function],
      addClass: [Function],
      removeClass: [Function],
      toggleClass: [Function],
      setAttr: [Function],
      doc: [Document]
    },
    taggingService: [Circular *1],
    documentTagService: DocumentTagService { plugin: [Circular *2] },
    keyManager: KeyManager { plugin: [Circular *2] }
  },
  coreServices: {
    openAIClient: OpenAIClient {
      config: [Object],
      client: null,
      encodingCache: {},
      pricingConfig: [Object]
    },
    taxonomyManager: TaxonomyManager {
      taxonomy: [Object],
      customDomains: Set(0) {},
      customSubdomains: Map(0) {},
      customContextualTags: Set(0) {}
    },
    taggingService: TaggingService {
      openAIClient: [OpenAIClient],
      options: [Object],
      taxonomyManager: [TaxonomyManager]
    },
    documentProcessor: DocumentProcessor { frontmatterProcessor: [FrontmatterPro
cessor] },
    batchProcessingService: BatchProcessingService {
      taggingService: [TaggingService],
      options: [Object]
    }
  }
}
After onload, plugin.documentTagService: <ref *2> DocumentTagService {
  plugin: <ref *1> ObsidianMagicPlugin {
    on: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    off: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    offref: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    trigger: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    tryTrigger: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    containerEl: undefined,
    addChild: [Function: addChild] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    removeChild: [Function: removeChild] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    register: [Function: register] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerEvent: [Function: registerEvent] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerDomEvent: [Function: registerDomEvent] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerInterval: [Function: registerInterval] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    app: App {
      __esModule: true,
      vault: [Vault],
      workspace: [Workspace],
      metadataCache: [MetadataCache],
      keymap: [Object],
      scope: [Object],
      fileManager: [Object],
      lastEvent: null,
      Setting: [class Setting extends MockEvents],
      isDesktopApp: true,
      createElement: [Function],
      loadLocalStorage: [Function],
      saveLocalStorage: [Function]
    },
    manifest: {
      id: 'test-magus-mark',
      name: 'Test Magus Mark',
      version: '1.0.0',
      minAppVersion: '0.15.0',
      description: 'Test plugin',
      author: 'Test',
      authorUrl: 'https://test.com',
      isDesktopOnly: false
    },
    unregisterEvent: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerHoverLinkSource: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerExtensions: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerMarkdownPostProcessor: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    registerMarkdownCodeBlockProcessor: [Function: spy] {
      getMockName: [Function (anonymous)],
      mockName: [Function (anonymous)],
      mockClear: [Function (anonymous)],
      mockReset: [Function (anonymous)],
      mockRestore: [Function (anonymous)],
      getMockImplementation: [Function (anonymous)],
      mockImplementation: [Function (anonymous)],
      mockImplementationOnce: [Function (anonymous)],
      withImplementation: [Function: withImplementation],
      mockReturnThis: [Function (anonymous)],
      mockReturnValue: [Function (anonymous)],
      mockReturnValueOnce: [Function (anonymous)],
      mockResolvedValue: [Function (anonymous)],
      mockResolvedValueOnce: [Function (anonymous)],
      mockRejectedValue: [Function (anonymous)],
      mockRejectedValueOnce: [Function (anonymous)]
    },
    settings: {
      apiKey: '',
      apiKeyStorage: 'local',
      apiKeyKeychainId: '',
      defaultTagBehavior: 'merge',
      enableAutoSync: false,
      modelPreference: 'gpt-4o',
      showRibbonIcon: true,
      statusBarDisplay: 'always'
    },
    statusBarElement: HTMLDivElement {
      createEl: [Function],
      createDiv: [Function],
      createSpan: [Function],
      createPara: [Function],
      setText: [Function],
      empty: [Function],
      addClass: [Function],
      removeClass: [Function],
      toggleClass: [Function],
      setAttr: [Function],
      doc: [Document]
    },
    taggingService: TaggingService {
      status: [BehaviorSubject],
      notice: [Subject],
      plugin: [Circular *1],
      coreServices: [Object]
    },
    documentTagService: [Circular *2],
    keyManager: KeyManager { plugin: [Circular *1] }
  }
}

stdout | src/main.test.ts > ObsidianMagicPlugin > should add ribbon icon based o
n settings
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should add ribbon icon based o
n settings
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 16,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should add ribbon icon based o
n settings
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should add ribbon icon based o
n settings
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 17,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should register views
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should register views
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 18,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should add commands
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should add commands
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 19,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should add setting tab
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should add setting tab
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 20,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should add status bar item bas
ed on settings
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should add status bar item bas
ed on settings
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 21,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should add status bar item bas
ed on settings
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should add status bar item bas
ed on settings
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 22,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should handle onunload correct
ly
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/main.test.ts > ObsidianMagicPlugin > should handle onunload correct
ly
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 23,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/main.test.ts > ObsidianMagicPlugin > should handle onunload correct
ly
Unloading Magus Mark plugin


 ❯ src/main.test.ts (8 tests | 1 failed) 46ms
   × ObsidianMagicPlugin > should load settings on initialization 9ms
     → [Function loadData] is not a spy or a call to a spy!
   ✓ ObsidianMagicPlugin > should initialize services on load 10ms
   ✓ ObsidianMagicPlugin > should add ribbon icon based on settings 5ms
   ✓ ObsidianMagicPlugin > should register views 5ms
   ✓ ObsidianMagicPlugin > should add commands 4ms
   ✓ ObsidianMagicPlugin > should add setting tab 4ms
   ✓ ObsidianMagicPlugin > should add status bar item based on settings 6ms
   ✓ ObsidianMagicPlugin > should handle onunload correctly 3ms
stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 clean up resources on unload
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 clean up resources on unload
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 24,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 clean up resources on unload
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 clean up resources on unload
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 25,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 clean up resources on unload
Unloading Magus Mark plugin

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 load and apply settings properly
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 load and apply settings properly
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 26,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 load and apply settings properly
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stderr | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 load and apply settings properly
Error loading API key: FileSystemError: Failed to load from local storage: Faile
d to decrypt key: Invalid encrypted key format
    at KeyManager.loadFromLocalStorage (/Users/khallmark/Desktop/Code/neurotypic
-ai/magus-mark/apps/obsidian-plugin/src/services/KeyManager.ts:176:13)
    at KeyManager.loadKey (/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mar
k/apps/obsidian-plugin/src/services/KeyManager.ts:54:19)
    at ObsidianMagicPlugin.onload (/Users/khallmark/Desktop/Code/neurotypic-ai/m
agus-mark/apps/obsidian-plugin/src/main.ts:53:36)
    at processTicksAndRejections (node:internal/process/task_queues:105:5)
    at /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/obsidian-plug
in/src/integration.test.ts:294:7
    at file:///Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_module
s/.pnpm/@vitest+runner@3.1.3/node_modules/@vitest/runner/dist/index.js:59
6:20 {
                                                                           code:
 'FILE_SYSTEM_ERROR',
  cause: undefined,
  context: undefined,
  recoverable: false,
  path: undefined
}

stdout | src/integration.test.ts > Integration Tests > Plugin Lifecycle > should
 load and apply settings properly
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 27,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should create a KeyManager instance
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should create a KeyManager instance
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 28,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should create a TaggingService instance
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should create a TaggingService instance
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 29,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should create a DocumentTagService instance
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should create a DocumentTagService instance
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 30,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should have an accessible vault
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should have an accessible vault
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 31,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should handle folder tagging
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > Service Initialization >
should handle folder tagging
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 32,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

stdout | src/integration.test.ts > Integration Tests > FileHandling > should hav
e services available for file processing
[Magus Mark] Loading plugin...
[DEBUG] onload step 1: About to call loadSettings

stdout | src/integration.test.ts > Integration Tests > FileHandling > should hav
e services available for file processing
[DEBUG] onload step 2: loadSettings completed
[DEBUG] onload step 3: KeyManager created
[DEBUG] onload step 4: apiKey loaded: false
[DEBUG] onload step 5: TaggingService created
[Magus Mark] TaggingService initialized.
registerEditorExtension [
  ViewPlugin {
    id: 33,
    create: [Function (anonymous)],
    domEventHandlers: undefined,
    domEventObservers: undefined,
    extension: [ [FacetProvider], [FacetProvider] ]
  }
]
[DEBUG] onload step 6: DocumentTagService created
[DEBUG] onload step 7: SettingTab added
[DEBUG] onload step 8: Views registered
[DEBUG] onload step 9: Ribbon icon added
[DEBUG] onload step 10: Status bar added
addCommand {
  id: 'open-tag-management',
  name: 'Open Tag Management',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'open-tag-visualization',
  name: 'Open Tag Visualization',
  callback: [AsyncFunction: callback]
}
addCommand {
  id: 'tag-current-file',
  name: 'Tag Current File',
  checkCallback: [Function: checkCallback]
}
addCommand {
  id: 'tag-folder',
  name: 'Tag Folder',
  callback: [Function: callback]
}
[DEBUG] onload step 11: Commands added
[DEBUG] onload step 12: Context menu registered
registerMarkdownPostProcessor [Function (anonymous)] undefined

 ✓ src/integration.test.ts (17 tests) 82ms

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Failed Test
s 11 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

 FAIL  src/main.test.ts > ObsidianMagicPlugin > should load settings on initiali
zation
TypeError: [Function loadData] is not a spy or a call to a spy!
 ❯ src/main.test.ts:37:29
     35|   it('should load settings on initialization', async () => {
     36|     await plugin.onload();
     37|     expect(plugin.loadData).toHaveBeenCalled();
       |                             ^
     38|     expect(plugin.settings).toEqual(DEFAULT_SETTINGS);
     39|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/11]�
��
                                                                         
 FAIL  src/services/TaggingService.test.ts > TaggingService > processFiles > sho
uld handle errors for individual files
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 ❯ src/services/TaggingService.test.ts:299:34
    297| 
    298|       expect(results).toHaveLength(filesWithError.length);
    299|       expect(results[0]?.isOk()).toBe(true);
       |                                  ^
    300|       expect(results[1]?.isFail()).toBe(true);
    301|       if (results[1]?.isFail()) {

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯���⎯⎯⎯⎯⎯⎯⎯⎯[2/11
]⎯
                                                                         
 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > UI Initialization > shou
ld create necessary UI elements on open using Setting mock
TypeError: [Function Setting] is not a spy or a call to a spy!
 ❯ src/ui/FolderTagModal.test.ts:72:23
     70| 
     71|       // Verify Setting constructor was called (for folder selection, s
earch, etc.)
     72|       expect(Setting).toHaveBeenCalled();
       |                       ^
     73|       expect(vi.mocked(Setting)).toHaveBeenCalledTimes(4);
     74|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[3/11]⎯

 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > UI Initialization > shou
ld populate dropdown with folders
AssertionError: expected "spy" to be called at least once
 ❯ src/ui/FolderTagModal.test.ts:78:47
     76|     it('should populate dropdown with folders', () => {
     77|       modal.onOpen();
     78|       expect(testApp.vault.getAllLoadedFiles).toHaveBeenCalled();
       |                                               ^
     79|     });
     80| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[4/11]⎯

 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > UI Initialization > shou
ld display a list of folders
AssertionError: expected "spy" to be called at least once
 ❯ src/ui/FolderTagModal.test.ts:88:47
     86|       modal.onOpen();
     87| 
     88|       expect(testApp.vault.getAllLoadedFiles).toHaveBeenCalled();
       |                                               ^
     89|       const listCreateEl = mockFolderList.createEl as any;
     90|       expect(listCreateEl).toHaveBeenCalledWith('div', expect.objectCon
taining({ text: 'folder1' }));

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[5/11]⎯

 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > Folder Selection > shoul
d handle folder selection
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 ❯ src/ui/FolderTagModal.test.ts:110:58
    108| 
    109|       privateModal.handleFolderClick({ currentTarget: folderItem1 } as
unknown as MouseEvent);
    110|       expect(folderItem1.classList.contains('selected')).toBe(true);
       |                                                          ^
    111|       expect(folderItem2.classList.contains('selected')).toBe(false);
    112|       expect(privateModal.selectedFolderPath).toBe('folder1');

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[6/11]⎯

 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > Folder Selection > shoul
d handle folder search
AssertionError: expected '' to be 'none' // Object.is equality

- Expected
+ Received

- none

 ❯ src/ui/FolderTagModal.test.ts:138:39
    136|       privateModal.handleFolderSearch({ target: searchInput } as unknow
n as Event);
    137|       expect(items[0]?.style.display).toBe('');
    138|       expect(items[1]?.style.display).toBe('none');
       |                                       ^
    139|       expect(items[2]?.style.display).toBe('none');
    140| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[7/11]⎯

 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > Tag Operation > should t
ag selected folder when Tag button is clicked
AssertionError: expected "spy" to be called with arguments: [ ObjectContaining{…
}, true ]

Number of calls: 0

 ❯ src/ui/FolderTagModal.test.ts:166:32
    164|       privateModal.handleTagButtonClick();
    165| 
    166|       expect(onSubmitCallback).toHaveBeenCalledWith(expect.objectContai
ning({ path: 'folder1' }), true);
       |                                ^
    167|       expect(privateModal.close).toHaveBeenCalled();
    168|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[8/11]⎯

 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > Tag Operation > should r
espect the include subfolders option
AssertionError: expected "spy" to be called with arguments: [ ObjectContaining{…
}, false ]

Number of calls: 0

 ❯ src/ui/FolderTagModal.test.ts:195:32
    193|       privateModal.handleTagButtonClick();
    194| 
    195|       expect(onSubmitCallback).toHaveBeenCalledWith(expect.objectContai
ning({ path: 'folder1' }), false);
       |                                ^
    196|     });
    197|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[9/11]⎯

 FAIL  src/ui/FolderTagModal.test.ts > FolderTagModal > Cancel Operation > shoul
d close modal when Cancel button is clicked
TypeError: Cannot read properties of undefined (reading 'calls')
 ❯ src/ui/FolderTagModal.test.ts:206:47
    204| 
    205|       // Find the cancel button setting (should be the 4th Setting call
)
    206|       const settingCalls = vi.mocked(Setting).mock.calls;
       |                                               ^
    207|       expect(settingCalls.length).toBeGreaterThanOrEqual(4);
    208| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[10/11]⎯

 FAIL  src/ui/TagVisualizationView.test.ts > TagVisualizationView > should rende
r the view on open
AssertionError: expected "spy" to be called at least once
 ❯ src/ui/TagVisualizationView.test.ts:146:33
    144|     await view.onOpen();
    145| 
    146|     expect(mockContainer.empty).toHaveBeenCalled();
       |                                 ^
    147|   });
    148| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[11/11]⎯


 Test Files  4 failed | 5 passed (9)
      Tests  11 failed | 69 passed (80)
   Start at  06:50:16
   Duration  1.19s (transform 540ms, setup 0ms, collect 1.89s, tests 415ms, envi
ronment 4.05s, prepare 860ms)

 ELIFECYCLE  Test failed. See above for more details.


   ✔  nx run magus-mark-core:build
   ✔  nx run magus-mark-cli:build
   ✔  nx run magus-mark-obsidian:build
   ✔  nx run magus-typescript-viewer:build
   ✔  nx run magus-mark-core:test
   ✖  nx run magus-typescript-viewer:test
   ✖  nx run magus-mark-cli:test
   ✖  nx run magus-mark-obsidian:test

————————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————

 NX   Ran target test for 4 projects and 4 tasks they depend on (24s)

   ✔  5/8 succeeded [1 read from cache]

   ✖  3/8 targets failed, including the following:

      - nx run magus-typescript-viewer:test
      - nx run magus-mark-cli:test
      - nx run magus-mark-obsidian:test




Task completed in 27.718 total:
  User time: 47.287
  System time: 10.395
  CPU usage: 208%
  Max memory: 2289808 KB

```

---

Now let me run just the VS Code tests to see if there are additional failures:

---

```bash
nx run magus-mark-vscode:test:integration
```

```
in magus-mark ➜ nx run magus-mark-vscode:test:integration

> nx run magus-mark-core:build  [existing outputs match the cache, left as is]


> nx run magus-mark-vscode:build

> vsce package

Executing prepublish script 'npm run vscode:prepublish'...

> magus-mark-vscode@0.1.0 vscode:prepublish
> pnpm run package


> magus-mark-vscode@0.1.0 package /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/vscode
> pnpm run check-types && pnpm run lint && tsx esbuild.config.ts --production


> magus-mark-vscode@0.1.0 check-types /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/vscode
> tsc --noEmit

src/cursor/MCPServer.ts:12:15 - error TS2300: Duplicate identifier 'Result'.

12 import type { Result, SmartContextProvider } from '../services/SmartContextProvider';
                 ~~~~~~

src/cursor/MCPServer.ts:15:15 - error TS2300: Duplicate identifier 'Result'.

15 import type { Result } from '@magus-mark/core/errors/Result';
                 ~~~~~~

src/cursor/MCPServer.ts:28:37 - error TS6133: 'defaultCode' is declared but its value is never read.

28 function toAppError(error: unknown, defaultCode?: string): Error {
                                       ~~~~~~~~~~~

src/cursor/MCPServer.ts:128:11 - error TS6133: '_knowledgeGraphView' is declared but its value is never read.

128   private _knowledgeGraphView?: KnowledgeGraphView;
              ~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:576:36 - error TS4111: Property 'type' comes from an index signature, so it must be accessed with ['type'].

576         const searchType = (params.type as string) || 'semantic';
                                       ~~~~

src/cursor/MCPServer.ts:577:15 - error TS6133: 'limit' is declared but its value is never read.

577         const limit = params.limit! || 10;
                  ~~~~~

src/cursor/MCPServer.ts:598:23 - error TS6133: 'params' is declared but its value is never read.

598       execute: async (params: ToolParameters) => {
                          ~~~~~~

src/cursor/MCPServer.ts:618:7 - error TS2345: Argument of type '{ name: string; description: string; inputSchema: { type: string; properties: { content: 
{ type: string; description: string; }; language: { type: string; description: string; }; analysisType: { type: string; enum: string[]; description: stri
ng; default: string; }; }; required: string[]; }; }' is not assignable to parameter of type 'string'.

618       {
          ~
619         name: 'analyze_code_intelligence',
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
... 
640         },
    ~~~~~~~~~~
641       },
    ~~~~~~~

src/cursor/MCPServer.ts:647:7 - error TS2345: Argument of type '{ name: string; description: string; inputSchema: { type: string; properties: { tags: { t
ype: string; items: { type: string; }; description: string; }; includeHierarchy: { type: string; description: string; default: boolean; }; }; required: s
tring[]; }; }' is not assignable to parameter of type 'string'.

647       {
          ~
648         name: 'discover_tag_relationships',
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
... 
665         },
    ~~~~~~~~~~
666       },
    ~~~~~~~

src/cursor/MCPServer.ts:672:7 - error TS2345: Argument of type '{ name: string; description: string; inputSchema: { type: string; properties: { clusterCo
unt: { type: string; description: string; default: number; }; method: { type: string; enum: string[]; description: string; default: string; }; }; }; }' i
s not assignable to parameter of type 'string'.

672       {
          ~
673         name: 'cluster_files_intelligently',
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
... 
690         },
    ~~~~~~~~~~
691       },
    ~~~~~~~

src/cursor/MCPServer.ts:697:7 - error TS2345: Argument of type '{ name: string; description: string; inputSchema: { type: string; properties: { descripti
on: { type: string; description: string; }; language: { type: string; description: string; }; contextType: { type: string; enum: string[]; description: s
tring; }; }; required: string[]; }; }' is not assignable to parameter of type 'string'.

697       {
          ~
698         name: 'generate_contextual_snippets',
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
... 
718         },
    ~~~~~~~~~~
719       },
    ~~~~~~~

src/cursor/MCPServer.ts:860:17 - error TS6133: 'handleKnowledgeGraphQuery' is declared but its value is never read.

860   private async handleKnowledgeGraphQuery(params: KnowledgeQueryParams): Promise<Result<ToolResult>> {
                    ~~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:860:89 - error TS2304: Cannot find name 'ToolResult'.

860   private async handleKnowledgeGraphQuery(params: KnowledgeQueryParams): Promise<Result<ToolResult>> {
                                                                                            ~~~~~~~~~~

src/cursor/MCPServer.ts:862:17 - error TS2339: Property '_vaultIntegrationService' does not exist on type 'MCPServer'.

862       if (!this._vaultIntegrationService) {
                    ~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:863:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

863         return Result.fail(new Error('Vault integration service not available'));
                   ~~~~~~

src/cursor/MCPServer.ts:866:38 - error TS2339: Property '_vaultIntegrationService' does not exist on type 'MCPServer'.

866       const notesResult = await this._vaultIntegrationService.getAllNotes();
                                         ~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:868:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

868         return Result.fail(notesResult.error);
                   ~~~~~~

src/cursor/MCPServer.ts:889:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

889       return Result.ok({
                 ~~~~~~

src/cursor/MCPServer.ts:907:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

907       return Result.fail(new Error(`Knowledge graph query failed: ${error}`));
                 ~~~~~~

src/cursor/MCPServer.ts:911:17 - error TS6133: 'handleContextAnalysis' is declared but its value is never read.

911   private async handleContextAnalysis(params: ContextAnalysisParams): Promise<Result<ToolResult>> {
                    ~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:911:86 - error TS2304: Cannot find name 'ToolResult'.

911   private async handleContextAnalysis(params: ContextAnalysisParams): Promise<Result<ToolResult>> {
                                                                                         ~~~~~~~~~~

src/cursor/MCPServer.ts:914:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

914         return Result.fail(new Error('Smart context provider not available'));
                   ~~~~~~

src/cursor/MCPServer.ts:917:38 - error TS2339: Property '_vaultIntegrationService' does not exist on type 'MCPServer'.

917       const notesResult = await this._vaultIntegrationService?.getAllNotes();
                                         ~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:919:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

919         return Result.fail(new Error('Could not retrieve notes for context analysis'));
                   ~~~~~~

src/cursor/MCPServer.ts:925:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

925         return Result.fail(suggestions.error);
                   ~~~~~~

src/cursor/MCPServer.ts:940:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

940       return Result.ok({
                 ~~~~~~

src/cursor/MCPServer.ts:949:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

949       return Result.fail(new Error(`Context analysis failed: ${error}`));
                 ~~~~~~

src/cursor/MCPServer.ts:953:80 - error TS2304: Cannot find name 'ToolResult'.

953   private async handleCodeAnalysis(params: CodeAnalysisParams): Promise<Result<ToolResult>> {
                                                                                   ~~~~~~~~~~

src/cursor/MCPServer.ts:956:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

956         return Result.fail(new Error('Smart context provider not available'));
                   ~~~~~~

src/cursor/MCPServer.ts:965:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

965         return Result.fail(snippetsResult.error);
                   ~~~~~~

src/cursor/MCPServer.ts:977:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

977       return Result.ok({
                 ~~~~~~

src/cursor/MCPServer.ts:986:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

986       return Result.fail(new Error(`Code analysis failed: ${error}`));
                 ~~~~~~

src/cursor/MCPServer.ts:993:22 - error TS2304: Cannot find name 'ToolResult'.

993   }): Promise<Result<ToolResult>> {
                         ~~~~~~~~~~

src/cursor/MCPServer.ts:995:17 - error TS2339: Property '_vaultIntegrationService' does not exist on type 'MCPServer'.

995       if (!this._vaultIntegrationService) {
                    ~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:996:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

996         return Result.fail(new Error('Vault integration service not available'));
                   ~~~~~~

src/cursor/MCPServer.ts:999:38 - error TS2339: Property '_vaultIntegrationService' does not exist on type 'MCPServer'.

999       const notesResult = await this._vaultIntegrationService.getAllNotes();
                                         ~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:1001:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1001         return Result.fail(notesResult.error);
                    ~~~~~~

src/cursor/MCPServer.ts:1011:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1011       return Result.ok({
                  ~~~~~~

src/cursor/MCPServer.ts:1029:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1029       return Result.fail(new Error(`Tag relationship discovery failed: ${error}`));
                  ~~~~~~

src/cursor/MCPServer.ts:1033:107 - error TS2304: Cannot find name 'ToolResult'.

1033   private async handleFilesClustering(params: { clusterCount?: number; method?: string }): Promise<Result<ToolResult>> {
                                                                                                               ~~~~~~~~~~

src/cursor/MCPServer.ts:1035:17 - error TS2339: Property '_vaultIntegrationService' does not exist on type 'MCPServer'.

1035       if (!this._vaultIntegrationService) {
                     ~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:1036:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1036         return Result.fail(new Error('Vault integration service not available'));
                    ~~~~~~

src/cursor/MCPServer.ts:1039:38 - error TS2339: Property '_vaultIntegrationService' does not exist on type 'MCPServer'.

1039       const notesResult = await this._vaultIntegrationService.getAllNotes();
                                          ~~~~~~~~~~~~~~~~~~~~~~~~

src/cursor/MCPServer.ts:1041:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1041         return Result.fail(notesResult.error);
                    ~~~~~~

src/cursor/MCPServer.ts:1049:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1049       return Result.ok({
                  ~~~~~~

src/cursor/MCPServer.ts:1067:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1067       return Result.fail(new Error(`File clustering failed: ${error}`));
                  ~~~~~~

src/cursor/MCPServer.ts:1075:22 - error TS2304: Cannot find name 'ToolResult'.

1075   }): Promise<Result<ToolResult>> {
                          ~~~~~~~~~~

src/cursor/MCPServer.ts:1078:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1078         return Result.fail(new Error('Smart context provider not available'));
                    ~~~~~~

src/cursor/MCPServer.ts:1102:16 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1102         return Result.fail(snippetsResult.error);
                    ~~~~~~

src/cursor/MCPServer.ts:1105:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1105       return Result.ok({
                  ~~~~~~

src/cursor/MCPServer.ts:1124:14 - error TS2693: 'Result' only refers to a type, but is being used as a value here.

1124       return Result.fail(new Error(`Contextual snippet generation failed: ${error}`));
                  ~~~~~~

src/cursor/MCPServer.ts:1229:11 - error TS6133: 'results' is declared but its value is never read.

1229     const results: { title: string; path: string; relevance: number; reason: string }[] = [];
               ~~~~~~~

src/cursor/MCPServer.ts:1311:9 - error TS2322: Type 'string | undefined' is not assignable to type 'string'.
  Type 'undefined' is not assignable to type 'string'.

1311         tag1,
             ~~~~

  src/cursor/MCPServer.ts:1285:28
    1285     const relationships: { tag1: string; tag2: string; strength: number; coOccurrence: number }[] = [];
                                    ~~~~
    The expected type comes from property 'tag1' which is declared here on type '{ tag1: string; tag2: string; strength: number; coOccurrence: number; }'

src/cursor/MCPServer.ts:1312:9 - error TS2322: Type 'string | undefined' is not assignable to type 'string'.
  Type 'undefined' is not assignable to type 'string'.

1312         tag2,
             ~~~~

  src/cursor/MCPServer.ts:1285:42
    1285     const relationships: { tag1: string; tag2: string; strength: number; coOccurrence: number }[] = [];
                                                  ~~~~
    The expected type comes from property 'tag2' which is declared here on type '{ tag1: string; tag2: string; strength: number; coOccurrence: number; }'

src/cursor/MCPServer.ts:1323:5 - error TS6133: 'relationships' is declared but its value is never read.

1323     relationships: { tag1: string; tag2: string; strength: number }[]
         ~~~~~~~~~~~~~

src/cursor/MCPServer.ts:1338:24 - error TS2538: Type 'undefined' cannot be used as an index type.

1338         if (!hierarchy[parent]) {
                            ~~~~~~

src/cursor/MCPServer.ts:1339:21 - error TS2538: Type 'undefined' cannot be used as an index type.

1339           hierarchy[parent] = [];
                         ~~~~~~

src/cursor/MCPServer.ts:1341:19 - error TS2538: Type 'undefined' cannot be used as an index type.

1341         hierarchy[parent].push(tag);
                       ~~~~~~

src/cursor/MCPServer.ts:1353:11 - error TS6133: 'clusters' is declared but its value is never read.

1353     const clusters: { name: string; files: string[]; tags: string[]; description: string }[] = [];
               ~~~~~~~~

src/cursor/MCPServer.ts:1376:30 - error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
  Type 'undefined' is not assignable to type 'string'.

1376         if (!tagClusters.has(primaryTag)) {
                                  ~~~~~~~~~~

src/cursor/MCPServer.ts:1377:27 - error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
  Type 'undefined' is not assignable to type 'string'.

1377           tagClusters.set(primaryTag, []);
                               ~~~~~~~~~~

src/cursor/MCPServer.ts:1379:25 - error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
  Type 'undefined' is not assignable to type 'string'.

1379         tagClusters.get(primaryTag)!.push(note);
                             ~~~~~~~~~~

src/cursor/MCPServer.ts:1399:11 - error TS6133: 'clusters' is declared but its value is never read.

1399     const clusters: { name: string; files: string[]; tags: string[]; description: string }[] = [];
               ~~~~~~~~

src/extension.ts:768:35 - error TS18048: 'vaultService' is possibly 'undefined'.

768         const notesResult = await vaultService.getAllNotes();
                                      ~~~~~~~~~~~~

src/extension.ts:770:37 - error TS2341: Property 'value' is private and only accessible within class 'Result<T, E>'.

770           const notes = notesResult.value;
                                        ~~~~~

src/extension.ts:773:39 - error TS18048: 'vaultService' is possibly 'undefined'.

773           const relationships = await vaultService.getTagRelationships();
                                          ~~~~~~~~~~~~

src/extension.ts:775:65 - error TS2341: Property 'value' is private and only accessible within class 'Result<T, E>'.

775             knowledgeGraphView!.updateData(notes, relationships.value);
                                                                    ~~~~~

src/extension.ts:820:95 - error TS2341: Property 'value' is private and only accessible within class 'Result<T, E>'.

820           const suggestions = await smartContextProvider!.provideSmartSuggestions(notesResult.value, true);
                                                                                                  ~~~~~

src/extension.ts:890:21 - error TS2339: Property 'isErr' does not exist on type 'Result<TaggedNote[], Error>'.

890     if (notesResult.isErr()) {
                        ~~~~~

src/extension.ts:895:111 - error TS2341: Property 'value' is private and only accessible within class 'Result<T, E>'.

895     const relatedFiles = await smartContextProvider.suggestRelatedFiles(editor.document.fileName, notesResult.value);
                                                                                                                  ~~~~~

src/extension.ts:899:34 - error TS2341: Property 'value' is private and only accessible within class 'Result<T, E>'.

899         const note = notesResult.value.find((n) => n.path === filePath);
                                     ~~~~~

src/extension.ts:899:46 - error TS7006: Parameter 'n' implicitly has an 'any' type.

899         const note = notesResult.value.find((n) => n.path === filePath);
                                                 ~

src/extension.ts:952:39 - error TS4111: Property 'description' comes from an index signature, so it must be accessed with ['description'].

952             label: (snippet.metadata?.description as string) || 'Generated Snippet',
                                          ~~~~~~~~~~~

src/services/SmartContextProvider.ts:94:20 - error TS6133: '_tagEngine' is declared but its value is never read.

94   private readonly _tagEngine: TagEngine;
                      ~~~~~~~~~~

src/services/SmartContextProvider.ts:97:11 - error TS6133: '_lastAnalysis' is declared but its value is never read.

97   private _lastAnalysis: ContextAnalysis | null = null;
             ~~~~~~~~~~~~~

src/services/SmartContextProvider.ts:379:39 - error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
  Type 'undefined' is not assignable to type 'string'.

379         const confidence = parseFloat(confidenceStr);
                                          ~~~~~~~~~~~~~

src/services/SmartContextProvider.ts:385:24 - error TS18048: 'reasoning' is possibly 'undefined'.

385             reasoning: reasoning.trim(),
                           ~~~~~~~~~

src/services/SmartContextProvider.ts:405:18 - error TS18048: 'code' is possibly 'undefined'.

405         content: code.trim(),
                     ~~~~

src/services/SmartContextProvider.ts:407:20 - error TS18048: 'reasoning' is possibly 'undefined'.

407         reasoning: reasoning.trim(),
                       ~~~~~~~~~

src/services/SmartContextProvider.ts:409:24 - error TS18048: 'description' is possibly 'undefined'.

409           description: description.trim(),
                           ~~~~~~~~~~~

src/services/VaultIntegrationService.ts:578:40 - error TS2341: Property 'value' is private and only accessible within class 'Result<T, E>'.

578           allNotes.push(...notesResult.value);
                                           ~~~~~

src/services/VaultIntegrationService.ts:701:23 - error TS2339: Property 'isErr' does not exist on type 'Result<TaggedNote[], Error>'.

701       if (notesResult.isErr()) {
                          ~~~~~

src/services/VaultIntegrationService.ts:702:40 - error TS2341: Property 'error' is private and only accessible within class 'Result<T, E>'.

702         return Result.fail(notesResult.error);
                                           ~~~~~

src/services/VaultIntegrationService.ts:705:33 - error TS2341: Property 'value' is private and only accessible within class 'Result<T, E>'.

705       const notes = notesResult.value;
                                    ~~~~~

src/views/KnowledgeGraph.ts:168:48 - error TS4111: Property 'path' comes from an index signature, so it must be accessed with ['path'].

168     if (node.type === 'file' && node.metadata?.path) {
                                                   ~~~~

src/views/KnowledgeGraph.ts:170:49 - error TS4111: Property 'path' comes from an index signature, so it must be accessed with ['path'].

170       const uri = vscode.Uri.file(node.metadata.path as string);
                                                    ~~~~

src/views/KnowledgeGraph.ts:221:74 - error TS18048: 'filter.minConnections' is possibly 'undefined'.

221       filteredNodes = filteredNodes.filter((node) => node.connections >= filter.minConnections);
                                                                             ~~~~~~~~~~~~~~~~~~~~~

src/views/KnowledgeGraph.ts:232:55 - error TS4111: Property 'tags' comes from an index signature, so it must be accessed with ['tags'].

232       .filter((n) => n.type === 'file' && n.metadata?.tags?.includes(tag))
                                                          ~~~~

src/views/KnowledgeGraph.ts:232:61 - error TS2339: Property 'includes' does not exist on type '{}'.

232       .filter((n) => n.type === 'file' && n.metadata?.tags?.includes(tag))
                                                                ~~~~~~~~

src/views/KnowledgeGraph.ts:235:34 - error TS4111: Property 'path' comes from an index signature, so it must be accessed with ['path'].

235         description: n.metadata?.path as string,
                                     ~~~~

src/views/KnowledgeGraph.ts:250:29 - error TS6133: 'webview' is declared but its value is never read.

250   private getHtmlForWebview(webview: vscode.Webview): string {
                                ~~~~~~~

src/views/SmartSuggestions.ts:36:5 - error TS6133: 'context' is declared but its value is never read.

36     context: vscode.WebviewViewResolveContext,
       ~~~~~~~

src/views/SmartSuggestions.ts:37:5 - error TS6133: 'token' is declared but its value is never read.

37     token: vscode.CancellationToken
       ~~~~~

src/views/SmartSuggestions.ts:160:25 - error TS18048: 'frontmatter' is possibly 'undefined'.

160       const tagsMatch = frontmatter.match(/^tags:\s*(\[.*?\]|\S.*?)$/m);
                            ~~~~~~~~~~~

src/views/SmartSuggestions.ts:166:37 - error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'string'.
  Type 'undefined' is not assignable to type 'string'.

166           existingTags = JSON.parse(tagsMatch[1]);
                                        ~~~~~~~~~~~~

src/views/SmartSuggestions.ts:168:26 - error TS2532: Object is possibly 'undefined'.

168           existingTags = tagsMatch[1].split(',').map((t) => t.trim());
                             ~~~~~~~~~~~~

src/views/SmartSuggestions.ts:195:43 - error TS4111: Property 'path' comes from an index signature, so it must be accessed with ['path'].

195     const filePath = suggestion.metadata?.path as string;
                                              ~~~~

src/views/SmartSuggestions.ts:266:29 - error TS6133: 'webview' is declared but its value is never read.

266   private getHtmlForWebview(webview: vscode.Webview): string {
                                ~~~~~~~


Found 98 errors in 6 files.

Errors  Files
    63  src/cursor/MCPServer.ts:12
    10  src/extension.ts:768
     7  src/services/SmartContextProvider.ts:94
     4  src/services/VaultIntegrationService.ts:578
     7  src/views/KnowledgeGraph.ts:168
     7  src/views/SmartSuggestions.ts:36
 ELIFECYCLE  Command failed with exit code 2.
 ELIFECYCLE  Command failed with exit code 2.
npm error Lifecycle script `vscode:prepublish` failed with error:
npm error code 2
npm error path /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/vscode
npm error workspace magus-mark-vscode@0.1.0
npm error location /Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/vscode
npm error command failed
npm error command sh -c pnpm run package
 ERROR  npm failed with exit code 2

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

 NX   Ran target test:integration for project magus-mark-vscode and 2 task(s) they depend on (3s)

   ✖  1/2 failed
   ✔  1/2 succeeded [1 read from cache]


06:50:33 with khallmark at Voyager …                                                                                                               6.0s 
in magus-mark ➜
```

---

Now I have a comprehensive view of all the test failures across the workspace. Let me create a detailed analysis and guide to fix them.

Your Grace, I have conducted a thorough analysis of the test failures across your workspace. Here is my comprehensive assessment and systematic guide to resolve them:

## **Test Failure Analysis Summary**

### **Overview**
- **Total Failed Projects**: 4 out of 8
- **Projects with Issues**: 
  - `magus-typescript-viewer`: Vitest configuration issue
  - `magus-mark-cli`: 1 test failure + minor warnings
  - `magus-mark-obsidian`: 11 test failures (multiple categories)
  - `magus-mark-vscode`: 98 TypeScript compilation errors (blocking tests)

## **Category 1: Environment/Configuration Issues**

### **A. Vitest Configuration Error (magus-typescript-viewer)**
**Issue**: `TypeError: Cannot assign to read only property 'version' of object '#<process>'`

**Root Cause**: Vitest trying to mock or modify Node.js process properties in readonly mode.

**Fix**:
1. Check if the project has custom Vitest configuration attempting to mock `process.version`
2. Either remove the mock or use proper Vitest environment configuration
3. Add to `vitest.config.ts`:
```typescript
export default defineConfig({
  test: {
    environment: 'node',
    globals: false, // Avoid global pollution
  },
});
```

### **B. Deprecation Warnings**
**Issue**: `punycode` module deprecation warnings

**Fix**: Update dependencies that rely on the deprecated `punycode` module:
```bash
pnpm update
```

## **Category 2: Mock/Spy Configuration Issues**

### **A. CLI Test Failures**
**Issue**: Config utility test expecting empty string but getting `undefined`

**Location**: `apps/cli/src/utils/config.test.ts:162`

**Fix**: Update the test expectation or config implementation:
```typescript
// Either fix the test expectation:
expect(config.get('apiKey')).toBe(undefined); // If undefined is correct

// Or fix the config implementation to return empty string:
get(key: string): string {
  return this.store[key] ?? this.defaults[key] ?? '';
}
```

### **B. Obsidian Plugin Mock Issues**
**Multiple Issues**: Mock classes not properly implementing spy interfaces

**Locations**: 
- `FolderTagModal.test.ts` - Setting class not mocked
- `TagVisualizationView.test.ts` - Container methods not called
- `main.test.ts` - `loadData` not properly mocked

**Universal Fix Strategy**:
```typescript
// In test setup, ensure proper mocking:
vi.mock('obsidian', () => ({
  Plugin: vi.fn().mockImplementation(() => ({
    loadData: vi.fn().mockResolvedValue({}),
    saveData: vi.fn().mockResolvedValue(undefined),
    // ... other methods
  })),
  Setting: vi.fn().mockImplementation((containerEl) => ({
    setName: vi.fn().mockReturnThis(),
    setDesc: vi.fn().mockReturnThis(),
    addButton: vi.fn().mockReturnThis(),
    // ... other methods
  })),
}));
```

## **Category 3: TypeScript Compilation Errors (VS Code)**

### **A. Duplicate Import Issues**
**Issue**: `Result` type imported twice from different locations

**Fix**: Consolidate imports in `src/cursor/MCPServer.ts`:
```typescript
// Remove duplicate Result import
import type { SmartContextProvider } from '../services/SmartContextProvider';
import { Result } from '@magus-mark/core/errors/Result';
```

### **B. Unused Variables/Parameters**
**Multiple Locations**: Variables declared but never used

**Fix Strategy**:
1. Remove truly unused variables
2. For intentionally unused parameters, prefix with underscore:
```typescript
function handler(_unusedParam: string, usedParam: number) {
  return usedParam * 2;
}
```

### **C. Type Safety Issues**
**Issues**: Unsafe property access, undefined values

**Fix Examples**:
```typescript
// Before (unsafe):
const searchType = (params.type as string) || 'semantic';

// After (safe):
const searchType = params['type'] as string || 'semantic';

// Before (unsafe):
if (!hierarchy[parent]) {

// After (safe):  
if (parent && !hierarchy[parent]) {
```

## **Category 4: Service Integration Issues**

### **A. Missing Service References**
**Issue**: `_vaultIntegrationService` property missing

**Fix**: Add proper service initialization in MCPServer constructor:
```typescript
constructor(
  private _smartContextProvider: SmartContextProvider,
  private _vaultIntegrationService: VaultIntegrationService // Add this
) {
  // ...
}
```

### **B. Result Pattern Misuse**
**Issue**: Using `Result` as value instead of type

**Fix**: Import and use Result properly:
```typescript
import { Result } from '@magus-mark/core/errors/Result';

// Use it correctly:
return Result.fail(new Error('message'));
return Result.ok(data);
```

## **Systematic Fix Plan**

### **Phase 1: Environment Fixes (1-2 hours)**
1. Fix Vitest configuration in `magus-typescript-viewer`
2. Update dependencies to resolve deprecation warnings
3. Verify Node.js environment compatibility

### **Phase 2: TypeScript Compilation (2-3 hours)**
1. Fix all import issues in VS Code project
2. Remove/prefix unused variables
3. Add missing type annotations
4. Fix unsafe property access patterns

### **Phase 3: Mock System Overhaul (3-4 hours)**
1. Standardize mock implementations across Obsidian tests
2. Ensure all Obsidian API classes properly implement spy interfaces
3. Fix Result pattern usage consistency
4. Update test expectations to match actual behavior

### **Phase 4: Service Integration (2-3 hours)**
1. Add missing service dependencies
2. Fix service initialization patterns
3. Ensure proper error handling throughout

### **Priority Order**
1. **VS Code TypeScript errors** (blocks everything)
2. **Mock configuration issues** (multiple test failures)
3. **Environment configuration** (foundational)
4. **Minor test expectation fixes** (refinement)

### **Tools and Commands for Implementation**
```bash
# Run specific project tests:
nx test magus-mark-vscode
nx test magus-mark-obsidian
nx test magus-mark-cli

# Type checking:
nx run magus-mark-vscode:check-types

# Lint fixes:
nx run-many --target=lint:fix --all
```

This systematic approach will resolve all test failures while establishing better patterns for future test reliability.

Your Humble Servant, Sebastien

---

_**User**_

I want you to focus on a comprehensive overhaul of the mock system for the obsidian plugin. Start from first principles and fix it. 

---

_**Assistant**_



---

Your Grace, I shall conduct a comprehensive overhaul of the Obsidian plugin mock system from first principles. Let me begin by examining the current state and then systematically rebuild it.

---

<details>
            <summary>Listed directory apps/obsidian-plugin/src/__mocks__ • **2** results</summary>
        
| Name |
|-------|
| 📄 `obsidian.ts` |
| 📁 `obsidian` |

</details>

---

<details>
            <summary>Listed directory apps/obsidian-plugin/src/__mocks__/obsidian • **14** results</summary>
        
| Name |
|-------|
| 📄 `Component.ts` |
| 📄 `Vault.ts` |
| 📄 `MetadataCache.ts` |
| 📄 `Setting.ts` |
| 📄 `Modal.ts` |
| 📄 `MockObsidianElement.ts` |
| 📄 `WorkspaceLeaf.ts` |
| 📄 `ItemView.ts` |
| 📄 `Workspace.ts` |
| 📄 `FileMockHelpers.ts` |
| 📄 `Plugin.ts` |
| 📄 `MockEvents.ts` |
| 📄 `PluginSettingTab.ts` |
| 📄 `DataAdapter.ts` |

</details>

---

Now let me examine the current main mock file and some key components:

---

Read file: apps/obsidian-plugin/src/__mocks__/obsidian.ts

---

Read file: apps/obsidian-plugin/src/__mocks__/obsidian/Plugin.ts

---

Read file: apps/obsidian-plugin/src/__mocks__/obsidian/Setting.ts

---

Now let me examine some of the failing tests to understand the issues:

---

Read file: apps/obsidian-plugin/src/ui/FolderTagModal.test.ts

---

Read file: apps/obsidian-plugin/src/main.test.ts

---

Now I understand the core issues with the mock system. Let me create a comprehensive overhaul from first principles:

## **Root Problems Identified:**

1. **Setting class is not properly spied**: Tests expect `Setting` to be a spy but it's a real class
2. **Plugin methods like `loadData` aren't automatically spied**: Tests expect spies but get real methods
3. **Mock elements don't behave like real DOM**: CSS class manipulation and style changes don't work properly
4. **Inconsistent spy setup**: Some methods are spied, others aren't, leading to unpredictable behavior

## **First Principles Mock System Design:**

---

```diff
  
  import { createMockObsidianElement } from '../testing/createMockObsidianElement';
- import { MetadataCache } from './obsidian/MetadataCache';
- import { Modal } from './obsidian/Modal';
- import { Setting } from './obsidian/Setting';
- import { Vault } from './obsidian/Vault';
- import { Workspace } from './obsidian/Workspace';
  
  import type {
```

```diff
  
  import type { MockObsidianElement } from './obsidian/MockObsidianElement';
+ 
+ // ===== FIRST PRINCIPLES MOCK DESIGN =====
+ //
+ // 1. ALL exported classes are spy-constructors that can be mocked
+ // 2. ALL methods on instances are pre-spied for immediate testing
+ // 3. ALL DOM-like behavior is properly simulated
+ // 4. ALL plugin lifecycle methods are spied by default
+ //
+ // ==========================================
  
  // Mock type for ObsidianMagicPlugin to avoid circular dependency
```

```diff
  }
  
- // Mock implementations for Obsidian file system classes
+ // ===== FILE SYSTEM MOCKS =====
+ 
  export class TAbstractFile {
    path: string;
```

```diff
  }
  
- export { Modal };
- 
- // Mock Notice class for UI notifications - make it a function that can be spied on
- export const Notice: new (
-   message: string,
-   timeout?: number
- ) => {
-   message: string;
-   timeout: number;
-   setMessage: (message: string) => any;
-   hide: () => void;
- } = vi.fn().mockImplementation(function (this: any, message: string, timeout = 5000) {
+ // ===== ENHANCED MOCK ELEMENTS WITH CSS BEHAVIOR =====
+ 
+ class MockCSSStyleDeclaration {
+   private _styles: Record<string, string> = {};
+ 
+   get display(): string {
+     return this._styles.display || '';
+   }
+ 
+   set display(value: string) {
+     this._styles.display = value;
+   }
+ 
+   getPropertyValue(property: string): string {
+     return this._styles[property] || '';
+   }
+ 
+   setProperty(property: string, value: string): void {
+     this._styles[property] = value;
+   }
+ }
+ 
+ class MockClassList {
+   private _classes: Set<string> = new Set();
+ 
+   add(className: string): void {
+     this._classes.add(className);
+   }
+ 
+   remove(className: string): void {
+     this._classes.delete(className);
+   }
+ 
+   contains(className: string): boolean {
+     return this._classes.has(className);
+   }
+ 
+   toggle(className: string): boolean {
+     if (this._classes.has(className)) {
+       this._classes.delete(className);
+       return false;
+     } else {
+       this._classes.add(className);
+       return true;
+     }
+   }
+ 
+   toString(): string {
+     return Array.from(this._classes).join(' ');
+   }
+ }
+ 
+ // Enhanced MockObsidianElement with proper DOM-like behavior
+ class EnhancedMockObsidianElement extends createMockObsidianElement('div') {
+   style: MockCSSStyleDeclaration;
+   classList: MockClassList;
+   dataset: Record<string, string>;
+ 
+   constructor(tagName: string) {
+     super();
+     this.style = new MockCSSStyleDeclaration();
+     this.classList = new MockClassList();
+     this.dataset = {};
+     
+     // Override addClass to update classList
+     this.addClass = vi.fn((className: string) => {
+       this.classList.add(className);
+       return this;
+     });
+ 
+     // Override removeClass to update classList  
+     this.removeClass = vi.fn((className: string) => {
+       this.classList.remove(className);
+       return this;
+     });
+ 
+     // Override toggleClass to update classList
+     this.toggleClass = vi.fn((className: string) => {
+       this.classList.toggle(className);
+       return this;
+     });
+   }
+ }
+ 
+ // ===== SPIED NOTICE CLASS =====
+ 
+ export const Notice = vi.fn().mockImplementation(function (this: any, message: string, timeout = 5000) {
    this.message = message;
    this.timeout = timeout;
```

```diff
  
    this.hide = vi.fn();
+   return this;
  });
+ 
+ // ===== SPIED MODAL CLASS =====
+ 
+ export const Modal = vi.fn().mockImplementation(function (this: any, app: AppType) {
+   this.app = app;
+   this.containerEl = new EnhancedMockObsidianElement('div');
+   this.contentEl = new EnhancedMockObsidianElement('div');
+   this.titleEl = new EnhancedMockObsidianElement('div');
+   this.modalEl = new EnhancedMockObsidianElement('div');
+   this.scope = {
+     register: vi.fn(),
+     unregister: vi.fn(),
+   };
+ 
+   // All modal methods are spies
+   this.open = vi.fn();
+   this.close = vi.fn();
+   this.onOpen = vi.fn();
+   this.onClose = vi.fn();
+   
+   return this;
+ });
+ 
+ // ===== SPIED SETTING CLASS =====
+ 
+ export const Setting = vi.fn().mockImplementation(function (this: any, containerEl: any) {
+   // Create realistic mock elements
+   this.settingEl = new EnhancedMockObsidianElement('div');
+   this.nameEl = new EnhancedMockObsidianElement('div');
+   this.descEl = new EnhancedMockObsidianElement('div');
+   this.controlEl = new EnhancedMockObsidianElement('div');
+   this.infoEl = new EnhancedMockObsidianElement('div');
+   this.components = [];
+ 
+   // All Setting methods are spies that return this for chaining
+   this.setName = vi.fn(() => this);
+   this.setDesc = vi.fn(() => this);
+   this.setClass = vi.fn(() => this);
+   this.setHeading = vi.fn(() => this);
+   this.setInfo = vi.fn(() => this);
+   this.setTooltip = vi.fn(() => this);
+   this.setDisabled = vi.fn(() => this);
+   this.clear = vi.fn(() => this);
+   this.then = vi.fn((cb: (setting: any) => void) => {
+     cb(this);
+     return this;
+   });
+ 
+   // Component creators with realistic spy behavior
+   this.addText = vi.fn((cb: (component: any) => void) => {
+     const component = {
+       inputEl: new EnhancedMockObsidianElement('input'),
+       getValue: vi.fn(() => ''),
+       setValue: vi.fn(() => component),
+       setPlaceholder: vi.fn(() => component),
+       onChange: vi.fn(() => component),
+       onChanged: vi.fn(),
+       setDisabled: vi.fn(() => component),
+       then: vi.fn(() => component),
+     };
+     this.components.push(component);
+     cb(component);
+     return this;
+   });
+ 
+   this.addSearch = vi.fn((cb: (component: any) => void) => {
+     const component = {
+       inputEl: new EnhancedMockObsidianElement('input'),
+       clearButtonEl: new EnhancedMockObsidianElement('div'),
+       getValue: vi.fn(() => ''),
+       setValue: vi.fn(() => component),
+       setPlaceholder: vi.fn(() => component),
+       onChange: vi.fn(() => component),
+       onChanged: vi.fn(),
+       setDisabled: vi.fn(() => component),
+       then: vi.fn(() => component),
+     };
+     this.components.push(component);
+     cb(component);
+     return this;
+   });
+ 
+   this.addToggle = vi.fn((cb: (component: any) => void) => {
+     const component = {
+       toggleEl: new EnhancedMockObsidianElement('input'),
+       getValue: vi.fn(() => false),
+       setValue: vi.fn(() => component),
+       onChange: vi.fn(() => component),
+       onClick: vi.fn(() => component),
+       setTooltip: vi.fn(() => component),
+       setDisabled: vi.fn(() => component),
+       then: vi.fn(() => component),
+     };
+     this.components.push(component);
+     cb(component);
+     return this;
+   });
+ 
+   this.addButton = vi.fn((cb: (component: any) => void) => {
+     const component = {
+       buttonEl: new EnhancedMockObsidianElement('button'),
+       setButtonText: vi.fn(() => component),
+       setClass: vi.fn(() => component),
+       setCta: vi.fn(() => component),
+       setIcon: vi.fn(() => component),
+       setTooltip: vi.fn(() => component),
+       removeCta: vi.fn(() => component),
+       setWarning: vi.fn(() => component),
+       onClick: vi.fn((callback: () => void) => {
+         // Store callback for manual triggering in tests
+         component._clickCallback = callback;
+         return component;
+       }),
+       setDisabled: vi.fn(() => component),
+       then: vi.fn(() => component),
+       // Helper method for tests to trigger clicks
+       triggerClick: () => {
+         if (component._clickCallback) {
+           component._clickCallback();
+         }
+       },
+     };
+     this.components.push(component);
+     cb(component);
+     return this;
+   });
+ 
+   this.addDropdown = vi.fn((cb: (component: any) => void) => {
+     const component = {
+       selectEl: new EnhancedMockObsidianElement('select'),
+       getValue: vi.fn(() => ''),
+       setValue: vi.fn(() => component),
+       addOption: vi.fn(() => component),
+       addOptions: vi.fn(() => component),
+       onChange: vi.fn(() => component),
+       setDisabled: vi.fn(() => component),
+       then: vi.fn(() => component),
+     };
+     this.components.push(component);
+     cb(component);
+     return this;
+   });
+ 
+   this.addExtraButton = vi.fn((cb: (component: any) => void) => {
+     const component = {
+       extraSettingsEl: new EnhancedMockObsidianElement('button'),
+       setDisabled: vi.fn(() => component),
+       setTooltip: vi.fn(() => component),
+       setIcon: vi.fn(() => component),
+       onClick: vi.fn(() => component),
+       then: vi.fn(() => component),
+     };
+     this.components.push(component);
+     cb(component);
+     return this;
+   });
+ 
+   // Additional component methods as spies
+   this.addTextArea = vi.fn(() => this);
+   this.addMomentFormat = vi.fn(() => this);
+   this.addSlider = vi.fn(() => this);
+   this.addColorPicker = vi.fn(() => this);
+   this.addProgressBar = vi.fn(() => this);
+ 
+   // Simulate adding to container
+   if (containerEl && containerEl.appendChild) {
+     containerEl.appendChild(this.settingEl);
+   }
+ 
+   return this;
+ });
+ 
+ // ===== UTILITY FUNCTIONS =====
  
  export function normalizePath(path: string): string {
    return path.replace(/\\/g, '/');
  }
+ 
  export const Platform = {
    isDesktop: true,
```

```diff
    resourcePathPrefix: 'app://mock-id/',
  };
+ 
+ // ===== ENHANCED APP CLASS =====
+ 
  export class App implements AppType {
    __esModule = true;
```

```diff
    isDesktopApp: boolean = Platform.isDesktopApp;
    createElement: Mock<(tagName: string) => MockObsidianElement>;
+   loadLocalStorage: Mock<() => Promise<null>>;
+   saveLocalStorage: Mock<() => void>;
  
    constructor() {
+     // Import actual mock implementations
+     const { Vault } = require('./obsidian/Vault');
+     const { Workspace } = require('./obsidian/Workspace');
+     const { MetadataCache } = require('./obsidian/MetadataCache');
+ 
      this.vault = new Vault() as VaultType;
      this.workspace = new Workspace() as WorkspaceType;
      this.metadataCache = new MetadataCache() as MetadataCacheType;
      this.Setting = Setting;
-     this.createElement = vi.fn((tagName: string) => createMockObsidianElement(tagName as any));
+     this.createElement = vi.fn((tagName: string) => new EnhancedMockObsidianElement(tagName));
  
      this.keymap = {
        pushScope: vi.fn(),
        popScope: vi.fn(),
      };
+     
      this.scope = {
        register: vi.fn<
```

```diff
        unregister: vi.fn(),
      };
+     
      this.fileManager = {
        getNewFileParent: vi.fn().mockReturnValue(new TFolder()),
```

```diff
        getAvailablePathForAttachment: vi.fn().mockResolvedValue(''),
      };
+     
      this.lastEvent = null;
-   }
- 
-   loadLocalStorage: Mock<() => Promise<null>> = vi.fn().mockResolvedValue(null);
-   saveLocalStorage: Mock<() => void> = vi.fn();
- }
- 
- export function createMockApp(): App {
-   return new App();
- }
- 
- export function createMockedPlugin(): MockObsidianMagicPlugin {
-   const mockApp = createMockApp();
-   return {
-     app: mockApp,
-     settings: {},
-   };
- }
- 
- // --- Add common Obsidian UI components to the mock ---
+     this.loadLocalStorage = vi.fn().mockResolvedValue(null);
+     this.saveLocalStorage = vi.fn();
+   }
+ }
+ 
+ // ===== ENHANCED EVENTS CLASS =====
  
  export class Events implements EventsType {
```

```diff
    registerInterval: Mock<(id: number) => number> = vi.fn((id) => id || window.setInterval(vi.fn(), 1000));
  }
+ 
+ // ===== ENHANCED COMPONENT CLASS =====
  
  export class Component extends Events implements ComponentType {
```

```diff
    onload: Mock<() => void> = vi.fn();
    unload: Mock<() => void> = vi.fn();
-   onunload: Mock<() => void> = vi.fn();
    addChild: <T extends ComponentType>(component: T) => T = vi.fn(
      <T extends ComponentType>(component: T): T => component
```

```diff
      (el: EventTarget, type: string, callback: (evt: any) => any, options?: boolean | AddEventListenerOptions) => void
    > = vi.fn();
+   registerInterval: Mock<(id: number) => number> = vi.fn((id) => id);
  }
+ 
+ // ===== ENHANCED VIEW CLASSES =====
  
  export class View extends Component {
```

```diff
      super();
      this.leaf = leaf;
-     this.app = (leaf as any).app;
-     this.containerEl = createMockObsidianElement('div');
-     this.scope = {
-       register: vi.fn(),
-       unregister: vi.fn(),
-     } as ScopeType;
+     this.app = (leaf as any).workspace?.app || new App();
+     this.containerEl = new EnhancedMockObsidianElement('div');
+     this.scope = this.app.scope;
    }
  
-   // Define abstract methods that child classes should override
    getViewType(): string {
      return 'mock-view';
```

```diff
  
    onResize(): void {
-     // Default implementation
+     // Mock implementation
    }
  
    onHeaderMenu(_menu: any): void {
-     // Default implementation
+     // Mock implementation
    }
  
    async onOpen(): Promise<void> {
-     // Default implementation
+     // Mock implementation
    }
  
    async onClose(): Promise<void> {
-     // Default implementation
+     // Mock implementation
    }
  
```

```diff
  
    setEphemeralState(_state: any): void {
-     // Default implementation
+     // Mock implementation
    }
  }
```

```diff
    constructor(leaf: WorkspaceLeafType) {
      super(leaf);
-     this.contentEl = createMockObsidianElement('div');
-     if (this.containerEl && this.contentEl) {
-       this.containerEl.appendChild(this.contentEl);
-     }
- 
-     // ItemView does NOT override any methods - let child classes provide their own implementations
-   }
- }
- 
- // --- End common Obsidian UI components ---
- 
- export { WorkspaceLeaf } from './obsidian/WorkspaceLeaf';
- export { Plugin } from './obsidian/Plugin';
- export { PluginSettingTab } from './obsidian/PluginSettingTab';
- export { Setting } from './obsidian/Setting';
- export { Workspace } from './obsidian/Workspace';
+     this.contentEl = new EnhancedMockObsidianElement('div');
+   }
+ }
+ 
+ // ===== ENHANCED PLUGIN CLASS WITH AUTO-SPIED METHODS =====
+ 
+ export const Plugin = vi.fn().mockImplementation(function (this: any, app: AppType, manifest: any) {
+   // Inherit from Component
+   Object.setPrototypeOf(this, Component.prototype);
+   Component.call(this);
+ 
+   this.app = app;
+   this.manifest = manifest;
+ 
+   // AUTO-SPY ALL PLUGIN LIFECYCLE METHODS
+   this.onload = vi.fn().mockResolvedValue(undefined);
+   this.onunload = vi.fn();
+   this.loadData = vi.fn().mockResolvedValue({});
+   this.saveData = vi.fn().mockResolvedValue(undefined);
+ 
+   // AUTO-SPY ALL PLUGIN REGISTRATION METHODS
+   this.addCommand = vi.fn((command: any) => {
+     console.log('addCommand', command);
+     return command;
+   });
+   this.registerView = vi.fn();
+   this.addSettingTab = vi.fn();
+   this.addRibbonIcon = vi.fn(() => new EnhancedMockObsidianElement('div'));
+   this.addStatusBarItem = vi.fn(() => new EnhancedMockObsidianElement('div'));
+   this.registerEditorExtension = vi.fn((extension: unknown) => {
+     console.log('registerEditorExtension', extension);
+   });
+   this.removeCommand = vi.fn((commandId: string) => {
+     console.log('removeCommand', commandId);
+   });
+   this.unregisterEvent = vi.fn((event: string, callback: () => void) => {
+     console.log('unregisterEvent', event, callback);
+   });
+   this.registerHoverLinkSource = vi.fn((id: string, source: any) => {
+     console.log('registerHoverLinkSource', id, source);
+   });
+   this.registerExtensions = vi.fn((extensions: unknown[]) => {
+     console.log('registerExtensions', extensions);
+   });
+   this.registerMarkdownPostProcessor = vi.fn((processor: any, sortOrder?: number) => {
+     console.log('registerMarkdownPostProcessor', processor, sortOrder);
+     return processor;
+   });
+   this.registerMarkdownCodeBlockProcessor = vi.fn((language: string, handler: any, sortOrder?: number) => {
+     console.log('registerMarkdownCodeBlockProcessor', language, handler, sortOrder);
+     return handler;
+   });
+   this.registerObsidianProtocolHandler = vi.fn((action: string, handler: any) => {
+     console.log('registerObsidianProtocolHandler', action, handler);
+   });
+   this.registerEditorSuggest = vi.fn((suggest: any) => {
+     console.log('registerEditorSuggest', suggest);
+   });
+   this.onUserEnable = vi.fn(() => {
+     console.log('onUserEnable called');
+   });
+ 
+   return this;
+ });
+ 
+ // ===== FACTORY FUNCTIONS =====
+ 
+ export function createMockApp(): App {
+   return new App();
+ }
+ 
+ export function createMockedPlugin(): MockObsidianMagicPlugin {
+   const mockApp = createMockApp();
+   return {
+     app: mockApp,
+     settings: {},
+   };
+ }
+ 
+ // Enhanced createMockObsidianElement function
+ export function createMockObsidianElement<T extends keyof HTMLElementTagNameMap>(
+   tagName: T,
+   options?: { cls?: string; text?: string; type?: string; [key: string]: any }
+ ): MockObsidianElement<T> {
+   const element = new EnhancedMockObsidianElement(tagName) as any;
+   
+   if (options?.cls) {
+     element.classList.add(options.cls);
+   }
+   if (options?.text) {
+     element.textContent = options.text;
+   }
+   if (options?.type && tagName === 'input') {
+     element.type = options.type;
+   }
+   
+   // Add any additional properties
+   Object.keys(options || {}).forEach(key => {
+     if (key !== 'cls' && key !== 'text' && key !== 'type') {
+       element[key] = options![key];
+     }
+   });
+ 
+   return element;
+ }
  
```

---

Now I need to create a test-specific plugin factory that properly extends our new enhanced Plugin class:

---

```diff
  import { vi } from 'vitest';
  
- import type { ElementAttrs, MockObsidianElement } from '../__mocks__/obsidian/MockObsidianElement';
+ import type { MockObsidianElement } from '../__mocks__/obsidian/MockObsidianElement';
  
- // Create a mock element of the given tag, augmented with Obsidian helpers
- 
- export function createMockObsidianElement<K extends keyof HTMLElementTagNameMap>(
-   tag: K,
-   attrs?: ElementAttrs
- ): MockObsidianElement<K> {
-   const el = document.createElement(tag) as MockObsidianElement<K>;
-   if (attrs) {
-     if (attrs.cls) el.className = Array.isArray(attrs.cls) ? attrs.cls.join(' ') : attrs.cls;
-     if (attrs.text) el.textContent = typeof attrs.text === 'string' ? attrs.text : (attrs.text.textContent ?? '');
-     if (attrs.textContent) el.textContent = attrs.textContent;
-   }
-   // Attach Obsidian-specific helpers
-   el.createEl = vi.fn(
-     <L extends keyof HTMLElementTagNameMap>(childTag: L, childAttrs?: ElementAttrs): MockObsidianElement<L> => {
-       const childEl = createMockObsidianElement<L>(childTag, childAttrs);
-       el.appendChild(childEl);
-       return childEl;
-     }
-   );
-   el.createDiv = vi.fn((divAttrs?: ElementAttrs): MockObsidianElement<'div'> => {
-     const divEl = createMockObsidianElement('div', divAttrs);
-     el.appendChild(divEl);
-     return divEl;
-   });
-   el.createSpan = vi.fn((spanAttrs?: ElementAttrs): MockObsidianElement<'span'> => {
-     const spanEl = createMockObsidianElement('span', spanAttrs);
-     el.appendChild(spanEl);
-     return spanEl;
-   });
-   el.createPara = vi.fn((paraAttrs?: ElementAttrs): MockObsidianElement<'p'> => {
-     const paraEl = createMockObsidianElement('p', paraAttrs);
-     el.appendChild(paraEl);
-     return paraEl;
-   });
-   el.setText = vi.fn((text: string) => {
-     el.textContent = text;
-   });
-   el.empty = vi.fn(() => {
-     el.innerHTML = '';
-   });
-   el.addClass = vi.fn();
-   el.removeClass = vi.fn();
-   el.toggleClass = vi.fn();
-   el.setAttr = vi.fn();
-   el.doc = document; // Add doc property
- 
-   return el;
+ // Enhanced mock element factory that properly simulates DOM behavior
+ export function createMockObsidianElement<T extends keyof HTMLElementTagNameMap>(
+   tagName: T,
+   options?: { cls?: string; text?: string; type?: string; [key: string]: any }
+ ): MockObsidianElement<T> {
+   const element = {
+     tagName: tagName.toUpperCase(),
+     textContent: options?.text || '',
+     innerHTML: options?.text || '',
+     value: '',
+     checked: false,
+     disabled: false,
+     type: options?.type || '',
+     id: '',
+     
+     // Enhanced DOM-like behavior
+     style: {
+       display: '',
+       visibility: '',
+       opacity: '',
+       getPropertyValue: vi.fn((prop: string) => ''),
+       setProperty: vi.fn(),
+     },
+     
+     classList: {
+       _classes: new Set<string>(),
+       add: vi.fn((className: string) => {
+         (element.classList as any)._classes.add(className);
+       }),
+       remove: vi.fn((className: string) => {
+         (element.classList as any)._classes.delete(className);
+       }),
+       contains: vi.fn((className: string) => {
+         return (element.classList as any)._classes.has(className);
+       }),
+       toggle: vi.fn((className: string) => {
+         const classes = (element.classList as any)._classes;
+         if (classes.has(className)) {
+           classes.delete(className);
+           return false;
+         } else {
+           classes.add(className);
+           return true;
+         }
+       }),
+       toString: vi.fn(() => Array.from((element.classList as any)._classes).join(' ')),
+     },
+     
+     dataset: {},
+     attributes: new Map<string, string>(),
+     children: [] as any[],
+     childNodes: [] as any[],
+     parentNode: null,
+     parentElement: null,
+     
+     // Enhanced Obsidian-specific methods
+     createEl: vi.fn((childTagName: string, childOptions?: any) => {
+       const child = createMockObsidianElement(childTagName as any, childOptions);
+       element.children.push(child);
+       element.childNodes.push(child);
+       (child as any).parentNode = element;
+       (child as any).parentElement = element;
+       return child;
+     }),
+     
+     createDiv: vi.fn((options?: any) => element.createEl('div', options)),
+     createSpan: vi.fn((options?: any) => element.createEl('span', options)),
+     createPara: vi.fn((options?: any) => element.createEl('p', options)),
+     
+     setText: vi.fn((text: string) => {
+       element.textContent = text;
+       element.innerHTML = text;
+       return element;
+     }),
+     
+     empty: vi.fn(() => {
+       element.children.length = 0;
+       element.childNodes.length = 0;
+       element.innerHTML = '';
+       element.textContent = '';
+       return element;
+     }),
+     
+     addClass: vi.fn((className: string) => {
+       element.classList.add(className);
+       return element;
+     }),
+     
+     removeClass: vi.fn((className: string) => {
+       element.classList.remove(className);
+       return element;
+     }),
+     
+     toggleClass: vi.fn((className: string) => {
+       element.classList.toggle(className);
+       return element;
+     }),
+     
+     setAttr: vi.fn((name: string, value: string) => {
+       element.attributes.set(name, value);
+       if (name === 'id') element.id = value;
+       if (name === 'type' && tagName === 'input') element.type = value;
+       return element;
+     }),
+     
+     getAttr: vi.fn((name: string) => {
+       return element.attributes.get(name) || '';
+     }),
+     
+     removeAttr: vi.fn((name: string) => {
+       element.attributes.delete(name);
+       return element;
+     }),
+     
+     appendChild: vi.fn((child: any) => {
+       element.children.push(child);
+       element.childNodes.push(child);
+       child.parentNode = element;
+       child.parentElement = element;
+       return child;
+     }),
+     
+     removeChild: vi.fn((child: any) => {
+       const index = element.children.indexOf(child);
+       if (index > -1) {
+         element.children.splice(index, 1);
+         element.childNodes.splice(index, 1);
+         child.parentNode = null;
+         child.parentElement = null;
+       }
+       return child;
+     }),
+     
+     querySelector: vi.fn((selector: string) => {
+       // Simple mock implementation for common selectors
+       if (selector.startsWith('.')) {
+         const className = selector.slice(1);
+         return element.children.find((child: any) => 
+           child.classList.contains(className)
+         ) || null;
+       }
+       if (selector.startsWith('#')) {
+         const id = selector.slice(1);
+         return element.children.find((child: any) => 
+           child.id === id
+         ) || null;
+       }
+       return element.children.find((child: any) => 
+         child.tagName.toLowerCase() === selector.toLowerCase()
+       ) || null;
+     }),
+     
+     querySelectorAll: vi.fn((selector: string) => {
+       // Simple mock implementation
+       if (selector.startsWith('.')) {
+         const className = selector.slice(1);
+         return element.children.filter((child: any) => 
+           child.classList.contains(className)
+         );
+       }
+       return element.children.filter((child: any) => 
+         child.tagName.toLowerCase() === selector.toLowerCase()
+       );
+     }),
+     
+     // Standard DOM event methods
+     addEventListener: vi.fn(),
+     removeEventListener: vi.fn(),
+     dispatchEvent: vi.fn(),
+     
+     // Standard DOM properties
+     get firstChild() { return element.children[0] || null; },
+     get lastChild() { return element.children[element.children.length - 1] || null; },
+     get childElementCount() { return element.children.length; },
+     
+     // Document reference
+     doc: {
+       createElement: vi.fn((tag: string) => createMockObsidianElement(tag as any)),
+       createDocumentFragment: vi.fn(() => ({ childNodes: [], appendChild: vi.fn() })),
+       location: { href: 'mock://obsidian' },
+       defaultView: {
+         getComputedStyle: vi.fn(() => ({})),
+       },
+     },
+   } as unknown as MockObsidianElement<T>;
+ 
+   // Apply initial classes if provided
+   if (options?.cls) {
+     element.classList.add(options.cls);
+   }
+   
+   // Apply any additional properties
+   Object.keys(options || {}).forEach(key => {
+     if (key !== 'cls' && key !== 'text' && key !== 'type') {
+       (element as any)[key] = options![key];
+     }
+   });
+ 
+   return element;
  }
  
```

---

Now let me create a proper test utility for creating plugin instances that use our enhanced mock system:

---

```diff
- 
+ import { vi } from 'vitest';
+ 
+ import type { App, PluginManifest } from 'obsidian';
+ import type ObsidianMagicPlugin from '../main';
+ 
+ // Test manifest for consistent testing
+ export const TEST_MANIFEST: PluginManifest = {
+   id: 'test-magus-mark',
+   name: 'Test Magus Mark',
+   version: '1.0.0',
+   minAppVersion: '0.15.0',
+   description: 'Test plugin',
+   author: 'Test',
+   authorUrl: 'https://test.com',
+   isDesktopOnly: false,
+ };
+ 
+ // Enhanced plugin test factory
+ export function createTestPlugin(
+   app?: App,
+   manifest?: PluginManifest,
+   overrides?: Partial<ObsidianMagicPlugin>
+ ): ObsidianMagicPlugin {
+   // Use enhanced mock system
+   const { createMockApp, Plugin } = require('../__mocks__/obsidian');
+   const testApp = app || createMockApp();
+   const testManifest = manifest || TEST_MANIFEST;
+ 
+   // Create plugin instance using the enhanced Plugin mock
+   const plugin = new (require('../main').default)(testApp, testManifest);
+ 
+   // Ensure all plugin methods are properly spied
+   const spyMethods = [
+     'onload',
+     'onunload', 
+     'loadData',
+     'saveData',
+     'addCommand',
+     'registerView',
+     'addSettingTab',
+     'addRibbonIcon',
+     'addStatusBarItem',
+   ];
+ 
+   spyMethods.forEach(method => {
+     if (typeof plugin[method] === 'function') {
+       vi.spyOn(plugin, method as keyof ObsidianMagicPlugin);
+     }
+   });
+ 
+   // Apply any overrides
+   if (overrides) {
+     Object.assign(plugin, overrides);
+   }
+ 
+   return plugin;
+ }
+ 
+ // Helper to create a plugin that's already loaded
+ export async function createLoadedTestPlugin(
+   app?: App,
+   manifest?: PluginManifest,
+   overrides?: Partial<ObsidianMagicPlugin>
+ ): Promise<ObsidianMagicPlugin> {
+   const plugin = createTestPlugin(app, manifest, overrides);
+   
+   // Mock loadData to return default settings
+   const { DEFAULT_SETTINGS } = require('../main');
+   vi.spyOn(plugin, 'loadData').mockResolvedValue(DEFAULT_SETTINGS);
+   
+   // Call onload to initialize services
+   await plugin.onload();
+   
+   return plugin;
+ }
+ 
+ // Helper to reset all plugin mocks
+ export function resetPluginMocks(): void {
+   vi.clearAllMocks();
+   
+   // Reset the mock constructors
+   const { Plugin, Setting, Modal, Notice } = require('../__mocks__/obsidian');
+   vi.mocked(Plugin).mockClear();
+   vi.mocked(Setting).mockClear();
+   vi.mocked(Modal).mockClear();
+   vi.mocked(Notice).mockClear();
+ } 
```

---

Now let me update the main plugin test to use our new enhanced mock system:

---

```diff
  import { beforeEach, describe, expect, it, vi } from 'vitest';
  
+ import { resetPluginMocks, createTestPlugin, TEST_MANIFEST } from './testing/createTestPlugin';
  import ObsidianMagicPlugin, { DEFAULT_SETTINGS } from './main';
  
- import type { App, PluginManifest } from 'obsidian';
- 
- // Create a proper test manifest
- const TEST_MANIFEST: PluginManifest = {
-   id: 'test-magus-mark',
-   name: 'Test Magus Mark',
-   version: '1.0.0',
-   minAppVersion: '0.15.0',
-   description: 'Test plugin',
-   author: 'Test',
-   authorUrl: 'https://test.com',
-   isDesktopOnly: false,
- };
+ import type { App } from 'obsidian';
  
  describe('ObsidianMagicPlugin', () => {
```

```diff
  
    beforeEach(async () => {
-     vi.clearAllMocks();
+     // Reset all mocks to ensure clean state
+     resetPluginMocks();
  
      const { createMockApp } = await import('./__mocks__/obsidian');
      mockAppInstance = createMockApp();
  
-     // Create plugin instance
-     plugin = new ObsidianMagicPlugin(mockAppInstance as unknown as App, TEST_MANIFEST);
- 
-     // Don't spy on loadData - let it run normally and just return empty/default data
+     // Create plugin instance using our enhanced factory
+     plugin = createTestPlugin(mockAppInstance, TEST_MANIFEST);
    });
  
    it('should load settings on initialization', async () => {
+     // Mock loadData to return default settings
+     vi.mocked(plugin.loadData).mockResolvedValue(DEFAULT_SETTINGS);
+ 
      await plugin.onload();
+     
      expect(plugin.loadData).toHaveBeenCalled();
      expect(plugin.settings).toEqual(DEFAULT_SETTINGS);
    });
  
    it('should initialize services on load', async () => {
+     // Mock loadData to return default settings  
+     vi.mocked(plugin.loadData).mockResolvedValue(DEFAULT_SETTINGS);
+ 
      console.log('Before onload, plugin.keyManager:', plugin.keyManager);
      console.log('Before onload, plugin.taggingService:', plugin.taggingService);
```

```diff
  
    it('should add ribbon icon based on settings', async () => {
-     // Spy on addRibbonIcon after plugin is created but before onload
-     const addRibbonIconSpy = vi.spyOn(plugin, 'addRibbonIcon').mockImplementation(vi.fn());
+     // Mock loadData to return default settings with ribbon enabled
+     vi.mocked(plugin.loadData).mockResolvedValue({ ...DEFAULT_SETTINGS, showRibbonIcon: true });
  
      await plugin.onload();
-     expect(addRibbonIconSpy).toHaveBeenCalledWith('tag', 'Magus Mark', expect.any(Function));
+     expect(plugin.addRibbonIcon).toHaveBeenCalledWith('tag', 'Magus Mark', expect.any(Function));
  
      // Test with ribbon icon disabled
-     const pluginNoRibbon = new ObsidianMagicPlugin(mockAppInstance as unknown as App, TEST_MANIFEST);
-     vi.spyOn(pluginNoRibbon, 'loadData').mockResolvedValue({ ...DEFAULT_SETTINGS, showRibbonIcon: false });
-     const noRibbonSpy = vi.spyOn(pluginNoRibbon, 'addRibbonIcon').mockImplementation(vi.fn());
+     const pluginNoRibbon = createTestPlugin(mockAppInstance, TEST_MANIFEST);
+     vi.mocked(pluginNoRibbon.loadData).mockResolvedValue({ ...DEFAULT_SETTINGS, showRibbonIcon: false });
  
      await pluginNoRibbon.onload();
-     expect(noRibbonSpy).not.toHaveBeenCalled();
+     expect(pluginNoRibbon.addRibbonIcon).not.toHaveBeenCalled();
    });
  
    it('should register views', async () => {
-     const registerViewSpy = vi.spyOn(plugin, 'registerView').mockImplementation(vi.fn());
+     vi.mocked(plugin.loadData).mockResolvedValue(DEFAULT_SETTINGS);
  
      await plugin.onload();
-     expect(registerViewSpy).toHaveBeenCalledWith('magus-mark-tag-management', expect.any(Function));
-     expect(registerViewSpy).toHaveBeenCalledWith('magus-mark-tag-visualization', expect.any(Function));
+     expect(plugin.registerView).toHaveBeenCalledWith('magus-mark-tag-management', expect.any(Function));
+     expect(plugin.registerView).toHaveBeenCalledWith('magus-mark-tag-visualization', expect.any(Function));
    });
  
    it('should add commands', async () => {
-     const addCommandSpy = vi.spyOn(plugin, 'addCommand').mockImplementation(vi.fn());
+     vi.mocked(plugin.loadData).mockResolvedValue(DEFAULT_SETTINGS);
  
      await plugin.onload();
-     expect(addCommandSpy).toHaveBeenCalledTimes(4);
-     expect(addCommandSpy).toHaveBeenCalledWith(expect.objectContaining({ id: 'tag-current-file' }));
+     expect(plugin.addCommand).toHaveBeenCalledTimes(4);
+     expect(plugin.addCommand).toHaveBeenCalledWith(expect.objectContaining({ id: 'tag-current-file' }));
    });
  
    it('should add setting tab', async () => {
-     const addSettingTabSpy = vi.spyOn(plugin, 'addSettingTab').mockImplementation(vi.fn());
+     vi.mocked(plugin.loadData).mockResolvedValue(DEFAULT_SETTINGS);
  
      await plugin.onload();
-     expect(addSettingTabSpy).toHaveBeenCalledWith(expect.any(Object));
+     expect(plugin.addSettingTab).toHaveBeenCalledWith(expect.any(Object));
    });
  
    it('should add status bar item based on settings', async () => {
-     const addStatusBarItemSpy = vi.spyOn(plugin, 'addStatusBarItem').mockImplementation(
-       () =>
-         ({
-           createEl: vi.fn(),
-           addClass: vi.fn(),
-           setText: vi.fn(),
-           setAttr: vi.fn(),
-         }) as unknown as HTMLElement
-     );
+     // Test with status bar enabled (default)
+     vi.mocked(plugin.loadData).mockResolvedValue({ ...DEFAULT_SETTINGS, statusBarDisplay: 'always' });
  
      await plugin.onload();
-     expect(addStatusBarItemSpy).toHaveBeenCalled();
+     expect(plugin.addStatusBarItem).toHaveBeenCalled();
  
      // Test with status bar disabled
-     const pluginNoStatus = new ObsidianMagicPlugin(mockAppInstance as unknown as App, TEST_MANIFEST);
-     vi.spyOn(pluginNoStatus, 'loadData').mockResolvedValue({ ...DEFAULT_SETTINGS, statusBarDisplay: 'never' });
-     const noStatusSpy = vi.spyOn(pluginNoStatus, 'addStatusBarItem').mockImplementation(
-       () =>
-         ({
-           createEl: vi.fn(),
-           addClass: vi.fn(),
-           setText: vi.fn(),
-           setAttr: vi.fn(),
-         }) as unknown as HTMLElement
-     );
+     const pluginNoStatus = createTestPlugin(mockAppInstance, TEST_MANIFEST);
+     vi.mocked(pluginNoStatus.loadData).mockResolvedValue({ ...DEFAULT_SETTINGS, statusBarDisplay: 'never' });
  
      await pluginNoStatus.onload();
-     expect(noStatusSpy).not.toHaveBeenCalled();
+     expect(pluginNoStatus.addStatusBarItem).not.toHaveBeenCalled();
    });
  
    it('should handle onunload correctly', async () => {
+     vi.mocked(plugin.loadData).mockResolvedValue(DEFAULT_SETTINGS);
+     
      await plugin.onload();
      plugin.onunload();
+     
      expect(mockAppInstance.workspace.detachLeavesOfType).toHaveBeenCalledWith('magus-mark-tag-management');
      expect(mockAppInstance.workspace.detachLeavesOfType).toHaveBeenCalledWith('magus-mark-tag-visualization');
```

---

Now let me update the FolderTagModal test to use our new enhanced mock system:

---

```diff
  import { beforeEach, describe, expect, it, vi } from 'vitest';
  
- import { createMockApp, createMockedPlugin } from '../__mocks__/obsidian';
+ import { resetPluginMocks, createTestPlugin } from '../testing/createTestPlugin';
  import { createMockObsidianElement } from '../testing/createMockObsidianElement';
  import { FolderTagModal } from './FolderTagModal';
  
- import type { App, ButtonComponent, TAbstractFile, TFolder } from 'obsidian';
- 
+ import type { TAbstractFile, TFolder } from 'obsidian';
  import type ObsidianMagicPlugin from '../main';
- 
- // Callback for tagging folder functionality
- const onSubmitCallback = vi.fn();
- 
- let testPlugin: ObsidianMagicPlugin;
- let testApp: App;
- let mockFilesAndFolders: TAbstractFile[];
  
  describe('FolderTagModal', () => {
    let modal: FolderTagModal;
+   let testPlugin: ObsidianMagicPlugin;
+   let onSubmitCallback: any;
+   let mockFilesAndFolders: TAbstractFile[];
  
-   beforeEach(() => {
-     // Reset mocks and state before each test
-     vi.clearAllMocks();
-     onSubmitCallback.mockClear();
- 
+   beforeEach(async () => {
+     // Reset all mocks to ensure clean state
+     resetPluginMocks();
+ 
+     // Set up test data
+     onSubmitCallback = vi.fn();
      mockFilesAndFolders = [
        {
          path: 'folder1',
          name: 'folder1',
-         parent: { path: '' } as TFolder,
+         parent: null,
          children: [],
          isFolder: () => true,
        } as unknown as TFolder,
        {
-         path: 'folder2',
+         path: 'folder2', 
          name: 'folder2',
-         parent: { path: '' } as TFolder,
+         parent: null,
          children: [],
          isFolder: () => true,
```

```diff
      ];
  
-     testApp = createMockApp();
-     testPlugin = createMockedPlugin() as unknown as ObsidianMagicPlugin;
+     // Create test plugin with mock app
+     const { createMockApp } = await import('../__mocks__/obsidian');
+     const testApp = createMockApp();
+     testPlugin = createTestPlugin(testApp);
  
-     // Mock methods on testApp.vault
+     // Mock vault methods
      vi.spyOn(testApp.vault, 'getAllLoadedFiles').mockReturnValue(mockFilesAndFolders);
      vi.spyOn(testApp.vault, 'getAbstractFileByPath').mockImplementation(
```

```diff
      it('should populate dropdown with folders', () => {
        modal.onOpen();
-       expect(testApp.vault.getAllLoadedFiles).toHaveBeenCalled();
+       expect(testPlugin.app.vault.getAllLoadedFiles).toHaveBeenCalled();
      });
  
```

```diff
        modal.onOpen();
  
-       expect(testApp.vault.getAllLoadedFiles).toHaveBeenCalled();
+       expect(testPlugin.app.vault.getAllLoadedFiles).toHaveBeenCalled();
        const listCreateEl = mockFolderList.createEl as any;
        expect(listCreateEl).toHaveBeenCalledWith('div', expect.objectContaining({ text: 'folder1' }));
```

```diff
  
        const privateModal = modal as any;
- 
        privateModal.folderItems = [folderItem1, folderItem2];
  
```

```diff
  
        const selectedFolder = { path: 'folder1', name: 'folder1', isFolder: () => true } as unknown as TFolder;
-       testApp.vault.getAbstractFileByPath = vi.fn().mockReturnValue(selectedFolder);
+       testPlugin.app.vault.getAbstractFileByPath = vi.fn().mockReturnValue(selectedFolder);
  
        privateModal.handleTagButtonClick();
```

```diff
  
        const selectedFolder = { path: 'folder1', name: 'folder1', isFolder: () => true } as unknown as TFolder;
-       testApp.vault.getAbstractFileByPath = vi.fn().mockReturnValue(selectedFolder);
+       testPlugin.app.vault.getAbstractFileByPath = vi.fn().mockReturnValue(selectedFolder);
  
        privateModal.handleTagButtonClick();
```

```diff
        modal.onOpen();
  
-       // Find the cancel button setting (should be the 4th Setting call)
-       const settingCalls = vi.mocked(Setting).mock.calls;
-       expect(settingCalls.length).toBeGreaterThanOrEqual(4);
+       // Verify Setting constructor was called
+       expect(vi.mocked(Setting)).toHaveBeenCalledTimes(4);
  
        // Get the cancel button setting instance (4th call result)
```

```diff
        }
  
+       // Get the button component from the addButton call
        const addButtonMock = vi.mocked(cancelButtonSetting.addButton);
        expect(addButtonMock).toHaveBeenCalled();
```

```diff
        expect(buttonConfigFn).toBeDefined();
  
+       // Create a mock button component that stores the click callback
        const mockCancelButton = {
          setButtonText: vi.fn().mockReturnThis(),
          onClick: vi.fn().mockImplementation((cb: () => void) => {
-           cb(); // Execute the callback immediately
+           // Store the callback for manual triggering
+           mockCancelButton._clickCallback = cb;
            return mockCancelButton;
          }),
-       } as unknown as ButtonComponent;
+         _clickCallback: undefined as (() => void) | undefined,
+         triggerClick: () => {
+           if (mockCancelButton._clickCallback) {
+             mockCancelButton._clickCallback();
+           }
+         },
+       } as any;
  
        modal.close = vi.fn();
```

```diff
        if (buttonConfigFn) {
          buttonConfigFn(mockCancelButton);
+         
+         // Trigger the click callback manually
+         mockCancelButton.triggerClick();
+         
          expect(modal.close).toHaveBeenCalled();
        }
```

---

Now let me run the tests to see if our enhanced mock system fixes the issues:

---

```bash
nx run magus-mark-obsidian-plugin:test --verbose
```

```
in magus-mark ➜ nx run magus-mark-obsidian-plugin:test --verbose

 NX   Cannot find project 'magus-mark-obsidian-plugin'

06:56:48 with khallmark at Voyager …
in magus-mark ➜
```

---

Let me check the correct project name:

---



---

```bash
nx run magus-mark-obsidian:test --verbose
```

```
in magus-mark ➜ nx run magus-mark-obsidian:test --verbose

> nx run magus-mark-core:build  [existing outputs match the cache, left as is]


> nx run magus-mark-obsidian:build

> tsc -p tsconfig.json --emitDeclarationOnly --outDir apps/obsidian-plugin/dist/types

src/__mocks__/obsidian.ts:3:10 - error TS2440: Import declaration conflicts with local declaration of 'createMockObsidianElement'.

3 import { createMockObsidianElement } from '../testing/createMockObsidianElement';
           ~~~~~~~~~~~~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:89:25 - error TS4111: Property 'display' comes from an index signature, so it must be accessed with ['display'].

89     return this._styles.display || '';
                           ~~~~~~~

src/__mocks__/obsidian.ts:93:18 - error TS4111: Property 'display' comes from an index signature, so it must be accessed with ['display'].

93     this._styles.display = value;
                    ~~~~~~~

src/__mocks__/obsidian.ts:136:43 - error TS2507: Type 'MockObsidianElement<"div">' is not a constructor function type.

136 class EnhancedMockObsidianElement extends createMockObsidianElement('div') {
                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:141:15 - error TS6133: 'tagName' is declared but its value is never read.

141   constructor(tagName: string) {
                  ~~~~~~~

src/__mocks__/obsidian.ts:148:10 - error TS2339: Property 'addClass' does not exist on type 'EnhancedMockObsidianElement'.

148     this.addClass = vi.fn((className: string) => {
             ~~~~~~~~

src/__mocks__/obsidian.ts:154:10 - error TS2339: Property 'removeClass' does not exist on type 'EnhancedMockObsidianElement'.

154     this.removeClass = vi.fn((className: string) => {
             ~~~~~~~~~~~

src/__mocks__/obsidian.ts:160:10 - error TS2339: Property 'toggleClass' does not exist on type 'EnhancedMockObsidianElement'.

160     this.toggleClass = vi.fn((className: string) => {
             ~~~~~~~~~~~

src/__mocks__/obsidian.ts:169:14 - error TS9010: Variable must have an explicit type annotation with --isolatedDeclarations.

169 export const Notice = vi.fn().mockImplementation(function (this: any, message: string, timeout = 5000) {
                 ~~~~~~

  src/__mocks__/obsidian.ts:169:14
    169 export const Notice = vi.fn().mockImplementation(function (this: any, message: string, timeout = 5000) {
                     ~~~~~~
    Add a type annotation to the variable Notice.

src/__mocks__/obsidian.ts:185:14 - error TS9010: Variable must have an explicit type annotation with --isolatedDeclarations.

185 export const Modal = vi.fn().mockImplementation(function (this: any, app: AppType) {
                 ~~~~~

  src/__mocks__/obsidian.ts:185:14
    185 export const Modal = vi.fn().mockImplementation(function (this: any, app: AppType) {
                     ~~~~~
    Add a type annotation to the variable Modal.

src/__mocks__/obsidian.ts:207:14 - error TS9010: Variable must have an explicit type annotation with --isolatedDeclarations.

207 export const Setting = vi.fn().mockImplementation(function (this: any, containerEl: any) {
                 ~~~~~~~

  src/__mocks__/obsidian.ts:207:14
    207 export const Setting = vi.fn().mockImplementation(function (this: any, containerEl: any) {
                     ~~~~~~~
    Add a type annotation to the variable Setting.

src/__mocks__/obsidian.ts:292:19 - error TS2339: Property '_clickCallback' does not exist on type '{ buttonEl: EnhancedMockObsidianElement; setButtonText
: Mock<() => { buttonEl: EnhancedMockObsidianElement; setButtonText: Mock<...>; ... 9 more ...; triggerClick: () => void; }>; ... 9 more ...; triggerClic
k: () => void; }'.

292         component._clickCallback = callback;
                      ~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:299:23 - error TS2339: Property '_clickCallback' does not exist on type '{ buttonEl: EnhancedMockObsidianElement; setButtonText
: Mock<() => { buttonEl: EnhancedMockObsidianElement; setButtonText: Mock<...>; ... 9 more ...; triggerClick: () => void; }>; ... 9 more ...; triggerClic
k: () => void; }'.

299         if (component._clickCallback) {
                          ~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:300:21 - error TS2339: Property '_clickCallback' does not exist on type '{ buttonEl: EnhancedMockObsidianElement; setButtonText
: Mock<() => { buttonEl: EnhancedMockObsidianElement; setButtonText: Mock<...>; ... 9 more ...; triggerClick: () => void; }>; ... 9 more ...; triggerClic
k: () => void; }'.

300           component._clickCallback();
                        ~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:403:5 - error TS2322: Type 'Mock<(tagName: string) => EnhancedMockObsidianElement>' is not assignable to type 'Mock<(tagName: s
tring) => MockObsidianElement>'.
  Types of property 'mock' are incompatible.
    Type 'MockContext<(tagName: string) => EnhancedMockObsidianElement>' is not assignable to type 'MockContext<(tagName: string) => MockObsidianElement>
'.
      Type '(tagName: string) => EnhancedMockObsidianElement' is not assignable to type '(tagName: string) => MockObsidianElement'.
        Type 'EnhancedMockObsidianElement' is not assignable to type 'MockObsidianElement'.
          Type 'EnhancedMockObsidianElement' is not assignable to type 'HTMLVideoElement & ObsidianElementExtras'.
            Type 'EnhancedMockObsidianElement' is missing the following properties from type 'HTMLVideoElement': disablePictureInPicture, height, onenter
pictureinpicture, onleavepictureinpicture, and 408 more.

403     this.createElement = vi.fn((tagName: string) => new EnhancedMockObsidianElement(tagName));
        ~~~~~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:451:14 - error TS2720: Class 'import("/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/obsidian-plugin/src/__mocks__
/obsidian").Component' incorrectly implements class 'import("/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_modules/.pnpm/obsidian@1.8.7_@co
demirror+state@6.5.2_@codemirror+view@6.36.8/node_modules/obsidian/obsidian").Component'. Did you mean to extend 'import("/Users/khallmark/Desktop/Code/n
eurotypic-ai/magus-mark/node_modules/.pnpm/obsidian@1.8.7_@codemirror+state@6.5.2_@codemirror+view@6.36.8/node_modules/obsidian/obsidian").Component' and
 inherit its members as a subclass?
  Property 'onunload' is missing in type 'import("/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/obsidian-plugin/src/__mocks__/obsidian").Co
mponent' but required in type 'import("/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_modules/.pnpm/obsidian@1.8.7_@codemirror+state@6.5.2_@
codemirror+view@6.36.8/node_modules/obsidian/obsidian").Component'.

451 export class Component extends Events implements ComponentType {
                 ~~~~~~~~~

  ../../node_modules/.pnpm/obsidian@1.8.7_@codemirror+state@6.5.2_@codemirror+view@6.36.8/node_modules/obsidian/obsidian.d.ts:904:5
    904     onunload(): void;
            ~~~~~~~~
    'onunload' is declared here.

src/__mocks__/obsidian.ts:469:3 - error TS4114: This member must have an 'override' modifier because it overrides a member in the base class 'Events'.

469   registerInterval: Mock<(id: number) => number> = vi.fn((id) => id);
      ~~~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:486:5 - error TS2322: Type 'EnhancedMockObsidianElement' is not assignable to type 'MockObsidianElement'.
  Type 'EnhancedMockObsidianElement' is not assignable to type 'HTMLVideoElement & ObsidianElementExtras'.
    Type 'EnhancedMockObsidianElement' is missing the following properties from type 'HTMLVideoElement': disablePictureInPicture, height, onenterpicturei
npicture, onleavepictureinpicture, and 408 more.

486     this.containerEl = new EnhancedMockObsidianElement('div');
        ~~~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:540:5 - error TS2322: Type 'EnhancedMockObsidianElement' is not assignable to type 'MockObsidianElement'.
  Type 'EnhancedMockObsidianElement' is not assignable to type 'HTMLVideoElement & ObsidianElementExtras'.
    Type 'EnhancedMockObsidianElement' is missing the following properties from type 'HTMLVideoElement': disablePictureInPicture, height, onenterpicturei
npicture, onleavepictureinpicture, and 408 more.

540     this.contentEl = new EnhancedMockObsidianElement('div');
        ~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:546:14 - error TS9010: Variable must have an explicit type annotation with --isolatedDeclarations.

546 export const Plugin = vi.fn().mockImplementation(function (this: any, app: AppType, manifest: any) {
                 ~~~~~~

  src/__mocks__/obsidian.ts:546:14
    546 export const Plugin = vi.fn().mockImplementation(function (this: any, app: AppType, manifest: any) {
                     ~~~~~~
    Add a type annotation to the variable Plugin.

src/__mocks__/obsidian/ItemView.ts:42:12 - error TS4117: This member cannot have an 'override' modifier because it is not declared in the base class 'Com
ponent'. Did you mean 'onload'?

42   override onunload: Mock<() => void> = vi.fn();
              ~~~~~~~~

src/testing/createMockObsidianElement.ts:25:32 - error TS6133: 'prop' is declared but its value is never read.

25       getPropertyValue: vi.fn((prop: string) => ''),
                                  ~~~~

src/testing/createMockObsidianElement.ts:63:24 - error TS2339: Property 'push' does not exist on type 'HTMLCollection'.

63       element.children.push(child);
                          ~~~~

src/testing/createMockObsidianElement.ts:64:26 - error TS2339: Property 'push' does not exist on type 'NodeListOf<ChildNode>'.

64       element.childNodes.push(child);
                            ~~~~

src/testing/createMockObsidianElement.ts:81:24 - error TS2540: Cannot assign to 'length' because it is a read-only property.

81       element.children.length = 0;
                          ~~~~~~

src/testing/createMockObsidianElement.ts:82:26 - error TS2540: Cannot assign to 'length' because it is a read-only property.

82       element.childNodes.length = 0;
                            ~~~~~~

src/testing/createMockObsidianElement.ts:104:26 - error TS2339: Property 'set' does not exist on type 'NamedNodeMap'.

104       element.attributes.set(name, value);
                             ~~~

src/testing/createMockObsidianElement.ts:106:59 - error TS2339: Property 'type' does not exist on type '(HTMLObjectElement | HTMLElement | HTMLAnchorElem
ent | HTMLAreaElement | HTMLAudioElement | ... 57 more ... | HTMLVideoElement) & ObsidianElementExtras'.
  Property 'type' does not exist on type 'HTMLElement & ObsidianElementExtras'.

106       if (name === 'type' && tagName === 'input') element.type = value;
                                                              ~~~~

src/testing/createMockObsidianElement.ts:111:33 - error TS2339: Property 'get' does not exist on type 'NamedNodeMap'.

111       return element.attributes.get(name) || '';
                                    ~~~

src/testing/createMockObsidianElement.ts:115:26 - error TS2339: Property 'delete' does not exist on type 'NamedNodeMap'.

115       element.attributes.delete(name);
                             ~~~~~~

src/testing/createMockObsidianElement.ts:120:24 - error TS2339: Property 'push' does not exist on type 'HTMLCollection'.

120       element.children.push(child);
                           ~~~~

src/testing/createMockObsidianElement.ts:121:26 - error TS2339: Property 'push' does not exist on type 'NodeListOf<ChildNode>'.

121       element.childNodes.push(child);
                             ~~~~

src/testing/createMockObsidianElement.ts:128:38 - error TS2339: Property 'indexOf' does not exist on type 'HTMLCollection'.

128       const index = element.children.indexOf(child);
                                         ~~~~~~~

src/testing/createMockObsidianElement.ts:130:26 - error TS2339: Property 'splice' does not exist on type 'HTMLCollection'.

130         element.children.splice(index, 1);
                             ~~~~~~

src/testing/createMockObsidianElement.ts:131:28 - error TS2339: Property 'splice' does not exist on type 'NodeListOf<ChildNode>'.

131         element.childNodes.splice(index, 1);
                               ~~~~~~

src/testing/createMockObsidianElement.ts:142:33 - error TS2339: Property 'find' does not exist on type 'HTMLCollection'.

142         return element.children.find((child: any) => child.classList.contains(className)) || null;
                                    ~~~~

src/testing/createMockObsidianElement.ts:146:33 - error TS2339: Property 'find' does not exist on type 'HTMLCollection'.

146         return element.children.find((child: any) => child.id === id) || null;
                                    ~~~~

src/testing/createMockObsidianElement.ts:148:31 - error TS2339: Property 'find' does not exist on type 'HTMLCollection'.

148       return element.children.find((child: any) => child.tagName.toLowerCase() === selector.toLowerCase()) || null;
                                  ~~~~

src/testing/createMockObsidianElement.ts:155:33 - error TS2339: Property 'filter' does not exist on type 'HTMLCollection'.

155         return element.children.filter((child: any) => child.classList.contains(className));
                                    ~~~~~~

src/testing/createMockObsidianElement.ts:157:31 - error TS2339: Property 'filter' does not exist on type 'HTMLCollection'.

157       return element.children.filter((child: any) => child.tagName.toLowerCase() === selector.toLowerCase());
                                  ~~~~~~

src/testing/createTestPlugin.ts:26:26 - error TS6133: 'Plugin' is declared but its value is never read.

26   const { createMockApp, Plugin } = require('../__mocks__/obsidian');
                            ~~~~~~

src/ui/TagManagementView.test.ts:3:10 - error TS2305: Module '"../__mocks__/obsidian"' has no exported member 'WorkspaceLeaf'.

3 import { WorkspaceLeaf, createMockApp, createMockedPlugin } from '../__mocks__/obsidian';
           ~~~~~~~~~~~~~


Found 42 errors in 5 files.

Errors  Files
    20  src/__mocks__/obsidian.ts:3
     1  src/__mocks__/obsidian/ItemView.ts:42
    19  src/testing/createMockObsidianElement.ts:25
     1  src/testing/createTestPlugin.ts:26
     1  src/ui/TagManagementView.test.ts:3

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

 NX   Ran target test for project magus-mark-obsidian and 2 task(s) they depend on (2s)

   ✖  1/2 failed
   ✔  1/2 succeeded [1 read from cache]


06:57:01 with khallmark at Voyager …
in magus-mark ➜
```

---

I see there are several TypeScript compilation errors that need to be fixed. Let me address them systematically:

---



---

```diff
  import { vi } from 'vitest';
- 
- import { createMockObsidianElement } from '../testing/createMockObsidianElement';
  
  import type {
```

```diff
  
    get display(): string {
-     return this._styles.display || '';
+     return this._styles['display'] || '';
    }
  
    set display(value: string) {
-     this._styles.display = value;
+     this._styles['display'] = value;
    }
  
```

```diff
  
  // Enhanced MockObsidianElement with proper DOM-like behavior
- class EnhancedMockObsidianElement extends createMockObsidianElement('div') {
+ class EnhancedMockObsidianElement {
+   tagName: string;
+   textContent: string;
+   innerHTML: string;
+   value: string;
+   checked: boolean;
+   disabled: boolean;
+   type: string;
+   id: string;
    style: MockCSSStyleDeclaration;
    classList: MockClassList;
    dataset: Record<string, string>;
+   children: any[];
+   childNodes: any[];
+   parentNode: any;
+   parentElement: any;
+   attributes: Map<string, string>;
+ 
+   createEl: Mock;
+   createDiv: Mock;
+   createSpan: Mock;
+   createPara: Mock;
+   setText: Mock;
+   empty: Mock;
+   addClass: Mock;
+   removeClass: Mock;
+   toggleClass: Mock;
+   setAttr: Mock;
+   getAttr: Mock;
+   removeAttr: Mock;
+   appendChild: Mock;
+   removeChild: Mock;
+   querySelector: Mock;
+   querySelectorAll: Mock;
+   addEventListener: Mock;
+   removeEventListener: Mock;
+   dispatchEvent: Mock;
+ 
+   doc: any;
  
    constructor(tagName: string) {
-     super();
+     this.tagName = tagName.toUpperCase();
+     this.textContent = '';
+     this.innerHTML = '';
+     this.value = '';
+     this.checked = false;
+     this.disabled = false;
+     this.type = '';
+     this.id = '';
      this.style = new MockCSSStyleDeclaration();
      this.classList = new MockClassList();
      this.dataset = {};
-     
-     // Override addClass to update classList
+     this.children = [];
+     this.childNodes = [];
+     this.parentNode = null;
+     this.parentElement = null;
+     this.attributes = new Map();
+     
+     // Initialize all methods as spies
+     this.createEl = vi.fn((childTagName: string, childOptions?: any) => {
+       const child = new EnhancedMockObsidianElement(childTagName);
+       this.children.push(child);
+       this.childNodes.push(child);
+       child.parentNode = this;
+       child.parentElement = this;
+       return child;
+     });
+ 
+     this.createDiv = vi.fn((options?: any) => this.createEl('div', options));
+     this.createSpan = vi.fn((options?: any) => this.createEl('span', options));
+     this.createPara = vi.fn((options?: any) => this.createEl('p', options));
+ 
+     this.setText = vi.fn((text: string) => {
+       this.textContent = text;
+       this.innerHTML = text;
+       return this;
+     });
+ 
+     this.empty = vi.fn(() => {
+       this.children.length = 0;
+       this.childNodes.length = 0;
+       this.innerHTML = '';
+       this.textContent = '';
+       return this;
+     });
+ 
      this.addClass = vi.fn((className: string) => {
        this.classList.add(className);
        return this;
      });
  
-     // Override removeClass to update classList  
      this.removeClass = vi.fn((className: string) => {
        this.classList.remove(className);
        return this;
      });
  
-     // Override toggleClass to update classList
      this.toggleClass = vi.fn((className: string) => {
        this.classList.toggle(className);
        return this;
      });
-   }
+ 
+     this.setAttr = vi.fn((name: string, value: string) => {
+       this.attributes.set(name, value);
+       if (name === 'id') this.id = value;
+       if (name === 'type') this.type = value;
+       return this;
+     });
+ 
+     this.getAttr = vi.fn((name: string) => {
+       return this.attributes.get(name) || '';
+     });
+ 
+     this.removeAttr = vi.fn((name: string) => {
+       this.attributes.delete(name);
+       return this;
+     });
+ 
+     this.appendChild = vi.fn((child: any) => {
+       this.children.push(child);
+       this.childNodes.push(child);
+       child.parentNode = this;
+       child.parentElement = this;
+       return child;
+     });
+ 
+     this.removeChild = vi.fn((child: any) => {
+       const index = this.children.indexOf(child);
+       if (index > -1) {
+         this.children.splice(index, 1);
+         this.childNodes.splice(index, 1);
+         child.parentNode = null;
+         child.parentElement = null;
+       }
+       return child;
+     });
+ 
+     this.querySelector = vi.fn((selector: string) => {
+       if (selector.startsWith('.')) {
+         const className = selector.slice(1);
+         return this.children.find((child: any) => 
+           child.classList && child.classList.contains(className)
+         ) || null;
+       }
+       if (selector.startsWith('#')) {
+         const id = selector.slice(1);
+         return this.children.find((child: any) => 
+           child.id === id
+         ) || null;
+       }
+       return this.children.find((child: any) => 
+         child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()
+       ) || null;
+     });
+ 
+     this.querySelectorAll = vi.fn((selector: string) => {
+       if (selector.startsWith('.')) {
+         const className = selector.slice(1);
+         return this.children.filter((child: any) => 
+           child.classList && child.classList.contains(className)
+         );
+       }
+       return this.children.filter((child: any) => 
+         child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()
+       );
+     });
+ 
+     this.addEventListener = vi.fn();
+     this.removeEventListener = vi.fn();
+     this.dispatchEvent = vi.fn();
+ 
+     this.doc = {
+       createElement: vi.fn((tag: string) => new EnhancedMockObsidianElement(tag)),
+       createDocumentFragment: vi.fn(() => ({ childNodes: [], appendChild: vi.fn() })),
+       location: { href: 'mock://obsidian' },
+       defaultView: {
+         getComputedStyle: vi.fn(() => ({})),
+       },
+     };
+   }
+ 
+   get firstChild() { return this.children[0] || null; }
+   get lastChild() { return this.children[this.children.length - 1] || null; }
+   get childElementCount() { return this.children.length; }
  }
  
  // ===== SPIED NOTICE CLASS =====
  
- export const Notice = vi.fn().mockImplementation(function (this: any, message: string, timeout = 5000) {
+ export const Notice: new (message: string, timeout?: number) => any = vi.fn().mockImplementation(function (this: any, message: string, timeout = 5000) {
    this.message = message;
    this.timeout = timeout;
```

```diff
  // ===== SPIED MODAL CLASS =====
  
- export const Modal = vi.fn().mockImplementation(function (this: any, app: AppType) {
+ export const Modal: new (app: AppType) => any = vi.fn().mockImplementation(function (this: any, app: AppType) {
    this.app = app;
    this.containerEl = new EnhancedMockObsidianElement('div');
```

```diff
  // ===== SPIED SETTING CLASS =====
  
- export const Setting = vi.fn().mockImplementation(function (this: any, containerEl: any) {
+ export const Setting: new (containerEl: any) => any = vi.fn().mockImplementation(function (this: any, containerEl: any) {
    // Create realistic mock elements
    this.settingEl = new EnhancedMockObsidianElement('div');
```

```diff
  
    this.addButton = vi.fn((cb: (component: any) => void) => {
-     const component = {
+     const component: any = {
        buttonEl: new EnhancedMockObsidianElement('button'),
        setButtonText: vi.fn(() => component),
```

```diff
    Setting: typeof Setting;
    isDesktopApp: boolean = Platform.isDesktopApp;
-   createElement: Mock<(tagName: string) => MockObsidianElement>;
+   createElement: Mock<(tagName: string) => any>;
    loadLocalStorage: Mock<() => Promise<null>>;
    saveLocalStorage: Mock<() => void>;
```

```diff
    onload: Mock<() => void> = vi.fn();
    unload: Mock<() => void> = vi.fn();
+   onunload: Mock<() => void> = vi.fn();
    addChild: <T extends ComponentType>(component: T) => T = vi.fn(
      <T extends ComponentType>(component: T): T => component
```

```diff
      (el: EventTarget, type: string, callback: (evt: any) => any, options?: boolean | AddEventListenerOptions) => void
    > = vi.fn();
-   registerInterval: Mock<(id: number) => number> = vi.fn((id) => id);
+   override registerInterval: Mock<(id: number) => number> = vi.fn((id) => id);
  }
  
```

```diff
    navigation: boolean = false;
    leaf: WorkspaceLeafType;
-   containerEl: MockObsidianElement;
+   containerEl: any;
    scope: ScopeType;
  
```

```diff
  
  export class ItemView extends View {
-   contentEl: MockObsidianElement;
+   contentEl: any;
  
    constructor(leaf: WorkspaceLeafType) {
```

```diff
  // ===== ENHANCED PLUGIN CLASS WITH AUTO-SPIED METHODS =====
  
- export const Plugin = vi.fn().mockImplementation(function (this: any, app: AppType, manifest: any) {
+ export const Plugin: new (app: AppType, manifest: any) => any = vi.fn().mockImplementation(function (this: any, app: AppType, manifest: any) {
    // Inherit from Component
    Object.setPrototypeOf(this, Component.prototype);
```

```diff
    tagName: T,
    options?: { cls?: string; text?: string; type?: string; [key: string]: any }
- ): MockObsidianElement<T> {
-   const element = new EnhancedMockObsidianElement(tagName) as any;
+ ): any {
+   const element = new EnhancedMockObsidianElement(tagName);
    
    if (options?.cls) {
```

```diff
      element.textContent = options.text;
    }
-   if (options?.type && tagName === 'input') {
+   if (options?.type) {
      element.type = options.type;
    }
```

```diff
    Object.keys(options || {}).forEach(key => {
      if (key !== 'cls' && key !== 'text' && key !== 'type') {
-       element[key] = options![key];
+       (element as any)[key] = options![key];
      }
    });
  
    return element;
  }
+ 
+ // Re-export remaining mock classes
+ export { WorkspaceLeaf } from './obsidian/WorkspaceLeaf';
+ export { PluginSettingTab } from './obsidian/PluginSettingTab';
+ export { Workspace } from './obsidian/Workspace';
  
```

---

Now I need to fix the other mock files and the testing utility:

---

```diff
  import { vi } from 'vitest';
  
+ import { Component } from './Component';
  import { createMockObsidianElement } from '../../testing/createMockObsidianElement';
- import { Component } from '../obsidian';
  
- import type { App, TFile } from 'obsidian';
+ import type { ItemView as ItemViewType, WorkspaceLeaf as WorkspaceLeafType } from 'obsidian';
+ import type { MockObsidianElement } from './MockObsidianElement';
  import type { Mock } from 'vitest';
  
- import type { WorkspaceLeaf } from './WorkspaceLeaf';
- 
- export class ItemView extends Component {
-   file?: TFile | null;
-   app: App;
-   leaf: WorkspaceLeaf;
-   containerEl: HTMLElement;
-   contentEl: HTMLElement;
- 
-   constructor(leaf: WorkspaceLeaf) {
+ export class ItemView extends Component implements ItemViewType {
+   navigation = true;
+   leaf: WorkspaceLeafType;
+   containerEl: MockObsidianElement<'div'>;
+   contentEl: MockObsidianElement<'div'>;
+   // The mocked app field comes from the component
+   app: any;
+   // The mocked scope field comes from the component
+   scope: any;
+ 
+   constructor(leaf: WorkspaceLeafType) {
      super();
      this.leaf = leaf;
-     this.containerEl = createMockObsidianElement<'div'>('div');
-     this.contentEl = createMockObsidianElement<'div'>('div');
-     this.app = leaf.app as unknown as App;
+     this.containerEl = createMockObsidianElement('div');
+     this.contentEl = createMockObsidianElement('div');
+     this.app = leaf.workspace?.app || {};
+     this.scope = this.app.scope || {};
  
      // Make instance methods mockable
```

```diff
      return this.containerEl;
    }
+ 
+   getViewType(): string {
+     return 'mock-item-view';
+   }
+   getDisplayText(): string {
+     return 'Mock Item View';
+   }
+   getIcon(): string {
+     return 'mock-icon';
+   }
+   getState(): any {
+     return {};
+   }
+   setState(_state: any, _result: any): Promise<void> {
+     return Promise.resolve();
+   }
+   getEphemeralState(): any {
+     return {};
+   }
+   setEphemeralState(_state: any): void {
+     // Mock implementation
+   }
+   onHeaderMenu(_menu: any): void {
+     // Mock implementation
+   }
+   onResize(): void {
+     // Mock implementation
+   }
+   onOpen(): Promise<void> {
+     return Promise.resolve();
+   }
+   onClose(): Promise<void> {
+     return Promise.resolve();
+   }
+   // Remove the incorrect override modifier since this method exists in Component
+   onunload: Mock<() => void> = vi.fn();
  
    // Override Component methods to make them mockable if needed
    override load: Mock<() => void> = vi.fn();
    override onload: Mock<() => void> = vi.fn();
-   override unload: Mock<() => void> = vi.fn();
-   override onunload: Mock<() => void> = vi.fn();
    override register: Mock<(cb: () => any) => void> = vi.fn((cb) => cb());
    override registerEvent: Mock<(ref: any) => void> = vi.fn();
```

---

Now let me fix the testing utility files:

---

```diff
      // Enhanced DOM-like behavior
      style: {
-       display: '',
+       _styles: {} as Record<string, string>,
+       get display() { return this._styles.display || ''; },
+       set display(value: string) { this._styles.display = value; },
        visibility: '',
        opacity: '',
-       getPropertyValue: vi.fn((prop: string) => ''),
+       getPropertyValue: vi.fn((_prop: string) => ''),
        setProperty: vi.fn(),
      },
```

```diff
        element.children.push(child);
        element.childNodes.push(child);
-       child.parentNode = element;
-       child.parentElement = element;
+       (child as any).parentNode = element;
+       (child as any).parentElement = element;
        return child;
      }),
```

```diff
      
      empty: vi.fn(() => {
-       element.children.length = 0;
-       element.childNodes.length = 0;
+       element.children.splice(0);
+       element.childNodes.splice(0);
        element.innerHTML = '';
        element.textContent = '';
```

```diff
        element.attributes.set(name, value);
        if (name === 'id') element.id = value;
-       if (name === 'type' && tagName === 'input') element.type = value;
+       if (name === 'type') (element as any).type = value;
        return element;
      }),
```

```diff
        if (selector.startsWith('.')) {
          const className = selector.slice(1);
-         return element.children.find((child: any) => child.classList.contains(className)) || null;
+         return element.children.find((child: any) => 
+           child.classList && child.classList.contains(className)
+         ) || null;
        }
        if (selector.startsWith('#')) {
          const id = selector.slice(1);
-         return element.children.find((child: any) => child.id === id) || null;
+         return element.children.find((child: any) => 
+           child.id === id
+         ) || null;
        }
-       return element.children.find((child: any) => child.tagName.toLowerCase() === selector.toLowerCase()) || null;
+       return element.children.find((child: any) => 
+         child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()
+       ) || null;
      }),
      
```

```diff
        if (selector.startsWith('.')) {
          const className = selector.slice(1);
-         return element.children.filter((child: any) => child.classList.contains(className));
+         return element.children.filter((child: any) => 
+           child.classList && child.classList.contains(className)
+         );
        }
-       return element.children.filter((child: any) => child.tagName.toLowerCase() === selector.toLowerCase());
+       return element.children.filter((child: any) => 
+         child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()
+       );
      }),
      
```

```diff
      
      // Standard DOM properties
-     get firstChild() {
-       return element.children[0] || null;
-     },
-     get lastChild() {
-       return element.children[element.children.length - 1] || null;
-     },
-     get childElementCount() {
-       return element.children.length;
-     },
+     get firstChild() { return element.children[0] || null; },
+     get lastChild() { return element.children[element.children.length - 1] || null; },
+     get childElementCount() { return element.children.length; },
      
      // Document reference
```

```diff
    
    // Apply any additional properties
-   Object.keys(options || {}).forEach((key) => {
+   Object.keys(options || {}).forEach(key => {
      if (key !== 'cls' && key !== 'text' && key !== 'type') {
        (element as any)[key] = options![key];
```

---

Now let me fix the createTestPlugin utility:

---

```diff
  ): ObsidianMagicPlugin {
    // Use enhanced mock system
-   const { createMockApp, Plugin } = require('../__mocks__/obsidian');
+   const { createMockApp } = require('../__mocks__/obsidian');
    const testApp = app || createMockApp();
    const testManifest = manifest || TEST_MANIFEST;
```

```diff
    ];
  
-   spyMethods.forEach((method) => {
+   spyMethods.forEach(method => {
      if (typeof plugin[method] === 'function') {
        vi.spyOn(plugin, method as keyof ObsidianMagicPlugin);
```

---

Now let me fix the TagManagementView test by adding the missing exports:

---

Read file: apps/obsidian-plugin/src/ui/TagManagementView.test.ts

---

```diff
  import { beforeEach, describe, expect, it, vi } from 'vitest';
  
- import { WorkspaceLeaf, createMockApp, createMockedPlugin } from '../__mocks__/obsidian';
+ import { resetPluginMocks, createTestPlugin } from '../testing/createTestPlugin';
  import { createMockObsidianElement } from '../testing/createMockObsidianElement';
  import { TagManagementView } from './TagManagementView';
  
  import type { App, CachedMetadata, TFile, WorkspaceLeaf as WorkspaceLeafType } from 'obsidian';
- 
  import type { MockObsidianElement } from '../__mocks__/obsidian/MockObsidianElement';
  import type ObsidianMagicPlugin from '../main';
```

```diff
    let view: TagManagementView;
    let mockContentContainer: HTMLElement; // Reference to the actual content area
-   let mockPlugin: ObsidianMagicPlugin; // Changed type to allow full plugin mock
+   let mockPlugin: ObsidianMagicPlugin;
    let mockApp: any;
    let mockLeaf: WorkspaceLeafType;
  
-   beforeEach(() => {
-     vi.clearAllMocks();
- 
+   beforeEach(async () => {
+     // Reset all mocks to ensure clean state
+     resetPluginMocks();
+ 
+     const { createMockApp, WorkspaceLeaf } = await import('../__mocks__/obsidian');
+     
      mockApp = createMockApp();
      mockLeaf = new WorkspaceLeaf() as unknown as WorkspaceLeafType;
      (mockLeaf as any).app = mockApp as unknown as App;
  
-     mockPlugin = createMockedPlugin() as unknown as ObsidianMagicPlugin; // Use createMockedPlugin
+     mockPlugin = createTestPlugin(mockApp);
  
      // Apply specific mocks to the app, metadataCache, and vault instances from the mocked plugin
```

```diff
        tags: [{ tag: '#inline-tag', position: { start: { line: 5 } } }],
      } as unknown as CachedMetadata);
+     
      vi.spyOn(mockPlugin.app.vault, 'getMarkdownFiles').mockReturnValue([
        { path: 'note1.md' },
```

```diff
      // Get the reference to the actual content container
      mockContentContainer = view.contentEl;
-     // No need to spyOn methods on mockContentContainer directly if using createMockObsidianElement's features
-     // If specific spies are needed on contentEl's methods (like empty, createEl), they can be set up here:
-     // e.g., vi.spyOn(mockContentContainer, 'empty'); vi.spyOn(mockContentContainer, 'createEl');
-     // However, createMockObsidianElement should already provide vi.fn() mocks for these.
-     // To assert on them, use vi.mocked(mockContentContainer.empty) or vi.mocked(mockContentContainer).empty
    });
  
```

---

Now let me run the tests to see if our enhanced mock system fixes the issues:

---

```bash
nx run magus-mark-obsidian:test --verbose
```

```
in magus-mark ➜ nx run magus-mark-obsidian:test --verbose

> nx run magus-mark-core:build  [existing outputs match the cache, left as is]


> nx run magus-mark-obsidian:build

> tsc -p tsconfig.json --emitDeclarationOnly --outDir apps/obsidian-plugin/dist/types

src/__mocks__/obsidian.ts:23:1 - error TS6133: 'MockObsidianElement' is declared but its value is never read.

23 import type { MockObsidianElement } from './obsidian/MockObsidianElement';
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/__mocks__/obsidian.ts:193:50 - error TS6133: 'childOptions' is declared but its value is never read.

193     this.createEl = vi.fn((childTagName: string, childOptions?: any) => {
                                                     ~~~~~~~~~~~~

src/__mocks__/obsidian/ItemView.ts:11:14 - error TS2720: Class 'import("/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/apps/obsidian-plugin/src/_
_mocks__/obsidian/ItemView").ItemView' incorrectly implements class 'import("/Users/khallmark/Desktop/Code/neurotypic-ai/magus-mark/node_modules/.pnpm/ob
sidian@1.8.7_@codemirror+state@6.5.2_@codemirror+view@6.36.8/node_modules/obsidian/obsidian").ItemView'. Did you mean to extend 'import("/Users/khallmark
/Desktop/Code/neurotypic-ai/magus-mark/node_modules/.pnpm/obsidian@1.8.7_@codemirror+state@6.5.2_@codemirror+view@6.36.8/node_modules/obsidian/obsidian")
.ItemView' and inherit its members as a subclass?
  Type 'ItemView' is missing the following properties from type 'ItemView': icon, onPaneMenu

11 export class ItemView extends Component implements ItemViewType {
                ~~~~~~~~

src/__mocks__/obsidian/ItemView.ts:14:3 - error TS4114: This member must have an 'override' modifier because it overrides a member in the base class 'Com
ponent'.

14   containerEl: MockObsidianElement<'div'>;
     ~~~~~~~~~~~

src/__mocks__/obsidian/ItemView.ts:26:21 - error TS2339: Property 'workspace' does not exist on type 'WorkspaceLeaf'.

26     this.app = leaf.workspace?.app || {};
                       ~~~~~~~~~

src/__mocks__/obsidian/ItemView.ts:76:3 - error TS4114: This member must have an 'override' modifier because it overrides a member in the base class 'Com
ponent'.

76   onunload: Mock<() => void> = vi.fn();
     ~~~~~~~~

src/testing/createMockObsidianElement.ts:24:29 - error TS4111: Property 'display' comes from an index signature, so it must be accessed with ['display'].

24         return this._styles.display || '';
                               ~~~~~~~

src/testing/createMockObsidianElement.ts:27:22 - error TS4111: Property 'display' comes from an index signature, so it must be accessed with ['display'].

27         this._styles.display = value;
                        ~~~~~~~

src/testing/createMockObsidianElement.ts:69:24 - error TS2339: Property 'push' does not exist on type 'HTMLCollection'.

69       element.children.push(child);
                          ~~~~

src/testing/createMockObsidianElement.ts:70:26 - error TS2339: Property 'push' does not exist on type 'NodeListOf<ChildNode>'.

70       element.childNodes.push(child);
                            ~~~~

src/testing/createMockObsidianElement.ts:87:24 - error TS2339: Property 'splice' does not exist on type 'HTMLCollection'.

87       element.children.splice(0);
                          ~~~~~~

src/testing/createMockObsidianElement.ts:88:26 - error TS2339: Property 'splice' does not exist on type 'NodeListOf<ChildNode>'.

88       element.childNodes.splice(0);
                            ~~~~~~

src/testing/createMockObsidianElement.ts:110:26 - error TS2339: Property 'set' does not exist on type 'NamedNodeMap'.

110       element.attributes.set(name, value);
                             ~~~

src/testing/createMockObsidianElement.ts:117:33 - error TS2339: Property 'get' does not exist on type 'NamedNodeMap'.

117       return element.attributes.get(name) || '';
                                    ~~~

src/testing/createMockObsidianElement.ts:121:26 - error TS2339: Property 'delete' does not exist on type 'NamedNodeMap'.

121       element.attributes.delete(name);
                             ~~~~~~

src/testing/createMockObsidianElement.ts:126:24 - error TS2339: Property 'push' does not exist on type 'HTMLCollection'.

126       element.children.push(child);
                           ~~~~

src/testing/createMockObsidianElement.ts:127:26 - error TS2339: Property 'push' does not exist on type 'NodeListOf<ChildNode>'.

127       element.childNodes.push(child);
                             ~~~~

src/testing/createMockObsidianElement.ts:134:38 - error TS2339: Property 'indexOf' does not exist on type 'HTMLCollection'.

134       const index = element.children.indexOf(child);
                                         ~~~~~~~

src/testing/createMockObsidianElement.ts:136:26 - error TS2339: Property 'splice' does not exist on type 'HTMLCollection'.

136         element.children.splice(index, 1);
                             ~~~~~~

src/testing/createMockObsidianElement.ts:137:28 - error TS2339: Property 'splice' does not exist on type 'NodeListOf<ChildNode>'.

137         element.childNodes.splice(index, 1);
                               ~~~~~~

src/testing/createMockObsidianElement.ts:148:33 - error TS2339: Property 'find' does not exist on type 'HTMLCollection'.

148         return element.children.find((child: any) => child.classList?.contains(className)) || null;
                                    ~~~~

src/testing/createMockObsidianElement.ts:152:33 - error TS2339: Property 'find' does not exist on type 'HTMLCollection'.

152         return element.children.find((child: any) => child.id === id) || null;
                                    ~~~~

src/testing/createMockObsidianElement.ts:155:26 - error TS2339: Property 'find' does not exist on type 'HTMLCollection'.

155         element.children.find(
                             ~~~~

src/testing/createMockObsidianElement.ts:165:33 - error TS2339: Property 'filter' does not exist on type 'HTMLCollection'.

165         return element.children.filter((child: any) => child.classList?.contains(className));
                                    ~~~~~~

src/testing/createMockObsidianElement.ts:167:31 - error TS2339: Property 'filter' does not exist on type 'HTMLCollection'.

167       return element.children.filter(
                                  ~~~~~~


Found 25 errors in 3 files.

Errors  Files
     2  src/__mocks__/obsidian.ts:23
     4  src/__mocks__/obsidian/ItemView.ts:11
    19  src/testing/createMockObsidianElement.ts:24

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

 NX   Ran target test for project magus-mark-obsidian and 2 task(s) they depend on (2s)

   ✖  1/2 failed
   ✔  1/2 succeeded [1 read from cache]


07:00:28 with khallmark at Voyager …
in magus-mark ➜
```

---

I still have some TypeScript errors to fix. Let me address them systematically:

---

```diff
  
      // Initialize all methods as spies
-     this.createEl = vi.fn((childTagName: string, childOptions?: any) => {
+     this.createEl = vi.fn((childTagName: string, _childOptions?: any) => {
        const child = new EnhancedMockObsidianElement(childTagName);
        this.children.push(child);
```

```diff
        if (selector.startsWith('.')) {
          const className = selector.slice(1);
-         return this.children.find((child: any) => child.classList && child.classList.contains(className)) || null;
+         return this.children.find((child: any) => 
+           child.classList && child.classList.contains(className)
+         ) || null;
        }
        if (selector.startsWith('#')) {
          const id = selector.slice(1);
-         return this.children.find((child: any) => child.id === id) || null;
+         return this.children.find((child: any) => 
+           child.id === id
+         ) || null;
        }
-       return (
-         this.children.find((child: any) => child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()) ||
-         null
-       );
+       return this.children.find((child: any) => 
+         child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()
+       ) || null;
      });
  
      this.querySelectorAll = vi.fn((selector: string) => {
        if (selector.startsWith('.')) {
          const className = selector.slice(1);
-         return this.children.filter((child: any) => child.classList && child.classList.contains(className));
+         return this.children.filter((child: any) => 
+           child.classList && child.classList.contains(className)
+         );
        }
-       return this.children.filter(
-         (child: any) => child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()
+       return this.children.filter((child: any) => 
+         child.tagName && child.tagName.toLowerCase() === selector.toLowerCase()
        );
      });
```

```diff
    }
  
-   get firstChild() {
-     return this.children[0] || null;
-   }
-   get lastChild() {
-     return this.children[this.children.length - 1] || null;
-   }
-   get childElementCount() {
-     return this.children.length;
-   }
+   get firstChild() { return this.children[0] || null; }
+   get lastChild() { return this.children[this.children.length - 1] || null; }
+   get childElementCount() { return this.children.length; }
  }
  
  // ===== SPIED NOTICE CLASS =====
  
- export const Notice: new (message: string, timeout?: number) => any = vi.fn().mockImplementation(function (
-   this: any,
-   message: string,
-   timeout = 5000
- ) {
+ export const Notice: new (message: string, timeout?: number) => any = vi.fn().mockImplementation(function (this: any, message: string, timeout = 5000) {
    this.message = message;
    this.timeout = timeout;
```

```diff
  // ===== SPIED SETTING CLASS =====
  
- export const Setting: new (containerEl: any) => any = vi.fn().mockImplementation(function (
-   this: any,
-   containerEl: any
- ) {
+ export const Setting: new (containerEl: any) => any = vi.fn().mockImplementation(function (this: any, containerEl: any) {
    // Create realistic mock elements
    this.settingEl = new EnhancedMockObsidianElement('div');
```

```diff
  // ===== ENHANCED PLUGIN CLASS WITH AUTO-SPIED METHODS =====
  
- export const Plugin: new (app: AppType, manifest: any) => any = vi.fn().mockImplementation(function (
-   this: any,
-   app: AppType,
-   manifest: any
- ) {
+ export const Plugin: new (app: AppType, manifest: any) => any = vi.fn().mockImplementation(function (this: any, app: AppType, manifest: any) {
    // Inherit from Component
    Object.setPrototypeOf(this, Component.prototype);
```

```diff
    
    // Add any additional properties
-   Object.keys(options || {}).forEach((key) => {
+   Object.keys(options || {}).forEach(key => {
      if (key !== 'cls' && key !== 'text' && key !== 'type') {
        (element as any)[key] = options![key];
```

---

Now let me fix the ItemView mock:

---

Error calling tool 'edit_file'.

---

```diff
  import { vi } from 'vitest';
  
+ import { Component } from './Component';
  import { createMockObsidianElement } from '../../testing/createMockObsidianElement';
- import { Component } from './Component';
  
  import type { ItemView as ItemViewType, WorkspaceLeaf as WorkspaceLeafType } from 'obsidian';
+ import type { MockObsidianElement } from './MockObsidianElement';
  import type { Mock } from 'vitest';
- 
- import type { MockObsidianElement } from './MockObsidianElement';
  
  export class ItemView extends Component implements ItemViewType {
    navigation = true;
+   icon = 'mock-icon';
    leaf: WorkspaceLeafType;
-   containerEl: MockObsidianElement<'div'>;
+   override containerEl: MockObsidianElement<'div'>;
    contentEl: MockObsidianElement<'div'>;
    // The mocked app field comes from the component
```

```diff
      this.containerEl = createMockObsidianElement('div');
      this.contentEl = createMockObsidianElement('div');
-     this.app = leaf.workspace?.app || {};
+     this.app = (leaf as any).app || {};
      this.scope = this.app.scope || {};
- 
-     // Make instance methods mockable
-     this.addAction = vi.fn(this.addAction.bind(this));
-   }
- 
-   addAction(icon: string, title: string, cb: (evt: MouseEvent) => any): HTMLElement {
-     console.log('addAction', icon, title, cb);
-     return createMockObsidianElement('div');
-   }
- 
-   getViewContainer(): HTMLElement {
-     return this.containerEl;
    }
  
```

```diff
    }
    getIcon(): string {
-     return 'mock-icon';
+     return this.icon;
    }
    getState(): any {
```

```diff
      // Mock implementation
    }
+   onPaneMenu(_menu: any, _source: string): void {
+     // Mock implementation - required by ItemView interface
+   }
    onResize(): void {
      // Mock implementation
```

```diff
      return Promise.resolve();
    }
-   // Remove the incorrect override modifier since this method exists in Component
-   onunload: Mock<() => void> = vi.fn();
+   override onunload: Mock<() => void> = vi.fn();
  
    // Override Component methods to make them mockable if needed
```

```diff
    override register: Mock<(cb: () => any) => void> = vi.fn((cb) => cb());
    override registerEvent: Mock<(ref: any) => void> = vi.fn();
-   override registerInterval: Mock<(id: number) => number> = vi.fn((id) => id || window.setInterval(vi.fn(), 1000));
-   override registerDomEvent: Mock<
-     (el: EventTarget, type: string, callback: (evt: any) => any, options?: boolean | AddEventListenerOptions) => void
-   > = vi.fn();
  }
  
```

---



Now let me fix the createMockObsidianElement to use proper array types:

---



---



---

