migration_guide:
  duckdb_node_neo:
    description: 'Implementation guide for database adapters in a multi-environment setup'

    important_notes:
      - title: 'API Changes'
        details: |
          Key differences in DuckDB Neo API:
          - Use `DuckDBInstance.create(path)` instead of `new Database(path)`
          - Connection is obtained via `await db.connect()` instead of `db.connect()`
          - Query execution is simpler:
            - Use `await connection.run(sql, values?, types?)` for direct execution
            - Use `await result.getRows()` to get all rows as an array
            - No need to manually close/finalize prepared statements
            - Prepared statements are optional and mainly for transactions
          - Close operations:
            - Use `connection.disconnect()` for connections (synchronous)
            - No need to close the database instance
          - Parameter binding:
            - Pass parameters directly to run: `connection.run(sql, values, types)`
            - Values must be DuckDBValue type
            - Types must be DuckDBType

      - title: 'Type Safety'
        details: |
          Enhanced type safety considerations:
          - Use `DatabaseRow` type for query results:
            ```typescript
            interface DatabaseRow {
              id: string;
              [key: string]: DuckDBValue | undefined;
            }
            ```
          - Convert DuckDB results to DatabaseRow:
            ```typescript
            function isDuckDBRow(row: unknown): row is Record<string, DuckDBValue> {
              return row !== null && typeof row === 'object' && !Array.isArray(row);
            }

            function convertToRow(duckDBRow: unknown): DatabaseRow {
              if (!isDuckDBRow(duckDBRow)) {
                throw new Error('Invalid row format from DuckDB');
              }
              
              const id = duckDBRow.id;
              if (typeof id !== 'string' && typeof id !== 'number') {
                throw new Error('Row is missing required id field');
              }

              return {
                id: String(id),
                ...Object.fromEntries(
                  Object.entries(duckDBRow).map(([key, value]) => [key, value as DuckDBValue])
                ),
              };
            }
            ```
          - Use `DuckDBValue` type for query parameters
          - Use `DuckDBType` for parameter type hints
          - QueryResult is now generic: `QueryResult<T extends DatabaseRow>`
          - Avoid using `any` or `unknown` in favor of proper types
          - Use type assertions carefully with `as` when converting results
          - DuckDB Neo types are more strict than the old version
          - Parameters must match DuckDBValue type exactly
          - Result rows must have an id field and DuckDBValue properties
          - Connection methods are properly typed with generics

      - title: 'Error Handling'
        details: |
          Proper error handling patterns:
          - All operations return Promises and should be properly awaited
          - Use try/catch blocks around database operations
          - Check for null/undefined before accessing results
          - Properly close resources in error cases
          - Use type guards to ensure type safety
          - Handle prepared statement cleanup (if used)
          - Ensure transactions are properly committed or rolled back
          - Always wrap non-Error throws in Error objects
          - Connection close is synchronous, no need to await
          - Validate row format and required fields
          - Handle missing or invalid id fields
          - Convert numeric ids to strings consistently

    types:
      description: |
        Common TypeScript types used across adapters:
        ```typescript
        import { 
          DuckDBInstance, 
          DuckDBConnection, 
          DuckDBResult,
          DuckDBResultReader,
          DuckDBValue,
          DuckDBType,
          DuckDBTypeId 
        } from '@duckdb/node-api';

        type QueryParams = DuckDBValue[] | Record<string, DuckDBValue>;
        type TypeParams = DuckDBType[] | Record<string, DuckDBType>;
        type RowResult = Record<string, any>;

        interface DuckDBMaterializedResult {
          readAll(): Promise<DuckDBResultReader>;
          getRows(): any[];
          getColumns(): any[];
        }

        // DuckDB specific type mappings
        interface TypeMappings {
          INTEGER: number;
          BIGINT: bigint;
          VARCHAR: string;
          TIMESTAMP: { micros: bigint; toString(): string; toParts(): { date: { year: number; month: number; day: number }, time: { hour: number; min: number; sec: number; micros: number } } };
          TIMESTAMP_MS: { milliseconds: bigint; toString(): string };
          TIMESTAMP_NS: { nanoseconds: bigint; toString(): string };
          TIMESTAMP_S: { seconds: bigint; toString(): string };
          TIME: { micros: bigint; toString(): string; toParts(): { hour: number; min: number; sec: number; micros: number } };
          TIME_TZ: { micros: bigint; offset: number; toString(): string; toParts(): { time: { hour: number; min: number; sec: number; micros: number }, offset: number } };
          BOOLEAN: boolean;
          DECIMAL: { value: bigint; width: number; scale: number; toString(): string; toDouble(): number };
          JSON: string;
          BLOB: { bytes: Uint8Array; toString(): string };
          ARRAY: { items: any[]; toString(): string };
          MAP: { entries: { key: any; value: any }[]; toString(): string };
          STRUCT: { entries: Record<string, any>; toString(): string };
        }
        ```

    architecture:
      - name: 'BrowserAdapter (Browser)'
        description: |
          WebAssembly-based adapter for browser environments. This adapter:
          - Uses DuckDB's WASM build for browser compatibility
          - Manages Web Worker lifecycle for background processing
          - Handles memory constraints of browser environment
          - Provides same query interface as ServerAdapter
          - Supports all DuckDB operations through WASM
          - Manages bundling and loading of WASM modules
          - Implements proper garbage collection
          - Handles browser-specific threading limitations
        details: |
          Browser adapter using DuckDB WASM:
          ```typescript
          import { AsyncDuckDB, AsyncDuckDBConnection } from '@duckdb/duckdb-wasm';

          export class BrowserAdapter implements IDatabaseAdapter {
            private db!: AsyncDuckDB;
            private conn!: AsyncDuckDBConnection;
            
            async init(): Promise<void> {
              const bundle = await duckdb.selectBundle(MANUAL_BUNDLES);
              const worker = new Worker(bundle.mainWorker);
              this.db = new duckdb.AsyncDuckDB(logger, worker);
              await this.db.instantiate(bundle.mainModule);
              this.conn = await this.db.connect();
            }
            
            async query<T = RowResult>(
              sql: string, 
              params: QueryParams = []
            ): Promise<T[]> {
              const prepared = await this.conn.prepare(sql);
              const result = await prepared.query(...params);
              return result.toArray() as T[];
            }
            
            async transaction<T>(callback: () => Promise<T>): Promise<T> {
              const prepared = await this.conn.prepare('BEGIN TRANSACTION');
              await prepared.run();
              try {
                const result = await callback();
                const commit = await this.conn.prepare('COMMIT');
                await commit.run();
                return result;
              } catch (error) {
                const rollback = await this.conn.prepare('ROLLBACK');
                await rollback.run();
                throw error;
              }
            }
          }
          ```

      - name: 'ServerAdapter (Node.js)'
        description: |
          Primary adapter for Node.js environment using DuckDB Neo. This adapter:
          - Provides full read/write capabilities using native DuckDB
          - Handles database file creation and management
          - Supports parameterized queries with type safety
          - Manages connection lifecycle and cleanup
          - Implements proper transaction support with rollback
          - Uses DuckDB Neo's async/await interface
          - Supports both in-memory and file-based databases
          - Handles complex data types through DuckDB's type system
        details: |
          Node.js adapter using DuckDB Neo:
          ```typescript
          import { DuckDBInstance, DuckDBConnection, DuckDBValue, DuckDBType } from '@duckdb/node-api';

          export class ServerAdapter implements IDatabaseAdapter {
            private db!: DuckDBInstance;
            private connection!: DuckDBConnection;
            
            constructor(private readonly dbPath = ':memory:') {}
            
            async init(): Promise<void> {
              this.db = await DuckDBInstance.create({
                path: this.dbPath
              });
              this.connection = await this.db.connect();
            }
            
            async query<T = RowResult>(
              sql: string, 
              values?: DuckDBValue[] | Record<string, DuckDBValue>,
              types?: DuckDBType[] | Record<string, DuckDBType>
            ): Promise<T[]> {
              if (values) {
                const prepared = await this.connection.prepare(sql);
                const result = await prepared.run(values, types);
                const reader = await result.readAll();
                return reader.getRows() as T[];
              }
              const result = await this.connection.run(sql);
              const reader = await result.readAll();
              return reader.getRows() as T[];
            }
            
            async close(): Promise<void> {
              await this.connection?.close();
              await this.db?.close();
            }
            
            async transaction<T>(callback: () => Promise<T>): Promise<T> {
              const prepared = await this.connection.prepare('BEGIN TRANSACTION');
              await prepared.run();
              try {
                const result = await callback();
                const commit = await this.connection.prepare('COMMIT');
                await commit.run();
                return result;
              } catch (error) {
                const rollback = await this.connection.prepare('ROLLBACK');
                await rollback.run();
                throw error;
              }
            }
            
            getDbPath(): string {
              return this.dbPath;
            }
          }
          ```

      - name: 'MockAdapter (Testing)'
        description: |
          In-memory JavaScript implementation for testing. This adapter:
          - Uses native JavaScript Maps for table storage
          - Implements basic SQL parsing for CRUD operations
          - Provides transaction support through state snapshots
          - Matches the real adapters' behavior for testing
          - Supports parameterized queries
          - Allows inspection of internal state
          - Can simulate network delays and errors
          - Provides debugging capabilities
          - Supports all repository operations without database dependency
        details: |
          In-memory adapter using JavaScript data structures:
          ```typescript
          export class MockAdapter implements IDatabaseAdapter {
            private tables: Map<string, any[]> = new Map();
            
            async init(): Promise<void> {
              // Initialize empty tables
              this.tables.clear();
            }
            
            async query<T = RowResult>(sql: string, params: QueryParams = []): Promise<T[]> {
              // Parse SQL and operate on this.tables
              // Example implementation for INSERT:
              if (sql.toLowerCase().startsWith('insert')) {
                const tableName = this.extractTableName(sql);
                const table = this.tables.get(tableName) || [];
                const newRow = this.createRow(sql, params);
                table.push(newRow);
                this.tables.set(tableName, table);
                return [newRow] as T[];
              }
              
              // Example implementation for SELECT:
              if (sql.toLowerCase().startsWith('select')) {
                const tableName = this.extractTableName(sql);
                return this.tables.get(tableName) || [];
              }
              
              return [];
            }
            
            async transaction<T>(callback: () => Promise<T>): Promise<T> {
              // Create snapshot of current state
              const snapshot = new Map(this.tables);
              try {
                const result = await callback();
                return result;
              } catch (error) {
                // Restore from snapshot on error
                this.tables = snapshot;
                throw error;
              }
            }
          }
          ```

    implementation_steps:
      - name: 'Common Query Interface'
        description: |
          The foundational interface that all adapters must implement. This interface:
          - Was designed by The Architect and should not be changed.
          - Defines the core contract for database operations
          - Ensures consistent behavior across all environments
          - Provides type safety through TypeScript definitions
          - Supports both synchronous and asynchronous operations
          - Handles connection lifecycle management
          - Enables transaction support
          - Maintains compatibility with existing repository patterns
          - Allows for future extensibility
        details: |
          All adapters should implement the same interface:
          ```typescript
          interface IDatabaseAdapter {
            init(): Promise<void>;
            query<T = RowResult>(sql: string, params?: QueryParams): Promise<T[]>;
            transaction<T>(callback: () => Promise<T>): Promise<T>;
            close(): Promise<void>;
            getDbPath(): string;
          }
          ```

      - name: 'Repository Layer'
        description: |
          The abstraction layer between business logic and database operations. This layer:
          - Abstracts adapter-specific implementation details
          - BaseRepository should encapsulate as much duplicate code as possible
          - Provides consistent data access patterns
          - Handles result type normalization
          - Manages entity mapping and transformation
          - Implements retry and error recovery strategies
          - Supports both single and batch operations
          - Maintains transaction boundaries
          - Enables testing through dependency injection
          - Ensures type safety through DatabaseRow validation
          - Provides robust error handling and debugging
        details: |
          Repositories work with any adapter:
          ```typescript
          export abstract class BaseRepository<T extends IBaseEntity, CreateDTO = T, UpdateDTO = Partial<T>> {
            constructor(protected adapter: IDatabaseAdapter) {}
            
            protected isDatabaseRow(item: unknown): item is DatabaseRow {
              if (item === null || typeof item !== 'object') {
                return false;
              }

              const record = item as Record<string, unknown>;
              return 'id' in record && typeof record.id === 'string';
            }

            protected isArrayOfDatabaseRows<R extends DatabaseRow>(data: unknown): data is R[] {
              if (!Array.isArray(data)) {
                return false;
              }

              return data.every((item) => this.isDatabaseRow(item));
            }

            protected async executeQuery<R extends DatabaseRow>(
              operation: string,
              query: string,
              params: QueryParams = []
            ): Promise<R[]> {
              try {
                // Log the query and its parameters
                console.log(`${this.errorTag} - Executing ${operation}:`);
                console.log('Query:', query);
                console.log('Params:', params);

                // Execute the query and get the results
                const result = await this.adapter.query<R>(query, params);

                // Log the results for debugging
                console.log(`${this.errorTag} - Query results:`, result);

                // Validate the results
                if (!this.isArrayOfDatabaseRows<R>(result)) {
                  throw new DatabaseResultError(
                    'Query result is not an array of database rows',
                    operation,
                    this.errorTag
                  );
                }

                return result;
              } catch (error) {
                this.logError(operation, error as Error);
                console.error(`${this.errorTag} - Query failed:`, error);
                throw new RepositoryError(
                  `Database operation '${operation}' failed: ${(error as Error).message}`,
                  operation,
                  this.errorTag,
                  error as Error
                );
              }
            }

            protected abstract mapToEntity(row: DatabaseRow): T;
          }
          ```

    next_steps:
      - 'Ensure BrowserAdapter handles all query types and commits transactions correctly'
      - 'Enhance MockAdapter with limited SQL parsing capabilities. Just needs to produce some data for visual testing.'
      - 'Update ServerAdapter with DuckDB Neo implementation that is built by the parsers/repositories'

    type_safety_improvements:
      - name: 'Database Row Types'
        description: |
          All database rows must extend DatabaseRow interface:
          ```typescript
          interface DatabaseRow {
            id: string;
            [key: string]: DuckDBValue | undefined;
          }
          ```
          This ensures:
          - Every row has a string ID
          - All other fields are DuckDBValue or undefined
          - No unknown or any types
          - Type safety across the entire database layer

      - name: 'Repository Layer'
        description: |
          Repositories now use strongly typed DTOs and entities:
          ```typescript
          abstract class BaseRepository<T extends IBaseEntity, CreateDTO = T, UpdateDTO = Partial<T>> {
            protected isDatabaseRow(item: unknown): item is DatabaseRow {
              if (item === null || typeof item !== 'object') {
                return false;
              }

              const record = item as Record<string, unknown>;
              return 'id' in record && typeof record.id === 'string';
            }

            protected isArrayOfDatabaseRows<R extends DatabaseRow>(data: unknown): data is R[] {
              if (!Array.isArray(data)) {
                return false;
              }

              return data.every((item) => this.isDatabaseRow(item));
            }

            protected buildUpdateQuery(updates: { field: string; value: DuckDBValue | undefined }[]): {
              query: string;
              values: QueryParams;
            }
          }
          ```

          Key improvements:
          - Type guards ensure runtime type safety
          - DuckDBValue used consistently for all database values
          - No more unknown types in query results
          - Better error handling with specific error types
          - Validation of all database operations

      - name: 'Query Parameters'
        description: |
          Query parameters are now strictly typed:
          ```typescript
          type QueryParams = (DuckDBValue | undefined)[];
          ```
          This ensures:
          - All parameters match DuckDB's expected types
          - No implicit type conversions
          - Better error messages for type mismatches
          - Consistent handling of null/undefined values

      - name: 'Error Handling'
        description: |
          New error types for better error handling:
          ```typescript
          class DatabaseResultError extends RepositoryError {
            constructor(message: string, operation: string, repository: string) {
              super(message, operation, repository);
              this.name = 'DatabaseResultError';
            }
          }
          ```
          Benefits:
          - Specific error types for different failure modes
          - Better error messages with context
          - Easier error handling in client code
          - Improved debugging experience
